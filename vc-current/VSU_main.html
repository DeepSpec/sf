<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>VSU_main: linking all the VSUs together with main VSU</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/vc.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<div id="page">

<div id="header">
<div id='logoinheader'><a href='https://softwarefoundations.cis.upenn.edu'>
<img src='common/media/image/sf_logo_sm.png' alt='Software Foundations Logo'></a></div>
<div class='booktitleinheader'><a href='index.html'>Volume 5: Verifiable C</a></div>
<ul id='menu'>
   <li class='section_name'><a href='toc.html'>Table of Contents</a></li>
   <li class='section_name'><a href='coqindex.html'>Index</a></li>
</ul>
</div>

<div id="main">

<h1 class="libtitle">VSU_main<span class="subtitle">linking all the VSUs together with main VSU</span></h1>


<div class="doc">

<div class="paragraph"> </div>

 This file is not only a VSU for the "main" function, but also shows
  how to link all the VSUs together to make a complete verified program.

<div class="paragraph"> </div>

  The <span class="inlinecode"><span class="id" title="var">main</span>()</span> function is special, in VST's separation logic, in that the SEP clause
  of its precondition contains <i>all</i> the global variables of <i>all</i> the modules.

<div class="paragraph"> </div>

  That won't be very noticeable in this example (stdlib/stack/triang/main), because
  none of the modules has global variables.  But in general, each module has its own
  "extern" or "static" global variables, initialized or default-zero-initialized.  They 
  constitute the initial footprint (in the separation-logic sense) of the program.

<div class="paragraph"> </div>

   We might expect that each module -- each .c file, or each VSU -- manages (some
  subset of) its own global variables as "private with a hidden representation".
  Clients of the module can refer to this using an abstract predicate, an APD.

<div class="paragraph"> </div>

   Indeed, the <span class="inlinecode"><span class="id" title="var">mem_mgr</span></span> predicate serves exactly this role:  it serves as an
   abstraction for the data structures that the malloc/free system uses to manage
   its free-list.  When we write,
<pre>
     Precondition: PROP ... LOCAL ... SEP(mem_mgr M gv; other_stuff)
       p = malloc(n);
     Precondition: PROP ... LOCAL ... SEP(data_at ...; mem_mgr M gv; other_stuff)
</pre>
   the <span class="inlinecode"><span class="id" title="var">mem_mgr</span></span> <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode"><span class="id" title="var">gv</span></span> in the postcondition stands for a <i>different state</i> of the
   free-list (with one item removed from it) compared to the <span class="inlinecode"><span class="id" title="var">mem_mgr</span></span> <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode"><span class="id" title="var">gv</span></span> in
   the precondition.

<div class="paragraph"> </div>

   When verifying any program in VST, the precondition of main (written as <span class="inlinecode"><span class="id" title="var">main_pre</span></span>) 
   contains all of these global variables.  The <span class="inlinecode"><span class="id" title="var">start_function</span></span> tactic
   for VSUs has the job of abstracting these into into module-specific APDs,
   using the mkInitPred lemma that comes with each VSU, as you will see. 
<div class="paragraph"> </div>

<a id="lab204"></a><h1 class="section">The VSU for main</h1>

<div class="paragraph"> </div>

 This VSU has the standard preamble: 
</div>
<div class="code">

<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">VST.floyd.proofauto</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">VST.floyd.VSU</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">VC.main2</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="library">VC.stdlib</span> <span class="id" title="library">VC.stack2</span> <span class="id" title="library">VC.triang2</span>.<br/>
<span class="id" title="keyword">Require</span> <a class="idref" href="Spec_stdlib.html#"><span class="id" title="library">VC.Spec_stdlib</span></a> <a class="idref" href="Spec_stack.html#"><span class="id" title="library">VC.Spec_stack</span></a> <a class="idref" href="Spec_triang.html#"><span class="id" title="library">VC.Spec_triang</span></a>.<br/>
</div>

<div class="doc">
<a id="lab205"></a><h2 class="section">Funspec for main function</h2>

<div class="paragraph"> </div>

 Because the funspec for main refers to all the initial values of all
    the global variables of all the modules, before writing <span class="inlinecode"><span class="id" title="var">main_spec</span></span>
    we must link all the modules together into a single program. 
<div class="paragraph"> </div>

 First, gain access to the VSUs that we have built. 
</div>
<div class="code">
<span class="id" title="keyword">Require</span> <a class="idref" href="VSU_stdlib.html#"><span class="id" title="library">VC.VSU_stdlib</span></a> <a class="idref" href="VSU_stack.html#"><span class="id" title="library">VC.VSU_stack</span></a> <a class="idref" href="VSU_triang.html#"><span class="id" title="library">VC.VSU_triang</span></a>.<br/>
</div>

<div class="doc">
Those VSUs are parametrized by Abstract Predicate Definitions (APDs),
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">M</span></span>,  the internal data representation of the malloc/free library, and

</li>
<li> <span class="inlinecode"><span class="id" title="var">STACK</span></span>, the internal data representation of the stack module.

</li>
</ul>
  For example, the StackVSU is parametrized by M, and the TriangVSU is
  parametrized by both M and STACK.

<div class="paragraph"> </div>

 But now in linking the whole program together, we must instantiate those
 parameters with the actual representations defined in their respective VSUs: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="M" class="idref" href="#M"><span class="id" title="definition">M</span></a> : <a class="idref" href="Spec_stdlib.html#MallocFreeAPD"><span class="id" title="record">Spec_stdlib.MallocFreeAPD</span></a> := <a class="idref" href="VSU_stdlib.html#M"><span class="id" title="axiom">VSU_stdlib.M</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a id="STACK" class="idref" href="#STACK"><span class="id" title="definition">STACK</span></a> : <a class="idref" href="Spec_stack.html#StackAPD"><span class="id" title="record">Spec_stack.StackAPD</span></a> := <a class="idref" href="VSU_stack.html#STACK"><span class="id" title="definition">VSU_stack.STACK</span></a> <a class="idref" href="VSU_main.html#M"><span class="id" title="definition">M</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a id="stackVSU" class="idref" href="#stackVSU"><span class="id" title="definition">stackVSU</span></a> := <a class="idref" href="VSU_stack.html#StackVSU"><span class="id" title="lemma">VSU_stack.StackVSU</span></a> <a class="idref" href="VSU_main.html#M"><span class="id" title="definition">M</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a id="triangVSU" class="idref" href="#triangVSU"><span class="id" title="definition">triangVSU</span></a> := <a class="idref" href="VSU_triang.html#TriangVSU"><span class="id" title="axiom">VSU_triang.TriangVSU</span></a> <a class="idref" href="VSU_main.html#M"><span class="id" title="definition">M</span></a> <a class="idref" href="VSU_main.html#STACK"><span class="id" title="definition">STACK</span></a>.<br/>
</div>

<div class="doc">
Each VSU has
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">Externs</span></span> :   functions entirely external to the whole C program, such as system calls
               and assembly-language functions that we won't prove in VST.  The
               function-specifications (funspecs) that we give for these functions are
               <i>axioms</i>  (but see "Connecting Higher-Order Separation Logic to a 
               First-Order Outside World" by Mansky et al. 2020 to see how these axioms
               can be proved as theorems in Coq).

</li>
<li> <span class="inlinecode"><span class="id" title="var">Imports</span></span>:  functions external to <i>this</i> module, but which will be proved in other VSUs;
               the <span class="inlinecode"><span class="id" title="var">Imports</span></span> list says what funspecs we assume about them.

</li>
<li> <span class="inlinecode"><span class="id" title="var">Exports</span></span>:  functions exported from this module, with funspecs guaranteed by proofs.

</li>
<li> <span class="inlinecode"><span class="id" title="var">G</span></span>:   funspecs of <i>internal</i> functions of the module.  Since these functions are
        not exported, not used in other modules, we don't need to "publish" these
        funspecs; they existed only in support of <span class="inlinecode"><span class="id" title="var">semax_body</span></span> proofs of the exported
         functions.  Therefore, the <span class="inlinecode"><span class="id" title="var">G</span></span> list is private to the VSU, and hidden by Coq's
         opacity mechanisms.

<div class="paragraph"> </div>

   Let's examine the Externs, Imports, and Exports of StackVSU and TriangVSU: 

</li>
</ul>
</div>
<div class="code">

<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">hnf</span> <span class="id" title="keyword">in</span> <span class="id" title="definition">VSU_Externs</span> <a class="idref" href="VSU_main.html#stackVSU"><span class="id" title="definition">stackVSU</span></a>. <span class="comment">(*&nbsp;nil&nbsp;*)</span><br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">hnf</span> <span class="id" title="keyword">in</span> <span class="id" title="definition">VSU_Imports</span> <a class="idref" href="VSU_main.html#stackVSU"><span class="id" title="definition">stackVSU</span></a>. <span class="comment">(*&nbsp;malloc,&nbsp;free,&nbsp;exit&nbsp;*)</span><br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">hnf</span> <span class="id" title="keyword">in</span> <span class="id" title="definition">VSU_Exports</span> <a class="idref" href="VSU_main.html#stackVSU"><span class="id" title="definition">stackVSU</span></a>. <span class="comment">(*&nbsp;newstack,&nbsp;push,&nbsp;pop&nbsp;*)</span><br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">hnf</span> <span class="id" title="keyword">in</span> <span class="id" title="definition">VSU_Externs</span> <a class="idref" href="VSU_main.html#triangVSU"><span class="id" title="definition">triangVSU</span></a>. <span class="comment">(*&nbsp;nil&nbsp;*)</span><br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">hnf</span> <span class="id" title="keyword">in</span> <span class="id" title="definition">VSU_Imports</span> <a class="idref" href="VSU_main.html#triangVSU"><span class="id" title="definition">triangVSU</span></a>. <span class="comment">(*&nbsp;newstack,&nbsp;push,&nbsp;pop&nbsp;*)</span><br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">hnf</span> <span class="id" title="keyword">in</span> <span class="id" title="definition">VSU_Exports</span> <a class="idref" href="VSU_main.html#triangVSU"><span class="id" title="definition">triangVSU</span></a>. <span class="comment">(*&nbsp;triang&nbsp;*)</span><br/>
</div>

<div class="doc">
We link together <span class="inlinecode"><span class="id" title="var">stackVSU</span></span> and <span class="inlinecode"><span class="id" title="var">triangVSU</span></span> to make <span class="inlinecode"><span class="id" title="var">stacktriangVSU1</span></span>: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="stacktriangVSU1" class="idref" href="#stacktriangVSU1"><span class="id" title="definition">stacktriangVSU1</span></a> := <span class="id" title="keyword">ltac</span>:(<span class="id" title="var">linkVSUs</span> <a class="idref" href="VSU_main.html#stackVSU"><span class="id" title="definition">stackVSU</span></a> <a class="idref" href="VSU_main.html#triangVSU"><span class="id" title="definition">triangVSU</span></a>).<br/>
</div>

<div class="doc">
When we link VSUs, C=linkVSUs(A,B),  the Imports of C are the union of
   the Imports of A and B, <i>minus</i> the defined functions (and externs) of A and B.
   So, for example, newstack,push,pop are imported by triangVSU,
  but they are not in the Imports of stacktriangVSU because they are provided 
  by stackVSU.

<div class="paragraph"> </div>

  Similarly, the Exports of C are the union of the Exports of A and B. 
</div>
<div class="code">

<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="definition">VSU_Externs</span> <a class="idref" href="VSU_main.html#stacktriangVSU1"><span class="id" title="definition">stacktriangVSU1</span></a>. <span class="comment">(*&nbsp;nil&nbsp;*)</span><br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="definition">VSU_Imports</span> <a class="idref" href="VSU_main.html#stacktriangVSU1"><span class="id" title="definition">stacktriangVSU1</span></a>. <span class="comment">(*&nbsp;malloc,&nbsp;free,&nbsp;exit&nbsp;*)</span><br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="definition">VSU_Exports</span> <a class="idref" href="VSU_main.html#stacktriangVSU1"><span class="id" title="definition">stacktriangVSU1</span></a>. <span class="comment">(*&nbsp;newstack,&nbsp;push,&nbsp;pop,&nbsp;triang&nbsp;*)</span><br/>
</div>

<div class="doc">
If we view stack+triang as a module, then what is the client view?
   (Hint:  the client is main.c, so what functions does main() call?)
  The client computes the triangular number of N.  So therefore this module
  should not export <span class="inlinecode"><span class="id" title="var">newstack</span>,<span class="id" title="var">push</span>,<span class="id" title="var">pop</span></span> to the client; it should export only
  <span class="inlinecode"><span class="id" title="var">triang</span></span>.  The stack functions are there only to support the triang function.

<div class="paragraph"> </div>

  To make a stack+triang  VSU that exports only triang, we start with 
  stacktriangVSU1, and privatize the three functions that we want to hide
  from clients.  As follows: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="stacktriangVSU" class="idref" href="#stacktriangVSU"><span class="id" title="definition">stacktriangVSU</span></a> :=<br/>
&nbsp;<span class="id" title="lemma">privatizeExports</span> <a class="idref" href="VSU_main.html#stacktriangVSU1"><span class="id" title="definition">stacktriangVSU1</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">[</span></a><span class="id" title="definition">stack2._newstack</span><a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">;</span></a> <span class="id" title="definition">stack2._push</span><a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">;</span></a> <span class="id" title="definition">stack2._pop</span><a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">]</span></a>.<br/>
</div>

<div class="doc">
Having done that, we can examine the exports of this new VSU: 
</div>
<div class="code">

<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="definition">VSU_Exports</span> <a class="idref" href="VSU_main.html#stacktriangVSU"><span class="id" title="definition">stacktriangVSU</span></a>. <span class="comment">(*&nbsp;triang&nbsp;*)</span><br/>
</div>

<div class="doc">
Next, let's examine the MallocFreeVSU:  
</div>
<div class="code">

<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">hnf</span> <span class="id" title="keyword">in</span> <span class="id" title="definition">VSU_Externs</span> <a class="idref" href="VSU_stdlib.html#MallocFreeVSU"><span class="id" title="definition">VSU_stdlib.MallocFreeVSU</span></a>. <span class="comment">(*&nbsp;malloc,&nbsp;free,&nbsp;exit&nbsp;*)</span><br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">hnf</span> <span class="id" title="keyword">in</span> <span class="id" title="definition">VSU_Imports</span> <a class="idref" href="VSU_stdlib.html#MallocFreeVSU"><span class="id" title="definition">VSU_stdlib.MallocFreeVSU</span></a>. <span class="comment">(*&nbsp;nil&nbsp;*)</span><br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">hnf</span> <span class="id" title="keyword">in</span> <span class="id" title="definition">VSU_Exports</span> <a class="idref" href="VSU_stdlib.html#MallocFreeVSU"><span class="id" title="definition">VSU_stdlib.MallocFreeVSU</span></a>. <span class="comment">(*&nbsp;malloc,&nbsp;free,&nbsp;exit&nbsp;*)</span><br/>
</div>

<div class="doc">
What we learn here (which we could have known already by reading VSU_stdlib.v)
   is that malloc,free,exit are <i>external</i> functions, not implemented within the
   entire C program we are verifying.  Once the MallocFree module (stdlib.c)
   re-exports them, the clients (such as stackVSU) will treat them as ordinary Imports,
   not knowing the difference.  
<div class="paragraph"> </div>

  We link the stacktriangVSU with the MallocFreeVSU.   We can do the privateExports
    step at the same time, without needing a separate Definition. 
</div>
<div class="code">

<span class="id" title="keyword">Time</span> <span class="id" title="keyword">Definition</span> <a id="coreVSU" class="idref" href="#coreVSU"><span class="id" title="definition">coreVSU</span></a> := <br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="lemma">privatizeExports</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">ltac</span>:(<span class="id" title="var">linkVSUs</span> <a class="idref" href="VSU_main.html#stacktriangVSU"><span class="id" title="definition">stacktriangVSU</span></a> <a class="idref" href="VSU_stdlib.html#MallocFreeVSU"><span class="id" title="definition">VSU_stdlib.MallocFreeVSU</span></a>)<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">[</span></a><span class="id" title="definition">stdlib._malloc</span><a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">;</span></a> <span class="id" title="definition">stdlib._free</span><a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">;</span></a> <span class="id" title="definition">stdlib._exit</span><a class="idref" href="http://coq.inria.fr/library//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">]</span></a> .<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="definition">VSU_Externs</span> <a class="idref" href="VSU_main.html#coreVSU"><span class="id" title="definition">coreVSU</span></a>. <span class="comment">(*&nbsp;malloc,&nbsp;free,&nbsp;exit&nbsp;*)</span><br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="definition">VSU_Imports</span> <a class="idref" href="VSU_main.html#coreVSU"><span class="id" title="definition">coreVSU</span></a>. <span class="comment">(*&nbsp;nil&nbsp;*)</span><br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="definition">VSU_Exports</span> <a class="idref" href="VSU_main.html#coreVSU"><span class="id" title="definition">coreVSU</span></a>. <span class="comment">(*&nbsp;triang&nbsp;*)</span><br/>
</div>

<div class="doc">
We call this the "core" VSU for a specific reason:  It's everything except main().
   We have to treat main() specially, because the <span class="inlinecode"><span class="id" title="var">main</span></span> function is the one that
   receives the initial values of all the global variables -- even the ones in other
  modules.  This is just a feature of how Separation Logic accounts for these variables.

<div class="paragraph"> </div>

   So therefore, the "recipe" is this:  First, construct the coreVSU that includes
   everything except main;  then construct the whole_prog that's the entire
   program including main: 
</div>
<div class="code">

<span class="id" title="keyword">Time</span> <span class="id" title="keyword">Definition</span> <a id="whole_prog" class="idref" href="#whole_prog"><span class="id" title="definition">whole_prog</span></a> := <span class="id" title="keyword">ltac</span>:(<span class="id" title="var">QPlink_progs</span> (<span class="id" title="definition">QPprog</span> <span class="id" title="definition">prog</span>) (<span class="id" title="definition">VSU_prog</span> <a class="idref" href="VSU_main.html#coreVSU"><span class="id" title="definition">coreVSU</span></a>)).<br/>
</div>

<div class="doc">
The main point about whole_prog is that it contains the intializers for
   every global variable <i>including</i> main.  

<div class="paragraph"> </div>

   The funspec for <span class="inlinecode"><span class="id" title="var">main</span></span> should have precondition <span class="inlinecode"><span class="id" title="var">main_pre</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span> <span class="inlinecode"><span class="id" title="var">gv</span></span>, where
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">p</span></span> is the program (e.g., all the .c files linked together),

</li>
<li> <span class="inlinecode"><span class="id" title="var">z</span></span> is the "external oracle" characterizing the initial state of the outside world,

</li>
<li> <span class="inlinecode"><span class="id" title="var">gv</span></span> is the usual global-variable mapping.

</li>
</ul>

<div class="paragraph"> </div>

 Because our stacktriang program doesn't interact with the outside world, the type of its
 external oracle can be simply <span class="inlinecode"><span class="id" title="var">unit</span></span>, and for <span class="inlinecode"><span class="id" title="var">z</span></span> we can use <span class="inlinecode"><span class="id" title="var">tt</span></span>.   Which is to say,
 we have been using NullExtension.Espec as the Espec for all our VSUs in this program,
 and <span class="inlinecode">@<span class="id" title="var">OK_ty</span></span> <span class="inlinecode"><span class="id" title="var">NullExtension.Espec</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">tt</span></span>.

<div class="paragraph"> </div>

 The definition <span class="inlinecode"><span class="id" title="var">main_pre</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span> <span class="inlinecode"><span class="id" title="var">gv</span></span> calculates a separation-logic mpred that characterizes
 all the initialized global variables of the program <span class="inlinecode"><span class="id" title="var">p</span></span>.

<div class="paragraph"> </div>

 The postcondition of <span class="inlinecode"><span class="id" title="var">main_spec</span></span>, in this case, says that it returns the
 10th triangular number. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="main_spec" class="idref" href="#main_spec"><span class="id" title="definition">main_spec</span></a> :=<br/>
&nbsp;<span class="id" title="notation">DECLARE</span> <span class="id" title="definition">_main</span><br/>
&nbsp;<span class="id" title="notation">WITH</span> <a id="gv:2" class="idref" href="#gv:2"><span class="id" title="binder">gv</span></a><span class="id" title="notation">:</span> <span class="id" title="definition">globals</span><br/>
&nbsp;<span class="id" title="notation">PRE</span> <span class="id" title="notation">[</span> <span class="id" title="notation">]</span> <span class="id" title="definition">main_pre</span> <a class="idref" href="VSU_main.html#whole_prog"><span class="id" title="definition">whole_prog</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="VSU_main.html#gv:1"><span class="id" title="variable">gv</span></a><br/>
&nbsp;<span class="id" title="notation">POST</span><span class="id" title="notation">[</span> <span class="id" title="definition">tint</span> <span class="id" title="notation">]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">PROP</span><span class="id" title="notation">()</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">RETURN</span> <span class="id" title="notation">(</span><span class="id" title="constructor">Vint</span> (<span class="id" title="definition">Int.repr</span> 55)<span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">SEP</span><span class="id" title="notation">(</span><span class="id" title="method">TT</span><span class="id" title="notation">)</span>.<br/>
</div>

<div class="doc">
Soon we will prove <span class="inlinecode"><span class="id" title="var">semax_body</span></span> <span class="inlinecode"><span class="id" title="var">V</span></span> <span class="inlinecode"><span class="id" title="var">G</span></span> <span class="inlinecode"><span class="id" title="var">f_main</span></span> <span class="inlinecode"><span class="id" title="var">main_spec</span></span>,  where <span class="inlinecode"><span class="id" title="var">f_main</span></span>
   is the function-body from main.c, and main_spec is the funspec just above. 
</div>
<div class="code">

<span class="id" title="keyword">Locate</span> <span class="id" title="var">f_main</span>. <span class="comment">(*&nbsp;VC&nbsp;main2.f_main&nbsp;*)</span><br/>
</div>

<div class="doc">
In order to prove a semax_body, we need a CompSpecs (which is an implicit
  parameter of @semax_body).  We compute this in the ordinary way from
   VC.main2.prog, just as you would in any module.  
</div>
<div class="code">
<span class="id" title="keyword">Instance</span> <a id="Compspecs" class="idref" href="#Compspecs"><span class="id" title="instance">Compspecs</span></a>: <span class="id" title="class">compspecs</span>. <span class="id" title="var">make_compspecs</span> <span class="id" title="definition">VC.main2.prog</span>. <span class="id" title="keyword">Defined</span>.<br/>
</div>

<div class="doc">
It's important to build this <span class="inlinecode"><span class="id" title="keyword">Instance</span></span> <i>after</i> the <span class="inlinecode"><span class="id" title="keyword">Require</span></span> statements just above,
 so that this is the <span class="inlinecode"><span class="id" title="var">compspecs</span></span> instance that typeclass-resolution will find, instead
 of finding <span class="inlinecode"><span class="id" title="var">VSU_stdlib.CompSpecs</span></span>, <span class="inlinecode"><span class="id" title="var">VSU_stack.CompSpecs</span></span>, etc. 
<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" title="var">body_main</span></span> lemma will need a Vprog, which in this case must
  be the <span class="inlinecode"><span class="id" title="var">varspecs</span></span> for the whole program: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="Vprog" class="idref" href="#Vprog"><span class="id" title="definition">Vprog</span></a>: <span class="id" title="definition">varspecs</span> := <span class="id" title="definition">QPvarspecs</span> <a class="idref" href="VSU_main.html#whole_prog"><span class="id" title="definition">whole_prog</span></a>.<br/>
</div>

<div class="doc">
The Gprog for main is, as usual, the funspecs of all the functions in this
   module plus the Imports of this module. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="Main_imports" class="idref" href="#Main_imports"><span class="id" title="definition">Main_imports</span></a>: <span class="id" title="definition">funspecs</span> := <a class="idref" href="Spec_triang.html#TriangASI"><span class="id" title="definition">Spec_triang.TriangASI</span></a> <a class="idref" href="VSU_main.html#M"><span class="id" title="definition">M</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a id="Main_Gprog" class="idref" href="#Main_Gprog"><span class="id" title="definition">Main_Gprog</span></a> : <span class="id" title="definition">funspecs</span> := <a class="idref" href="VSU_main.html#main_spec"><span class="id" title="definition">main_spec</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#::list_scope:x_'::'_x"><span class="id" title="notation">::</span></a> <a class="idref" href="VSU_main.html#Main_imports"><span class="id" title="definition">Main_imports</span></a>.<br/>
</div>

<div class="doc">
<a id="lab206"></a><h1 class="section">Proof of body_main</h1>

<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" title="var">semax_body</span></span> proof for <span class="inlinecode"><span class="id" title="var">main</span></span> is <i>almost</i> like any other,
 except that before <span class="inlinecode"><span class="id" title="var">start_function</span></span> we do <span class="inlinecode"><span class="id" title="tactic">pose</span></span> <span class="inlinecode"><span class="id" title="var">proof</span></span> <span class="inlinecode"><span class="id" title="var">Core_VSU</span></span>.
 This signals to <span class="inlinecode"><span class="id" title="var">start_function</span></span> that it can use the <span class="inlinecode"><span class="id" title="var">mkInitPred</span></span>
 lemmas from <span class="inlinecode"><span class="id" title="var">Core_VSU</span></span> to process all the global variables 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="body_main" class="idref" href="#body_main"><span class="id" title="lemma">body_main</span></a>: <span class="id" title="definition">semax_body</span> <a class="idref" href="VSU_main.html#Vprog"><span class="id" title="definition">Vprog</span></a> <a class="idref" href="VSU_main.html#Main_Gprog"><span class="id" title="definition">Main_Gprog</span></a> <span class="id" title="definition">f_main</span> <a class="idref" href="VSU_main.html#main_spec"><span class="id" title="definition">main_spec</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">pose</span> <a class="idref" href="VSU_main.html#coreVSU"><span class="id" title="definition">coreVSU</span></a>.<br/>
<span class="id" title="var">start_function</span>.<br/>
<span class="id" title="tactic">fold</span> <a class="idref" href="VSU_main.html#M"><span class="id" title="definition">M</span></a>. <span class="comment">(*&nbsp;See&nbsp;"Exercise:&nbsp;Delete"&nbsp;below&nbsp;to&nbsp;see&nbsp;why&nbsp;this&nbsp;is&nbsp;needed&nbsp;*)</span><br/>
</div>

<div class="doc">
Now the SEP clause of the precondition is, <span class="inlinecode"></span> <span class="inlinecode">(<span class="id" title="var">Spec_stdlib.mem_mgr</span></span> <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode"><span class="id" title="var">gv</span>;</span> <span class="inlinecode"><span class="id" title="var">has_ext</span></span> <span class="inlinecode"><span class="id" title="var">tt</span>)</span> <span class="inlinecode"></span>

<div class="paragraph"> </div>

 In general, there will be one clause for each VSU that has a
 state predicate, plus a <span class="inlinecode"><span class="id" title="var">has_ext</span></span> clause to characterize the
 external world.  In this program, which does no I/O, the
 external world is trivial, characterized by the unit value <span class="inlinecode"><span class="id" title="var">tt</span></span>.
 In this program, just one of the modules has a state predicate;
 that's the <span class="inlinecode"><span class="id" title="var">stdlib</span></span> module with its <span class="inlinecode"><span class="id" title="var">mem_mgr</span></span> predicate.
 That was put into the SEP clause by <span class="inlinecode"><span class="id" title="var">start_function</span></span>, signalled
 to do so by <span class="inlinecode"><span class="id" title="tactic">pose</span></span> <span class="inlinecode"><span class="id" title="var">proof</span></span> <span class="inlinecode"><span class="id" title="var">Core_VSU</span></span>. 
<div class="paragraph"> </div>

 Now, as usual prove correctness of the function body.  Start with a
  <span class="inlinecode"><span class="id" title="var">forward_call</span>(<span class="id" title="var">XX</span>)</span> to the <span class="inlinecode"><span class="id" title="var">triang</span></span> function.  The parameter XX will 
 depend on what you have put in the WITH clause of the <span class="inlinecode"><span class="id" title="var">triang_spec</span></span>
 in <a href="Spec_triang.html"><span class="inlineref">Spec_triang</span></a>. 
</div>
<div class="code">
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
Exercise:  Once you've finished the proof of <span class="inlinecode"><span class="id" title="var">body_main</span></span>, go back and delete the
   <span class="inlinecode"><span class="id" title="tactic">fold</span></span> <span class="inlinecode"><span class="id" title="var">M</span></span> near the top of <span class="inlinecode"><span class="id" title="var">body_main</span></span>, and proceed to the point immediately
  after the <span class="inlinecode"><span class="id" title="var">forward_call</span></span>.  You'll probably see an extra proof obligation here, 
  which is provable by (fold M; cancel).   That suggests why the <span class="inlinecode"><span class="id" title="tactic">fold</span></span> <span class="inlinecode"><span class="id" title="var">M</span></span> is
  useful at the top of the function. 
<div class="paragraph"> </div>

<a id="lab207"></a><h1 class="section">The Main Component, the Whole Component</h1>

<div class="paragraph"> </div>

 There are several different concepts (and types) here:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">Clight.program</span></span>   is the Abstract Syntax Tree (AST) of a Clight program 
                as produced by clightgen;

</li>
<li> <span class="inlinecode"><span class="id" title="var">QP.program</span></span>  is an alternate version of that AST that's more
                efficient to link computationally in Coq;

</li>
<li> <span class="inlinecode"><span class="id" title="var">Component</span></span> is a set of correctness proofs (and other property proofs) about
                a QP.program;

</li>
<li> <span class="inlinecode"><span class="id" title="var">VSU</span></span> is a <span class="inlinecode"><span class="id" title="var">Component</span></span> with its internal funspecs hidden by Coq's abstraction
       mechanism (sigT), and with the component's varspecs in a standard form.

</li>
</ul>

<div class="paragraph"> </div>

  Unlike ordinary modules, we don't turn main.c (or the module containing main())
  into a VSU; it's slightly nonstandard because it imports the "varspecs" of all
  the other modules (i.e., global-variable-initializer specifications).   We make
  a <span class="inlinecode"><span class="id" title="var">Component</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="MainComp" class="idref" href="#MainComp"><span class="id" title="definition">MainComp</span></a>:  <span class="id" title="definition">MainCompType</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> <span class="id" title="keyword">ltac</span>:(<span class="id" title="var">QPprog</span> <span class="id" title="definition">prog</span>) <a class="idref" href="VSU_main.html#coreVSU"><span class="id" title="definition">coreVSU</span></a> <a class="idref" href="VSU_main.html#whole_prog"><span class="id" title="definition">whole_prog</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#snd"><span class="id" title="definition">snd</span></a> <a class="idref" href="VSU_main.html#main_spec"><span class="id" title="definition">main_spec</span></a>) <span class="id" title="method">emp</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="var">mkComponent</span> <span class="id" title="definition">prog</span>.<br/>
</div>

<div class="doc">
Now, for each function in the Main module, we have a solve_SF_internal just
   as we would (for ordinary components) after <span class="inlinecode"><span class="id" title="var">mkVSU</span></span>. 
</div>
<div class="code">
- <span class="id" title="var">solve_SF_internal</span> <a class="idref" href="VSU_main.html#body_main"><span class="id" title="axiom">body_main</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The arguments of MainCompType (above) are,
<ul class="doclist">
<li>  nil,   the Externs of Main, just in case main() calls some system-calls directly
                  (in this case, there are none);

</li>
<li> (QPprog prog),   the main.c program,

</li>
<li> coreVSU,   the VSU of the entire program except main.c;

</li>
<li> whole_prog,   the whole program including main.c+core;

</li>
<li> snd main_spec,  the funspec of the main function;

</li>
<li> emp,   the separation-logic characterization of all the global variables 
                     of main.c (in this case, there are none).  

</li>
</ul>

<div class="paragraph"> </div>

 Having made the Main component, we link it with the coreVSU to form the
    Component corresponding to the whole program. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="WholeComp" class="idref" href="#WholeComp"><span class="id" title="lemma">WholeComp</span></a>: <span class="id" title="definition">WholeCompType</span> <a class="idref" href="VSU_main.html#coreVSU"><span class="id" title="definition">coreVSU</span></a> <a class="idref" href="VSU_main.html#MainComp"><span class="id" title="definition">MainComp</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="var">proveWholeComponent</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab208"></a><h1 class="section">Soundness!</h1>

</div>
<div class="code">

<span class="id" title="keyword">Import</span> <span class="id" title="var">SeparationLogicSoundness.VericMinimumSeparationLogic.CSHL_Defs</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">VST.veric.SequentialClight</span>.<br/>
</div>

<div class="doc">
VST's program logic is proved sound with respect to the operational semantics
   of Clight.  That means, 
<ul class="doclist">
<li> if you prove in VST that some program satisfies its specification, written
      as <span class="inlinecode">@<span class="id" title="var">semax_prog</span></span> <span class="inlinecode"><span class="id" title="var">Espec</span></span> <span class="inlinecode"><span class="id" title="var">CompSpecs</span></span> <span class="inlinecode"><span class="id" title="var">prog</span></span> <span class="inlinecode"><span class="id" title="var">init</span></span> <span class="inlinecode"><span class="id" title="var">V</span></span> <span class="inlinecode"><span class="id" title="var">G</span></span>

</li>
<li> then (in the operational semantics of CompCert Clight) it will behave 
      according to that specification. 

</li>
</ul>
</div>
<div class="code">

<span class="id" title="keyword">About</span> <span class="id" title="definition">semax_prog</span>. <span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;semax_prog&nbsp;:&nbsp;forall&nbsp;{Espec&nbsp;:&nbsp;OracleKind},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compspecs&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;Clight.program&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;OK_ty&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;varspecs&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;funspecs&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;Prop&nbsp;*)</span><br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">semax_prog</span></span> basically means that all the function-bodies in prog satisfy their
      funspecs in G, along with some other useful side-conditions. 
<div class="paragraph"> </div>

 If we could just prove <span class="inlinecode"><span class="id" title="var">semax_prog</span></span> about a program, then we could apply
 the following soundness theorem to prove it runs correctly: 
</div>
<div class="code">
<span class="id" title="keyword">Check</span> <span class="id" title="lemma">whole_program_sequential_safety_ext</span>.<br/>
</div>

<div class="doc">
That's a complicated theorem-statement, but the main premise is
<ul class="doclist">
<li>  <span class="inlinecode"><span class="id" title="var">semax_prog</span></span> <span class="inlinecode"><span class="id" title="var">prog</span></span> <span class="inlinecode"><span class="id" title="var">initial_oracle</span></span> <span class="inlinecode"><span class="id" title="var">V</span></span> <span class="inlinecode"><span class="id" title="var">G</span></span>

</li>
</ul>
   meaning "you proved the program correct",  and the main conclusion is
<ul class="doclist">
<li>  <span class="inlinecode"><span class="id" title="var">step_lemmas.dry_safeN</span></span> <span class="inlinecode">...</span>

</li>
</ul>
   meaning "the program runs safely, interacting correctly as specified 
   with its external environment."

<div class="paragraph"> </div>

   What we want from the VSU system is a proof that the C program you get by
   linking all these VSUs together (with the MainComponent) satisfies <span class="inlinecode"><span class="id" title="var">semax_prog</span></span>. 
   And here is that theorem: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="WholeProgSafe" class="idref" href="#WholeProgSafe"><span class="id" title="lemma">WholeProgSafe</span></a>: <span class="id" title="definition">WholeProgSafeType</span> <a class="idref" href="VSU_main.html#WholeComp"><span class="id" title="lemma">WholeComp</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="var">proveWholeProgSafe</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
And you can see what was just proved by unfolding WholeProgSafeType: 
</div>
<div class="code">

<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">red</span> <span class="id" title="keyword">in</span> (<span class="id" title="definition">WholeProgSafeType</span> <a class="idref" href="VSU_main.html#WholeComp"><span class="id" title="lemma">WholeComp</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a>).<br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;{G&nbsp;:&nbsp;funspecs<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;semax_prog&nbsp;(prog_of_component&nbsp;WholeComp)&nbsp;tt&nbsp;(QPvarspecs&nbsp;whole_prog)&nbsp;G}&nbsp;*)</span><br/>
</div>

<div class="doc">
or in other words, there exists a complete set <span class="inlinecode"><span class="id" title="var">G</span></span> of funspecs (for all the
    functions in the program) such that the Clight program corresponding to 
    the WholeComponent is proved correct.  Now we could apply 
    <span class="inlinecode"><span class="id" title="var">whole_program_sequential_safety_ext</span></span> to get the corollary that the program
   runs correctly. 
<div class="paragraph"> </div>

<a id="lab209"></a><h2 class="section">Next Chapter: <a href="VSU_stdlib2.html"><span class="inlineref">VSU_stdlib2</span></a></h2>

</div>
<div class="code">

<span class="comment">(*&nbsp;2022-02-04&nbsp;18:24&nbsp;*)</span><br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>