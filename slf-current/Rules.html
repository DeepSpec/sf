<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>Rules: Reasoning Rules</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/slf.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<div id="page">

<div id="header">
<div id='logoinheader'><a href='https://softwarefoundations.cis.upenn.edu'>
<img src='common/media/image/sf_logo_sm.png' alt='Software Foundations Logo'></a></div>
<div class='booktitleinheader'><a href='index.html'>Volume 6: Separation Logic Foundations</a></div>
<ul id='menu'>
   <li class='section_name'><a href='toc.html'>Table of Contents</a></li>
   <li class='section_name'><a href='coqindex.html'>Index</a></li>
   <li class='section_name'><a href='deps.html'>Roadmap</a></li>
</ul>
</div>

<div id="main">

<h1 class="libtitle">Rules<span class="subtitle">Reasoning Rules</span></h1>


<div class="code">

<span class="id" title="keyword">Set Implicit Arguments</span>.<br/>
</div>

<div class="doc">
This file imports <span class="inlinecode"><span class="id" title="var">LibSepDirect.v</span></span> instead of <span class="inlinecode"><span class="id" title="var">Hprop.v</span></span> and <span class="inlinecode"><span class="id" title="var">Himpl.v</span></span>.
    The file <span class="inlinecode"><span class="id" title="var">LibSepDirect.v</span></span> contains definitions that are essentially similar
    to those from <span class="inlinecode"><span class="id" title="var">Hprop.v</span></span> and <span class="inlinecode"><span class="id" title="var">Himpl.v</span></span>, yet with one main difference:
    <span class="inlinecode"><span class="id" title="var">LibSepDirect</span></span> makes the definition of Separation Logic operators opaque.

<div class="paragraph"> </div>

    As a result, one cannot unfold the definition of <span class="inlinecode"><span class="id" title="var">hstar</span></span>, <span class="inlinecode"><span class="id" title="var">hpure</span></span>, etc.
    To carry out reasoning, one must use the introduction and elimination
    lemmas (e.g. <span class="inlinecode"><span class="id" title="var">hstar_intro</span></span>, <span class="inlinecode"><span class="id" title="var">hstar_elim</span></span>). These lemmas enforce
    abstraction: they ensure that the proofs do not depend on the particular
    choice of the definitions used for constructing Separation Logic. 
</div>
<div class="code">

<span class="id" title="keyword">From</span> <span class="id" title="var">SLF</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="LibSepReference.html#"><span class="id" title="library">LibSepReference</span></a>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">SLF</span> <span class="id" title="keyword">Require</span> <a class="idref" href="Basic.html#"><span class="id" title="library">Basic</span></a>.<br/>
</div>

<div class="doc">
<a id="lab153"></a><h1 class="section">First Pass</h1>

<div class="paragraph"> </div>

 In the previous chapters, we have:

<div class="paragraph"> </div>

<ul class="doclist">
<li> introduced the key heap predicate operators,

</li>
<li> introduced the notion of Separation Logic triple,

</li>
<li> introduced the entailment relation,

</li>
<li> introduced the structural rules of Separation Logic.

</li>
</ul>

<div class="paragraph"> </div>

    We are now ready to present the other reasoning rules,
    which enable establishing properties of concrete programs.

<div class="paragraph"> </div>

    These reasoning rules are proved correct with respect to the
    semantics of the programming language in which the programs
    are expressed. Thus, a necessary preliminary step is to present
    the syntax and the semantics of a (toy) programming language,
    for which we aim to provide Separation Logic reasoning rules.

<div class="paragraph"> </div>

    The present chapter is thus organized as follows:

<div class="paragraph"> </div>

<ul class="doclist">
<li> definition of the syntax of the language,

</li>
<li> definition of the semantics of the language,

</li>
<li> statements of the reasoning rules associated with each of
      the term constructions from the language,

</li>
<li> specification of the primitive operations of the language,
      in particular those associated with memory operations,

</li>
<li> review of the 4 structural rules introduced in prior chapters,

</li>
<li> examples of practical verification proofs.

</li>
</ul>

<div class="paragraph"> </div>

    The bonus section (optional) also includes:
<ul class="doclist">
<li> proofs of the reasoning rules associated with each term construct,

</li>
<li> proofs of the specification of the primitive operations. 

</li>
</ul>
</div>

<div class="doc">
<a id="lab154"></a><h2 class="section">Semantic of Terms</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="SyntaxAndSemantics" class="idref" href="#SyntaxAndSemantics"><span class="id" title="module">SyntaxAndSemantics</span></a>.<br/>
</div>

<div class="doc">
<a id="lab155"></a><h3 class="section">Syntax</h3>

<div class="paragraph"> </div>

 The syntax described next captures the "abstract syntax tree"
    of a programming language. It follows a presentation that
    distiguishes between closed values and terms. This presentation
    is intended to simplify the definition and evaluation of the
    substitution function: because values are always closed (i.e.,
    no free variables in them), the substitution function never
    needs to traverse through values.

<div class="paragraph"> </div>

    The grammar for values includes unit, boolean, integers,
    locations, functions, recursive functions, and primitive operations.
    For example, <span class="inlinecode"><span class="id" title="var">val_int</span></span> <span class="inlinecode">3</span> denotes the integer value <span class="inlinecode">3</span>. The value
    <span class="inlinecode"><span class="id" title="var">val_fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> denotes the function <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">t</span></span>, and the value
    <span class="inlinecode"><span class="id" title="var">val_fix</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> denotes the function <span class="inlinecode"><span class="id" title="keyword">fix</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">t</span></span>, which is
    written <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="keyword">rec</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> in OCaml syntax.

<div class="paragraph"> </div>

    For conciseness, we include just a few primitive operations:
    <span class="inlinecode"><span class="id" title="var">ref</span></span>, <span class="inlinecode"><span class="id" title="var">get</span></span>, <span class="inlinecode"><span class="id" title="tactic">set</span></span> and <span class="inlinecode"><span class="id" title="var">free</span></span> for manipulating the mutable state,
    the operation <span class="inlinecode"><span class="id" title="var">add</span></span> to illustrate a simple arithmetic operation,
    and the operation <span class="inlinecode"><span class="id" title="var">div</span></span> to illustrate a partial operation. 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <a id="SyntaxAndSemantics.val" class="idref" href="#SyntaxAndSemantics.val"><span class="id" title="inductive">val</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.val_unit" class="idref" href="#SyntaxAndSemantics.val_unit"><span class="id" title="constructor">val_unit</span></a> : <a class="idref" href="Rules.html#val:1"><span class="id" title="inductive">val</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.val_bool" class="idref" href="#SyntaxAndSemantics.val_bool"><span class="id" title="constructor">val_bool</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#val:1"><span class="id" title="inductive">val</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.val_int" class="idref" href="#SyntaxAndSemantics.val_int"><span class="id" title="constructor">val_int</span></a> : <span class="id" title="notation">int</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#val:1"><span class="id" title="inductive">val</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.val_loc" class="idref" href="#SyntaxAndSemantics.val_loc"><span class="id" title="constructor">val_loc</span></a> : <a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#val:1"><span class="id" title="inductive">val</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.val_fun" class="idref" href="#SyntaxAndSemantics.val_fun"><span class="id" title="constructor">val_fun</span></a> : <a class="idref" href="LibSepVar.html#var"><span class="id" title="definition">var</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#val:1"><span class="id" title="inductive">val</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.val_fix" class="idref" href="#SyntaxAndSemantics.val_fix"><span class="id" title="constructor">val_fix</span></a> : <a class="idref" href="LibSepVar.html#var"><span class="id" title="definition">var</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="LibSepVar.html#var"><span class="id" title="definition">var</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#val:1"><span class="id" title="inductive">val</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.val_ref" class="idref" href="#SyntaxAndSemantics.val_ref"><span class="id" title="constructor">val_ref</span></a> : <a class="idref" href="Rules.html#val:1"><span class="id" title="inductive">val</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.val_get" class="idref" href="#SyntaxAndSemantics.val_get"><span class="id" title="constructor">val_get</span></a> : <a class="idref" href="Rules.html#val:1"><span class="id" title="inductive">val</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.val_set" class="idref" href="#SyntaxAndSemantics.val_set"><span class="id" title="constructor">val_set</span></a> : <a class="idref" href="Rules.html#val:1"><span class="id" title="inductive">val</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.val_free" class="idref" href="#SyntaxAndSemantics.val_free"><span class="id" title="constructor">val_free</span></a> : <a class="idref" href="Rules.html#val:1"><span class="id" title="inductive">val</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.val_add" class="idref" href="#SyntaxAndSemantics.val_add"><span class="id" title="constructor">val_add</span></a> : <a class="idref" href="Rules.html#val:1"><span class="id" title="inductive">val</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.val_div" class="idref" href="#SyntaxAndSemantics.val_div"><span class="id" title="constructor">val_div</span></a> : <a class="idref" href="Rules.html#val:1"><span class="id" title="inductive">val</span></a><br/>
<br/>
</div>

<div class="doc">
The grammar for terms includes values, variables, function definitions,
    recursive function definitions, function applications, sequences,
    let-bindings, and conditionals. 
</div>
<div class="code">
<br/>
<span class="id" title="keyword">with</span> <a id="SyntaxAndSemantics.trm" class="idref" href="#SyntaxAndSemantics.trm"><span class="id" title="inductive">trm</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.trm_val" class="idref" href="#SyntaxAndSemantics.trm_val"><span class="id" title="constructor">trm_val</span></a> : <a class="idref" href="Rules.html#val:1"><span class="id" title="inductive">val</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.trm_var" class="idref" href="#SyntaxAndSemantics.trm_var"><span class="id" title="constructor">trm_var</span></a> : <a class="idref" href="LibSepVar.html#var"><span class="id" title="definition">var</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.trm_fun" class="idref" href="#SyntaxAndSemantics.trm_fun"><span class="id" title="constructor">trm_fun</span></a> : <a class="idref" href="LibSepVar.html#var"><span class="id" title="definition">var</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.trm_fix" class="idref" href="#SyntaxAndSemantics.trm_fix"><span class="id" title="constructor">trm_fix</span></a> : <a class="idref" href="LibSepVar.html#var"><span class="id" title="definition">var</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="LibSepVar.html#var"><span class="id" title="definition">var</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.trm_app" class="idref" href="#SyntaxAndSemantics.trm_app"><span class="id" title="constructor">trm_app</span></a> : <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.trm_seq" class="idref" href="#SyntaxAndSemantics.trm_seq"><span class="id" title="constructor">trm_seq</span></a> : <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.trm_let" class="idref" href="#SyntaxAndSemantics.trm_let"><span class="id" title="constructor">trm_let</span></a> : <a class="idref" href="LibSepVar.html#var"><span class="id" title="definition">var</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.trm_if" class="idref" href="#SyntaxAndSemantics.trm_if"><span class="id" title="constructor">trm_if</span></a> : <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#trm:2"><span class="id" title="inductive">trm</span></a>.<br/>
</div>

<div class="doc">
Note that <span class="inlinecode"><span class="id" title="var">trm_fun</span></span> and <span class="inlinecode"><span class="id" title="var">trm_fix</span></span> denote functions that may feature free
    variables, unlike <span class="inlinecode"><span class="id" title="var">val_fun</span></span> and <span class="inlinecode"><span class="id" title="var">val_fix</span></span> which denote closed values.
    The intention is that the evaluation of a <span class="inlinecode"><span class="id" title="var">trm_fun</span></span> in the empty context
    produces a <span class="inlinecode"><span class="id" title="var">val_fun</span></span> value. Likewise, a <span class="inlinecode"><span class="id" title="var">trm_fix</span></span> eventually evaluates to
    a <span class="inlinecode"><span class="id" title="var">val_fix</span></span>. 
<div class="paragraph"> </div>

 Several value constructors are declared as coercions, to enable more
    concise statements. For example, <span class="inlinecode"><span class="id" title="var">val_loc</span></span> is declared as a coercion,
    so that a location <span class="inlinecode"><span class="id" title="var">p</span></span> of type <span class="inlinecode"><span class="id" title="var">loc</span></span> can be viewed as the value
    <span class="inlinecode"><span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> where an expression of type <span class="inlinecode"><span class="id" title="var">val</span></span> is expected. Likewise,
    a boolean <span class="inlinecode"><span class="id" title="var">b</span></span> may be viewed as the value <span class="inlinecode"><span class="id" title="var">val_bool</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>, and an integer
    <span class="inlinecode"><span class="id" title="var">n</span></span> may be viewed as the value <span class="inlinecode"><span class="id" title="var">val_int</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Coercion</span> <a class="idref" href="Rules.html#SyntaxAndSemantics.val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.val_loc"><span class="id" title="constructor">:</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.val_loc"><span class="id" title="constructor">loc</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.val_loc"><span class="id" title="constructor">&gt;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span></span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.val_loc"><span class="id" title="constructor">val</span></a>.<br/>
<span class="id" title="keyword">Coercion</span> <a class="idref" href="Rules.html#SyntaxAndSemantics.val_bool"><span class="id" title="constructor">val_bool</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.val_bool"><span class="id" title="constructor">:</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.val_bool"><span class="id" title="constructor">bool</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.val_bool"><span class="id" title="constructor">&gt;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span></span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.val_bool"><span class="id" title="constructor">val</span></a>.<br/>
<span class="id" title="keyword">Coercion</span> <a class="idref" href="Rules.html#SyntaxAndSemantics.val_int"><span class="id" title="constructor">val_int</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.val_int"><span class="id" title="constructor">:</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.val_int"><span class="id" title="constructor">Z</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.val_int"><span class="id" title="constructor">&gt;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span></span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.val_int"><span class="id" title="constructor">val</span></a>.<br/>
</div>

<div class="doc">
<a id="lab156"></a><h3 class="section">State</h3>

<div class="paragraph"> </div>

 The language we consider is an imperative language, with primitive
    functions for manipulating the state. Thus, the statement of the
    evaluation rules involve a memory state.

<div class="paragraph"> </div>

    Recall from <span class="inlinecode"><span class="id" title="var">Hprop</span></span> that a state is represented as a finite map
    from location to values. Finite maps are presented using the type
    <span class="inlinecode"><span class="id" title="var">fmap</span></span>. Details of the construction of finite maps are beyond the
    scope of this course; details may be found in the the file
    <span class="inlinecode"><span class="id" title="var">LibSepFmap.v</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="SyntaxAndSemantics.state" class="idref" href="#SyntaxAndSemantics.state"><span class="id" title="definition">state</span></a> : <span class="id" title="keyword">Type</span> := <a class="idref" href="LibSepFmap.html#fmap"><span class="id" title="record">fmap</span></a> <a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.val"><span class="id" title="inductive">val</span></a>.<br/>
</div>

<div class="doc">
For technical reasons related to the internal representation of finite
    maps, to enable reading in a state, we need to justify that the grammar
    of values is inhabited. This property is captured by the following
    command, whose details are not relevant for understanding the rest of
    the chapter. 
</div>
<div class="code">

<span class="id" title="keyword">Instance</span> <a id="SyntaxAndSemantics.Inhab_val" class="idref" href="#SyntaxAndSemantics.Inhab_val"><span class="id" title="instance">Inhab_val</span></a> : <span class="id" title="class">Inhab</span> <a class="idref" href="Rules.html#SyntaxAndSemantics.val"><span class="id" title="inductive">val</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="tactic">apply</span> (<span class="id" title="lemma">Inhab_of_val</span> <a class="idref" href="Rules.html#SyntaxAndSemantics.val_unit"><span class="id" title="constructor">val_unit</span></a>). <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab157"></a><h3 class="section">Substitution</h3>

<div class="paragraph"> </div>

 The semantics of the evaluation of function is described by means
    of a substitution function. The substitution function, written
    <span class="inlinecode"><span class="id" title="tactic">subst</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">w</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>, replaces all occurrences of a variable <span class="inlinecode"><span class="id" title="var">y</span></span> with a
    value <span class="inlinecode"><span class="id" title="var">w</span></span> inside a term <span class="inlinecode"><span class="id" title="var">t</span></span>.

<div class="paragraph"> </div>

    The substitution function is always the identity function on values,
    because our language only considers closed values. In other words,
    we define <span class="inlinecode"><span class="id" title="tactic">subst</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">w</span></span> <span class="inlinecode">(<span class="id" title="var">trm_val</span></span> <span class="inlinecode"><span class="id" title="var">v</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode">(<span class="id" title="var">trm_val</span></span> <span class="inlinecode"><span class="id" title="var">v</span>)</span>.

<div class="paragraph"> </div>

    The substitution function, when reaching a variable, performs a
    comparison between two variables. To that end, it exploits the
    comparison function <span class="inlinecode"><span class="id" title="var">var_eq</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>, which produces a boolean value
    indicating whether <span class="inlinecode"><span class="id" title="var">x</span></span> and <span class="inlinecode"><span class="id" title="var">y</span></span> denote the same variable. 
<div class="paragraph"> </div>

 "Optional contents": the remaining of this section describes further
    details about the substitution function that may be safely skipped
    over in first reading. 
<div class="paragraph"> </div>

 The substitution operation traverses all other language constructs
    in a structural manner. It takes care of avoiding "variable capture"
    when traversing binders: <span class="inlinecode"><span class="id" title="tactic">subst</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">w</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> does not recurse below the
    scope of binders whose name is equal to <span class="inlinecode"><span class="id" title="var">y</span></span>. For example, the result
    of <span class="inlinecode"><span class="id" title="tactic">subst</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">w</span></span> <span class="inlinecode">(<span class="id" title="var">trm_let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span>)</span> is defined as
    <span class="inlinecode"><span class="id" title="var">trm_let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">(<span class="id" title="tactic">subst</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">w</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span>)</span> <span class="inlinecode">(<span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">var_eq</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode">(<span class="id" title="tactic">subst</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">w</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span>))</span>.

<div class="paragraph"> </div>

    The auxiliary function <span class="inlinecode"><span class="id" title="var">if_y_eq</span></span>, which appears in the definition of
    <span class="inlinecode"><span class="id" title="tactic">subst</span></span> shown below, helps performing the factorizing the relevant
    checks that prevent variable capture. 
</div>
<div class="code">

<span class="id" title="keyword">Fixpoint</span> <a id="SyntaxAndSemantics.subst" class="idref" href="#SyntaxAndSemantics.subst"><span class="id" title="definition">subst</span></a> (<a id="y:5" class="idref" href="#y:5"><span class="id" title="binder">y</span></a>:<a class="idref" href="LibSepVar.html#var"><span class="id" title="definition">var</span></a>) (<a id="w:6" class="idref" href="#w:6"><span class="id" title="binder">w</span></a>:<a class="idref" href="Rules.html#SyntaxAndSemantics.val"><span class="id" title="inductive">val</span></a>) (<a id="t:7" class="idref" href="#t:7"><span class="id" title="binder">t</span></a>:<a class="idref" href="Rules.html#SyntaxAndSemantics.trm"><span class="id" title="inductive">trm</span></a>) : <a class="idref" href="Rules.html#SyntaxAndSemantics.trm"><span class="id" title="inductive">trm</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <a id="aux:10" class="idref" href="#aux:10"><span class="id" title="binder">aux</span></a> <a id="t:9" class="idref" href="#t:9"><span class="id" title="binder">t</span></a> := <a class="idref" href="Rules.html#subst:8"><span class="id" title="definition">subst</span></a> <a class="idref" href="Rules.html#y:5"><span class="id" title="variable">y</span></a> <a class="idref" href="Rules.html#w:6"><span class="id" title="variable">w</span></a> <a class="idref" href="Rules.html#t:9"><span class="id" title="variable">t</span></a> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <a id="if_y_eq:14" class="idref" href="#if_y_eq:14"><span class="id" title="binder">if_y_eq</span></a> <a id="x:11" class="idref" href="#x:11"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:12" class="idref" href="#t<sub>1</sub>:12"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:13" class="idref" href="#t<sub>2</sub>:13"><span class="id" title="binder">t<sub>2</sub></span></a> := <span class="id" title="keyword">if</span> <a class="idref" href="LibSepVar.html#var_eq"><span class="id" title="definition">var_eq</span></a> <a class="idref" href="Rules.html#x:11"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#y:5"><span class="id" title="variable">y</span></a> <span class="id" title="keyword">then</span> <a class="idref" href="Rules.html#t<sub>1</sub>:12"><span class="id" title="variable">t<sub>1</sub></span></a> <span class="id" title="keyword">else</span> <a class="idref" href="Rules.html#t<sub>2</sub>:13"><span class="id" title="variable">t<sub>2</sub></span></a> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Rules.html#t:7"><span class="id" title="variable">t</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_val"><span class="id" title="constructor">trm_val</span></a> <span class="id" title="var">v</span> ⇒ <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_val"><span class="id" title="constructor">trm_val</span></a> <span class="id" title="var">v</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_var"><span class="id" title="constructor">trm_var</span></a> <span class="id" title="var">x</span> ⇒ <a class="idref" href="Rules.html#if_y_eq:14"><span class="id" title="variable">if_y_eq</span></a> <span class="id" title="var">x</span> (<a class="idref" href="Rules.html#SyntaxAndSemantics.trm_val"><span class="id" title="constructor">trm_val</span></a> <a class="idref" href="Rules.html#w:6"><span class="id" title="variable">w</span></a>) <a class="idref" href="Rules.html#t:7"><span class="id" title="variable">t</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_fun"><span class="id" title="constructor">trm_fun</span></a> <span class="id" title="var">x</span> <span class="id" title="var">t<sub>1</sub></span> ⇒ <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_fun"><span class="id" title="constructor">trm_fun</span></a> <span class="id" title="var">x</span> (<a class="idref" href="Rules.html#if_y_eq:14"><span class="id" title="variable">if_y_eq</span></a> <span class="id" title="var">x</span> <span class="id" title="var">t<sub>1</sub></span> (<a class="idref" href="Rules.html#aux:10"><span class="id" title="variable">aux</span></a> <span class="id" title="var">t<sub>1</sub></span>))<br/>
&nbsp;&nbsp;| <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_fix"><span class="id" title="constructor">trm_fix</span></a> <span class="id" title="var">f</span> <span class="id" title="var">x</span> <span class="id" title="var">t<sub>1</sub></span> ⇒ <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_fix"><span class="id" title="constructor">trm_fix</span></a> <span class="id" title="var">f</span> <span class="id" title="var">x</span> (<a class="idref" href="Rules.html#if_y_eq:14"><span class="id" title="variable">if_y_eq</span></a> <span class="id" title="var">f</span> <span class="id" title="var">t<sub>1</sub></span> (<a class="idref" href="Rules.html#if_y_eq:14"><span class="id" title="variable">if_y_eq</span></a> <span class="id" title="var">x</span> <span class="id" title="var">t<sub>1</sub></span> (<a class="idref" href="Rules.html#aux:10"><span class="id" title="variable">aux</span></a> <span class="id" title="var">t<sub>1</sub></span>)))<br/>
&nbsp;&nbsp;| <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_app"><span class="id" title="constructor">trm_app</span></a> <span class="id" title="var">t<sub>1</sub></span> <span class="id" title="var">t<sub>2</sub></span> ⇒ <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_app"><span class="id" title="constructor">trm_app</span></a> (<a class="idref" href="Rules.html#aux:10"><span class="id" title="variable">aux</span></a> <span class="id" title="var">t<sub>1</sub></span>) (<a class="idref" href="Rules.html#aux:10"><span class="id" title="variable">aux</span></a> <span class="id" title="var">t<sub>2</sub></span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_seq"><span class="id" title="constructor">trm_seq</span></a> <span class="id" title="var">t<sub>1</sub></span> <span class="id" title="var">t<sub>2</sub></span> ⇒ <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_seq"><span class="id" title="constructor">trm_seq</span></a>  (<a class="idref" href="Rules.html#aux:10"><span class="id" title="variable">aux</span></a> <span class="id" title="var">t<sub>1</sub></span>) (<a class="idref" href="Rules.html#aux:10"><span class="id" title="variable">aux</span></a> <span class="id" title="var">t<sub>2</sub></span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_let"><span class="id" title="constructor">trm_let</span></a> <span class="id" title="var">x</span> <span class="id" title="var">t<sub>1</sub></span> <span class="id" title="var">t<sub>2</sub></span> ⇒ <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_let"><span class="id" title="constructor">trm_let</span></a> <span class="id" title="var">x</span> (<a class="idref" href="Rules.html#aux:10"><span class="id" title="variable">aux</span></a> <span class="id" title="var">t<sub>1</sub></span>) (<a class="idref" href="Rules.html#if_y_eq:14"><span class="id" title="variable">if_y_eq</span></a> <span class="id" title="var">x</span> <span class="id" title="var">t<sub>2</sub></span> (<a class="idref" href="Rules.html#aux:10"><span class="id" title="variable">aux</span></a> <span class="id" title="var">t<sub>2</sub></span>))<br/>
&nbsp;&nbsp;| <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_if"><span class="id" title="constructor">trm_if</span></a> <span class="id" title="var">t<sub>0</sub></span> <span class="id" title="var">t<sub>1</sub></span> <span class="id" title="var">t<sub>2</sub></span> ⇒ <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_if"><span class="id" title="constructor">trm_if</span></a> (<a class="idref" href="Rules.html#aux:10"><span class="id" title="variable">aux</span></a> <span class="id" title="var">t<sub>0</sub></span>) (<a class="idref" href="Rules.html#aux:10"><span class="id" title="variable">aux</span></a> <span class="id" title="var">t<sub>1</sub></span>) (<a class="idref" href="Rules.html#aux:10"><span class="id" title="variable">aux</span></a> <span class="id" title="var">t<sub>2</sub></span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
<a id="lab158"></a><h3 class="section">Implicit Types and Coercions</h3>

<div class="paragraph"> </div>

 To improve the readability of the evaluation rules stated further,
    we take advantage of both implicit types and coercions.

<div class="paragraph"> </div>

    The implicit types are defined as shown below. For example, the
    first command indicates that variables whose name begins with the
    letter 'b' are, by default, variables of type <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">b</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">v</span> <span class="id" title="var">r</span> : <a class="idref" href="Rules.html#SyntaxAndSemantics.val"><span class="id" title="inductive">val</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">t</span> : <a class="idref" href="Rules.html#SyntaxAndSemantics.trm"><span class="id" title="inductive">trm</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">s</span> : <a class="idref" href="Rules.html#SyntaxAndSemantics.state"><span class="id" title="definition">state</span></a>.<br/>
</div>

<div class="doc">
We next introduce two key coercions. First, we declare
    <span class="inlinecode"><span class="id" title="var">trm_val</span></span> as a coercion, so that, instead of writing <span class="inlinecode"><span class="id" title="var">trm_val</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span>,
    we may write simply <span class="inlinecode"><span class="id" title="var">v</span></span> wherever a term is expected. 
</div>
<div class="code">

<span class="id" title="keyword">Coercion</span> <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_val"><span class="id" title="constructor">trm_val</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_val"><span class="id" title="constructor">:</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_val"><span class="id" title="constructor">val</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_val"><span class="id" title="constructor">&gt;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span></span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_val"><span class="id" title="constructor">trm</span></a>.<br/>
</div>

<div class="doc">
Second, we declare <span class="inlinecode"><span class="id" title="var">trm_app</span></span> as a "Funclass" coercion. This piece
    of magic enables us to write <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> as a shorthand for <span class="inlinecode"><span class="id" title="var">trm_app</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>.
    The idea of associating <span class="inlinecode"><span class="id" title="var">trm_app</span></span> as the "Funclass" coercion for the
    type <span class="inlinecode"><span class="id" title="var">trm</span></span> is that if a term <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> of type <span class="inlinecode"><span class="id" title="var">trm</span></span> is applied like a
    function to an argument, then <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> should be interpreted as <span class="inlinecode"><span class="id" title="var">trm_app</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Coercion</span> <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_app"><span class="id" title="constructor">trm_app</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_app"><span class="id" title="constructor">:</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_app"><span class="id" title="constructor">trm</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_app"><span class="id" title="constructor">&gt;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span></span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.trm_app"><span class="id" title="constructor">Funclass</span></a>.<br/>
</div>

<div class="doc">
Interestingly, the "Funclass" coercion for <span class="inlinecode"><span class="id" title="var">trm_app</span></span> can be iterated.
    The expression <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>3</sub></span></span> is parsed by Coq as <span class="inlinecode">(<span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span>)</span> <span class="inlinecode"><span class="id" title="var">t<sub>3</sub></span></span>. The first
    application <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> is interpreted as <span class="inlinecode"><span class="id" title="var">trm_app</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>. This expression,
    which itself has type <span class="inlinecode"><span class="id" title="var">trm</span></span>, is applied to <span class="inlinecode"><span class="id" title="var">t<sub>3</sub></span></span>. Hence, it is interpreted
    as <span class="inlinecode"><span class="id" title="var">trm_app</span></span> <span class="inlinecode">(<span class="id" title="var">trm_app</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span>)</span> <span class="inlinecode"><span class="id" title="var">t<sub>3</sub></span></span>, which indeed corresponds to a function
    applied to two arguments. 
</div>

<div class="doc">
<a id="lab159"></a><h3 class="section">Big-Step Semantics</h3>

<div class="paragraph"> </div>

 The semantics is presented in big-step style. This presentation makes
    it slightly easier to establish reasoning rules than with small-step
    reduction rules, because both the big-step judgment and a triple
    judgment describe complete execution, relating a term with the value
    that it produces.

<div class="paragraph"> </div>

    The big-step evaluation judgment, written <span class="inlinecode"><span class="id" title="tactic">eval</span></span> <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">s'</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span>, asserts that,
    starting from state <span class="inlinecode"><span class="id" title="var">s</span></span>, the evaluation of the term <span class="inlinecode"><span class="id" title="var">t</span></span> terminates in
    a state <span class="inlinecode"><span class="id" title="var">s'</span></span>, producing an output value <span class="inlinecode"><span class="id" title="var">v</span></span>.

<div class="paragraph"> </div>

    For simplicity, we assume terms to be in "A-normal form": the arguments
    of applications and of conditionals are restricted to variables and values.
    Such a requirement does not limit expressiveness, yet it simplifies the
    statement of the evaluation rules.

<div class="paragraph"> </div>

    For example, if a source program includes a conditional <span class="inlinecode"><span class="id" title="var">trm_if</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>0</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>,
    then it is required that <span class="inlinecode"><span class="id" title="var">t<sub>0</sub></span></span> be either a variable or a value.
    This is not a real restriction, because <span class="inlinecode"><span class="id" title="var">trm_if</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>0</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> can always be
    encoded as <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t<sub>0</sub></span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>.

<div class="paragraph"> </div>

    The big-step judgment is inductively defined as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <a id="SyntaxAndSemantics.eval" class="idref" href="#SyntaxAndSemantics.eval"><span class="id" title="inductive">eval</span></a> : <a class="idref" href="Rules.html#SyntaxAndSemantics.state"><span class="id" title="definition">state</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.trm"><span class="id" title="inductive">trm</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.state"><span class="id" title="definition">state</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.val"><span class="id" title="inductive">val</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
<br/>
</div>

<div class="doc">
1. <span class="inlinecode"><span class="id" title="tactic">eval</span></span> for values and function definitions.

<div class="paragraph"> </div>

      A value evaluates to itself.
      A term function evaluates to a value function.
      Likewise for a recursive function. 
</div>
<div class="code">
<br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.eval_val" class="idref" href="#SyntaxAndSemantics.eval_val"><span class="id" title="constructor">eval_val</span></a> : <span class="id" title="keyword">∀</span> <a id="s:18" class="idref" href="#s:18"><span class="id" title="binder">s</span></a> <a id="v:19" class="idref" href="#v:19"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:18"><span class="id" title="variable">s</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.trm_val"><span class="id" title="constructor">trm_val</span></a> <a class="idref" href="Rules.html#v:19"><span class="id" title="variable">v</span></a>) <a class="idref" href="Rules.html#s:18"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#v:19"><span class="id" title="variable">v</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.eval_fun" class="idref" href="#SyntaxAndSemantics.eval_fun"><span class="id" title="constructor">eval_fun</span></a> : <span class="id" title="keyword">∀</span> <a id="s:20" class="idref" href="#s:20"><span class="id" title="binder">s</span></a> <a id="x:21" class="idref" href="#x:21"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:22" class="idref" href="#t<sub>1</sub>:22"><span class="id" title="binder">t<sub>1</sub></span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:20"><span class="id" title="variable">s</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.trm_fun"><span class="id" title="constructor">trm_fun</span></a> <a class="idref" href="Rules.html#x:21"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:22"><span class="id" title="variable">t<sub>1</sub></span></a>) <a class="idref" href="Rules.html#s:20"><span class="id" title="variable">s</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_fun"><span class="id" title="constructor">val_fun</span></a> <a class="idref" href="Rules.html#x:21"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:22"><span class="id" title="variable">t<sub>1</sub></span></a>)<br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.eval_fix" class="idref" href="#SyntaxAndSemantics.eval_fix"><span class="id" title="constructor">eval_fix</span></a> : <span class="id" title="keyword">∀</span> <a id="s:23" class="idref" href="#s:23"><span class="id" title="binder">s</span></a> <a id="f:24" class="idref" href="#f:24"><span class="id" title="binder">f</span></a> <a id="x:25" class="idref" href="#x:25"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:26" class="idref" href="#t<sub>1</sub>:26"><span class="id" title="binder">t<sub>1</sub></span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:23"><span class="id" title="variable">s</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.trm_fix"><span class="id" title="constructor">trm_fix</span></a> <a class="idref" href="Rules.html#f:24"><span class="id" title="variable">f</span></a> <a class="idref" href="Rules.html#x:25"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:26"><span class="id" title="variable">t<sub>1</sub></span></a>) <a class="idref" href="Rules.html#s:23"><span class="id" title="variable">s</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_fix"><span class="id" title="constructor">val_fix</span></a> <a class="idref" href="Rules.html#f:24"><span class="id" title="variable">f</span></a> <a class="idref" href="Rules.html#x:25"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:26"><span class="id" title="variable">t<sub>1</sub></span></a>)<br/>
<br/>
</div>

<div class="doc">
2. <span class="inlinecode"><span class="id" title="tactic">eval</span></span> for function applications.

<div class="paragraph"> </div>

     The beta reduction rule asserts that <span class="inlinecode">(<span class="id" title="var">val_fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span>)</span> <span class="inlinecode"><span class="id" title="var">v<sub>2</sub></span></span>
     evaluates to the same result as <span class="inlinecode"><span class="id" title="tactic">subst</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">v<sub>2</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>.

<div class="paragraph"> </div>

     In the recursive case, <span class="inlinecode">(<span class="id" title="var">val_fix</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span>)</span> <span class="inlinecode"><span class="id" title="var">v<sub>2</sub></span></span> evaluates to
     <span class="inlinecode"><span class="id" title="tactic">subst</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">v<sub>2</sub></span></span> <span class="inlinecode">(<span class="id" title="tactic">subst</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">v<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span>)</span>, where <span class="inlinecode"><span class="id" title="var">v<sub>1</sub></span></span> denotes the recursive
     function itself, that is, <span class="inlinecode"><span class="id" title="var">val_fix</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>. 
</div>
<div class="code">
<br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.eval_app_fun" class="idref" href="#SyntaxAndSemantics.eval_app_fun"><span class="id" title="constructor">eval_app_fun</span></a> : <span class="id" title="keyword">∀</span> <a id="s<sub>1</sub>:27" class="idref" href="#s<sub>1</sub>:27"><span class="id" title="binder">s<sub>1</sub></span></a> <a id="s<sub>2</sub>:28" class="idref" href="#s<sub>2</sub>:28"><span class="id" title="binder">s<sub>2</sub></span></a> <a id="v<sub>1</sub>:29" class="idref" href="#v<sub>1</sub>:29"><span class="id" title="binder">v<sub>1</sub></span></a> <a id="v<sub>2</sub>:30" class="idref" href="#v<sub>2</sub>:30"><span class="id" title="binder">v<sub>2</sub></span></a> <a id="x:31" class="idref" href="#x:31"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:32" class="idref" href="#t<sub>1</sub>:32"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="v:33" class="idref" href="#v:33"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#v<sub>1</sub>:29"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.val_fun"><span class="id" title="constructor">val_fun</span></a> <a class="idref" href="Rules.html#x:31"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:32"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:27"><span class="id" title="variable">s<sub>1</sub></span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.subst"><span class="id" title="definition">subst</span></a> <a class="idref" href="Rules.html#x:31"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#v<sub>2</sub>:30"><span class="id" title="variable">v<sub>2</sub></span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:32"><span class="id" title="variable">t<sub>1</sub></span></a>) <a class="idref" href="Rules.html#s<sub>2</sub>:28"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Rules.html#v:33"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:27"><span class="id" title="variable">s<sub>1</sub></span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.trm_app"><span class="id" title="constructor">trm_app</span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:29"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Rules.html#v<sub>2</sub>:30"><span class="id" title="variable">v<sub>2</sub></span></a>) <a class="idref" href="Rules.html#s<sub>2</sub>:28"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Rules.html#v:33"><span class="id" title="variable">v</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.eval_app_fix" class="idref" href="#SyntaxAndSemantics.eval_app_fix"><span class="id" title="constructor">eval_app_fix</span></a> : <span class="id" title="keyword">∀</span> <a id="s<sub>1</sub>:34" class="idref" href="#s<sub>1</sub>:34"><span class="id" title="binder">s<sub>1</sub></span></a> <a id="s<sub>2</sub>:35" class="idref" href="#s<sub>2</sub>:35"><span class="id" title="binder">s<sub>2</sub></span></a> <a id="v<sub>1</sub>:36" class="idref" href="#v<sub>1</sub>:36"><span class="id" title="binder">v<sub>1</sub></span></a> <a id="v<sub>2</sub>:37" class="idref" href="#v<sub>2</sub>:37"><span class="id" title="binder">v<sub>2</sub></span></a> <a id="f:38" class="idref" href="#f:38"><span class="id" title="binder">f</span></a> <a id="x:39" class="idref" href="#x:39"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:40" class="idref" href="#t<sub>1</sub>:40"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="v:41" class="idref" href="#v:41"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#v<sub>1</sub>:36"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Rules.html#SyntaxAndSemantics.val_fix"><span class="id" title="constructor">val_fix</span></a> <a class="idref" href="Rules.html#f:38"><span class="id" title="variable">f</span></a> <a class="idref" href="Rules.html#x:39"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:40"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:34"><span class="id" title="variable">s<sub>1</sub></span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.subst"><span class="id" title="definition">subst</span></a> <a class="idref" href="Rules.html#x:39"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#v<sub>2</sub>:37"><span class="id" title="variable">v<sub>2</sub></span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.subst"><span class="id" title="definition">subst</span></a> <a class="idref" href="Rules.html#f:38"><span class="id" title="variable">f</span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:36"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:40"><span class="id" title="variable">t<sub>1</sub></span></a>)) <a class="idref" href="Rules.html#s<sub>2</sub>:35"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Rules.html#v:41"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:34"><span class="id" title="variable">s<sub>1</sub></span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.trm_app"><span class="id" title="constructor">trm_app</span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:36"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Rules.html#v<sub>2</sub>:37"><span class="id" title="variable">v<sub>2</sub></span></a>) <a class="idref" href="Rules.html#s<sub>2</sub>:35"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Rules.html#v:41"><span class="id" title="variable">v</span></a><br/>
<br/>
</div>

<div class="doc">
3. <span class="inlinecode"><span class="id" title="tactic">eval</span></span> for structural constructs.

<div class="paragraph"> </div>

      A sequence <span class="inlinecode"><span class="id" title="var">trm_seq</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> first evaluates <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>, taking the
      state from <span class="inlinecode"><span class="id" title="var">s<sub>1</sub></span></span> to <span class="inlinecode"><span class="id" title="var">s<sub>2</sub></span></span>, drops the result of <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>, then evaluates
      <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>, taking the state from <span class="inlinecode"><span class="id" title="var">s<sub>2</sub></span></span> to <span class="inlinecode"><span class="id" title="var">s<sub>3</sub></span></span>.

<div class="paragraph"> </div>

      The let-binding <span class="inlinecode"><span class="id" title="var">trm_let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> is similar, except that the
      variable <span class="inlinecode"><span class="id" title="var">x</span></span> gets substituted for the result of <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> inside <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>. 
</div>
<div class="code">
<br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.eval_seq" class="idref" href="#SyntaxAndSemantics.eval_seq"><span class="id" title="constructor">eval_seq</span></a> : <span class="id" title="keyword">∀</span> <a id="s<sub>1</sub>:42" class="idref" href="#s<sub>1</sub>:42"><span class="id" title="binder">s<sub>1</sub></span></a> <a id="s<sub>2</sub>:43" class="idref" href="#s<sub>2</sub>:43"><span class="id" title="binder">s<sub>2</sub></span></a> <a id="s<sub>3</sub>:44" class="idref" href="#s<sub>3</sub>:44"><span class="id" title="binder">s<sub>3</sub></span></a> <a id="t<sub>1</sub>:45" class="idref" href="#t<sub>1</sub>:45"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:46" class="idref" href="#t<sub>2</sub>:46"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="v<sub>1</sub>:47" class="idref" href="#v<sub>1</sub>:47"><span class="id" title="binder">v<sub>1</sub></span></a> <a id="v:48" class="idref" href="#v:48"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:42"><span class="id" title="variable">s<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:45"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#s<sub>2</sub>:43"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:47"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>2</sub>:43"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:46"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="Rules.html#s<sub>3</sub>:44"><span class="id" title="variable">s<sub>3</sub></span></a> <a class="idref" href="Rules.html#v:48"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:42"><span class="id" title="variable">s<sub>1</sub></span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.trm_seq"><span class="id" title="constructor">trm_seq</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:45"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:46"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#s<sub>3</sub>:44"><span class="id" title="variable">s<sub>3</sub></span></a> <a class="idref" href="Rules.html#v:48"><span class="id" title="variable">v</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.eval_let" class="idref" href="#SyntaxAndSemantics.eval_let"><span class="id" title="constructor">eval_let</span></a> : <span class="id" title="keyword">∀</span> <a id="s<sub>1</sub>:49" class="idref" href="#s<sub>1</sub>:49"><span class="id" title="binder">s<sub>1</sub></span></a> <a id="s<sub>2</sub>:50" class="idref" href="#s<sub>2</sub>:50"><span class="id" title="binder">s<sub>2</sub></span></a> <a id="s<sub>3</sub>:51" class="idref" href="#s<sub>3</sub>:51"><span class="id" title="binder">s<sub>3</sub></span></a> <a id="x:52" class="idref" href="#x:52"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:53" class="idref" href="#t<sub>1</sub>:53"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:54" class="idref" href="#t<sub>2</sub>:54"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="v<sub>1</sub>:55" class="idref" href="#v<sub>1</sub>:55"><span class="id" title="binder">v<sub>1</sub></span></a> <a id="r:56" class="idref" href="#r:56"><span class="id" title="binder">r</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:49"><span class="id" title="variable">s<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:53"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#s<sub>2</sub>:50"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:55"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>2</sub>:50"><span class="id" title="variable">s<sub>2</sub></span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.subst"><span class="id" title="definition">subst</span></a> <a class="idref" href="Rules.html#x:52"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:55"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:54"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#s<sub>3</sub>:51"><span class="id" title="variable">s<sub>3</sub></span></a> <a class="idref" href="Rules.html#r:56"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:49"><span class="id" title="variable">s<sub>1</sub></span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.trm_let"><span class="id" title="constructor">trm_let</span></a> <a class="idref" href="Rules.html#x:52"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:53"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:54"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#s<sub>3</sub>:51"><span class="id" title="variable">s<sub>3</sub></span></a> <a class="idref" href="Rules.html#r:56"><span class="id" title="variable">r</span></a><br/>
<br/>
</div>

<div class="doc">
4. <span class="inlinecode"><span class="id" title="tactic">eval</span></span> for conditionals.

<div class="paragraph"> </div>

      A conditional in a source program is assumed to be of the form
      <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>0</sub></span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>, where <span class="inlinecode"><span class="id" title="var">t<sub>0</sub></span></span> is either a variable or a
      value. If it is a variable, then by the time it reaches an
      evaluation position, the variable must have been substituted
      by a value. Thus, the evaluation rule only considers the form
      <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">v<sub>0</sub></span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>. The value <span class="inlinecode"><span class="id" title="var">v<sub>0</sub></span></span> must be a boolean value,
      otherwise evaluation gets stuck.

<div class="paragraph"> </div>

      The term <span class="inlinecode"><span class="id" title="var">trm_if</span></span> <span class="inlinecode">(<span class="id" title="var">val_bool</span></span> <span class="inlinecode"><span class="id" title="var">true</span>)</span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> behaves like <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>, whereas
      the term <span class="inlinecode"><span class="id" title="var">trm_if</span></span> <span class="inlinecode">(<span class="id" title="var">val_bool</span></span> <span class="inlinecode"><span class="id" title="var">false</span>)</span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> behaves like <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>.
      This behavior is described by a single rule, leveraging Coq's "if"
      constructor to factor out the two cases. 
</div>
<div class="code">
<br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.eval_if" class="idref" href="#SyntaxAndSemantics.eval_if"><span class="id" title="constructor">eval_if</span></a> : <span class="id" title="keyword">∀</span> <a id="s<sub>1</sub>:57" class="idref" href="#s<sub>1</sub>:57"><span class="id" title="binder">s<sub>1</sub></span></a> <a id="s<sub>2</sub>:58" class="idref" href="#s<sub>2</sub>:58"><span class="id" title="binder">s<sub>2</sub></span></a> <a id="b:59" class="idref" href="#b:59"><span class="id" title="binder">b</span></a> <a id="v:60" class="idref" href="#v:60"><span class="id" title="binder">v</span></a> <a id="t<sub>1</sub>:61" class="idref" href="#t<sub>1</sub>:61"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:62" class="idref" href="#t<sub>2</sub>:62"><span class="id" title="binder">t<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:57"><span class="id" title="variable">s<sub>1</sub></span></a> (<span class="id" title="keyword">if</span> <a class="idref" href="Rules.html#b:59"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">then</span> <a class="idref" href="Rules.html#t<sub>1</sub>:61"><span class="id" title="variable">t<sub>1</sub></span></a> <span class="id" title="keyword">else</span> <a class="idref" href="Rules.html#t<sub>2</sub>:62"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#s<sub>2</sub>:58"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Rules.html#v:60"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:57"><span class="id" title="variable">s<sub>1</sub></span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.trm_if"><span class="id" title="constructor">trm_if</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_bool"><span class="id" title="constructor">val_bool</span></a> <a class="idref" href="Rules.html#b:59"><span class="id" title="variable">b</span></a>) <a class="idref" href="Rules.html#t<sub>1</sub>:61"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:62"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#s<sub>2</sub>:58"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Rules.html#v:60"><span class="id" title="variable">v</span></a><br/>
<br/>
</div>

<div class="doc">
5. <span class="inlinecode"><span class="id" title="tactic">eval</span></span> for primitive stateless operations.

<div class="paragraph"> </div>

      For similar reasons as explained above, the behavior of applied
      primitive functions only need to be described for the case of value
      arguments.

<div class="paragraph"> </div>

      An arithmetic operation expects integer arguments. The addition
      of <span class="inlinecode"><span class="id" title="var">val_int</span></span> <span class="inlinecode"><span class="id" title="var">n<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" title="var">val_int</span></span> <span class="inlinecode"><span class="id" title="var">n<sub>2</sub></span></span> produces <span class="inlinecode"><span class="id" title="var">val_int</span></span> <span class="inlinecode">(<span class="id" title="var">n<sub>1</sub></span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n<sub>2</sub></span>)</span>.

<div class="paragraph"> </div>

      The division operation, on the same arguments, produces the
      quotient <span class="inlinecode"><span class="id" title="var">n<sub>1</sub></span></span> <span class="inlinecode">/</span> <span class="inlinecode"><span class="id" title="var">n<sub>2</sub></span></span>, under the assumption that the dividor <span class="inlinecode"><span class="id" title="var">n<sub>2</sub></span></span>
      is non-zero. In other words, if a program performs a division
      by zero, then it cannot satisfy the <span class="inlinecode"><span class="id" title="tactic">eval</span></span> judgment. 
</div>
<div class="code">
<br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.eval_add" class="idref" href="#SyntaxAndSemantics.eval_add"><span class="id" title="constructor">eval_add</span></a> : <span class="id" title="keyword">∀</span> <a id="s:63" class="idref" href="#s:63"><span class="id" title="binder">s</span></a> <a id="n<sub>1</sub>:64" class="idref" href="#n<sub>1</sub>:64"><span class="id" title="binder">n<sub>1</sub></span></a> <a id="n<sub>2</sub>:65" class="idref" href="#n<sub>2</sub>:65"><span class="id" title="binder">n<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:63"><span class="id" title="variable">s</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_add"><span class="id" title="constructor">val_add</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_int"><span class="id" title="constructor">val_int</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:64"><span class="id" title="variable">n<sub>1</sub></span></a>) (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_int"><span class="id" title="constructor">val_int</span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:65"><span class="id" title="variable">n<sub>2</sub></span></a>)) <a class="idref" href="Rules.html#s:63"><span class="id" title="variable">s</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_int"><span class="id" title="constructor">val_int</span></a> (<a class="idref" href="Rules.html#n<sub>1</sub>:64"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:65"><span class="id" title="variable">n<sub>2</sub></span></a>))<br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.eval_div" class="idref" href="#SyntaxAndSemantics.eval_div"><span class="id" title="constructor">eval_div</span></a> : <span class="id" title="keyword">∀</span> <a id="s:66" class="idref" href="#s:66"><span class="id" title="binder">s</span></a> <a id="n<sub>1</sub>:67" class="idref" href="#n<sub>1</sub>:67"><span class="id" title="binder">n<sub>1</sub></span></a> <a id="n<sub>2</sub>:68" class="idref" href="#n<sub>2</sub>:68"><span class="id" title="binder">n<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#n<sub>2</sub>:68"><span class="id" title="variable">n<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;&gt;'_x"><span class="id" title="notation">≠</span></a> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:66"><span class="id" title="variable">s</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_div"><span class="id" title="constructor">val_div</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_int"><span class="id" title="constructor">val_int</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:67"><span class="id" title="variable">n<sub>1</sub></span></a>) (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_int"><span class="id" title="constructor">val_int</span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:68"><span class="id" title="variable">n<sub>2</sub></span></a>)) <a class="idref" href="Rules.html#s:66"><span class="id" title="variable">s</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_int"><span class="id" title="constructor">val_int</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#Z.quot"><span class="id" title="definition">Z.quot</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:67"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:68"><span class="id" title="variable">n<sub>2</sub></span></a>))<br/>
<br/>
</div>

<div class="doc">
6. <span class="inlinecode"><span class="id" title="tactic">eval</span></span> for primitive operations on memory.

<div class="paragraph"> </div>

      There remains to describe operations that act on the mutable store.

<div class="paragraph"> </div>

      <span class="inlinecode"><span class="id" title="var">val_ref</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> allocates a fresh cell with contents <span class="inlinecode"><span class="id" title="var">v</span></span>. The operation
      returns the location, written <span class="inlinecode"><span class="id" title="var">p</span></span>, of the new cell. This location
      must not be previously in the domain of the store <span class="inlinecode"><span class="id" title="var">s</span></span>.

<div class="paragraph"> </div>

      <span class="inlinecode"><span class="id" title="var">val_get</span></span> <span class="inlinecode">(<span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">p</span>)</span> reads the value in the store <span class="inlinecode"><span class="id" title="var">s</span></span> at location <span class="inlinecode"><span class="id" title="var">p</span></span>.
      The location must be bound to a value in the store, else evaluation
      is stuck.

<div class="paragraph"> </div>

      <span class="inlinecode"><span class="id" title="var">val_set</span></span> <span class="inlinecode">(<span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">p</span>)</span> <span class="inlinecode"><span class="id" title="var">v</span></span> updates the store at a location <span class="inlinecode"><span class="id" title="var">p</span></span> assumed to
      be bound in the store <span class="inlinecode"><span class="id" title="var">s</span></span>. The operation modifies the store and returns
      the unit value.

<div class="paragraph"> </div>

      <span class="inlinecode"><span class="id" title="var">val_free</span></span> <span class="inlinecode">(<span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">p</span>)</span> deallocates the cell at location <span class="inlinecode"><span class="id" title="var">p</span></span>. 
</div>
<div class="code">
<br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.eval_ref" class="idref" href="#SyntaxAndSemantics.eval_ref"><span class="id" title="constructor">eval_ref</span></a> : <span class="id" title="keyword">∀</span> <a id="s:69" class="idref" href="#s:69"><span class="id" title="binder">s</span></a> <a id="v:70" class="idref" href="#v:70"><span class="id" title="binder">v</span></a> <a id="p:71" class="idref" href="#p:71"><span class="id" title="binder">p</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">¬</span></a> <a class="idref" href="LibSepReference.html#Fmap.indom"><span class="id" title="definition">Fmap.indom</span></a> <a class="idref" href="Rules.html#s:69"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#p:71"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:69"><span class="id" title="variable">s</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_ref"><span class="id" title="constructor">val_ref</span></a> <a class="idref" href="Rules.html#v:70"><span class="id" title="variable">v</span></a>) (<a class="idref" href="LibSepReference.html#Fmap.update"><span class="id" title="definition">Fmap.update</span></a> <a class="idref" href="Rules.html#s:69"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#p:71"><span class="id" title="variable">p</span></a> <a class="idref" href="Rules.html#v:70"><span class="id" title="variable">v</span></a>) (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:71"><span class="id" title="variable">p</span></a>)<br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.eval_get" class="idref" href="#SyntaxAndSemantics.eval_get"><span class="id" title="constructor">eval_get</span></a> : <span class="id" title="keyword">∀</span> <a id="s:72" class="idref" href="#s:72"><span class="id" title="binder">s</span></a> <a id="p:73" class="idref" href="#p:73"><span class="id" title="binder">p</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.indom"><span class="id" title="definition">Fmap.indom</span></a> <a class="idref" href="Rules.html#s:72"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#p:73"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:72"><span class="id" title="variable">s</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_get"><span class="id" title="constructor">val_get</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:73"><span class="id" title="variable">p</span></a>)) <a class="idref" href="Rules.html#s:72"><span class="id" title="variable">s</span></a> (<a class="idref" href="LibSepReference.html#Fmap.read"><span class="id" title="definition">Fmap.read</span></a> <a class="idref" href="Rules.html#s:72"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#p:73"><span class="id" title="variable">p</span></a>)<br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.eval_set" class="idref" href="#SyntaxAndSemantics.eval_set"><span class="id" title="constructor">eval_set</span></a> : <span class="id" title="keyword">∀</span> <a id="s:74" class="idref" href="#s:74"><span class="id" title="binder">s</span></a> <a id="p:75" class="idref" href="#p:75"><span class="id" title="binder">p</span></a> <a id="v:76" class="idref" href="#v:76"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.indom"><span class="id" title="definition">Fmap.indom</span></a> <a class="idref" href="Rules.html#s:74"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#p:75"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:74"><span class="id" title="variable">s</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_set"><span class="id" title="constructor">val_set</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:75"><span class="id" title="variable">p</span></a>) <a class="idref" href="Rules.html#v:76"><span class="id" title="variable">v</span></a>) (<a class="idref" href="LibSepReference.html#Fmap.update"><span class="id" title="definition">Fmap.update</span></a> <a class="idref" href="Rules.html#s:74"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#p:75"><span class="id" title="variable">p</span></a> <a class="idref" href="Rules.html#v:76"><span class="id" title="variable">v</span></a>) <a class="idref" href="Rules.html#SyntaxAndSemantics.val_unit"><span class="id" title="constructor">val_unit</span></a><br/>
&nbsp;&nbsp;| <a id="SyntaxAndSemantics.eval_free" class="idref" href="#SyntaxAndSemantics.eval_free"><span class="id" title="constructor">eval_free</span></a> : <span class="id" title="keyword">∀</span> <a id="s:77" class="idref" href="#s:77"><span class="id" title="binder">s</span></a> <a id="p:78" class="idref" href="#p:78"><span class="id" title="binder">p</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.indom"><span class="id" title="definition">Fmap.indom</span></a> <a class="idref" href="Rules.html#s:77"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#p:78"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#eval:16"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:77"><span class="id" title="variable">s</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_free"><span class="id" title="constructor">val_free</span></a> (<a class="idref" href="Rules.html#SyntaxAndSemantics.val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:78"><span class="id" title="variable">p</span></a>)) (<a class="idref" href="LibSepReference.html#Fmap.remove"><span class="id" title="definition">Fmap.remove</span></a> <a class="idref" href="Rules.html#s:77"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#p:78"><span class="id" title="variable">p</span></a>) <a class="idref" href="Rules.html#SyntaxAndSemantics.val_unit"><span class="id" title="constructor">val_unit</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Rules.html#SyntaxAndSemantics"><span class="id" title="module">SyntaxAndSemantics</span></a>.<br/>
</div>

<div class="doc">
<a id="lab160"></a><h3 class="section">Loading of Definitions from <span class="inlinecode"><span class="id" title="var">Direct</span></span></h3>

<div class="paragraph"> </div>

 Throughout the rest of this file, we rely not on the definitions
    shown above, but on the definitions from <span class="inlinecode"><span class="id" title="var">LibSepDirect.v</span></span>. The latter
    are slightly more general, yet completely equivalent to the ones
    presented above for the purpose of establishing the reasoning rules
    that we are interested in. 
<div class="paragraph"> </div>

 To reduce the clutter in the statement of lemmas, we associate default
    types to a number of common meta-variables. 
</div>
<div class="code">

<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">x</span> <span class="id" title="var">f</span> : <a class="idref" href="LibSepVar.html#var"><span class="id" title="definition">var</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">b</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">p</span> : <a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">n</span> : <span class="id" title="notation">int</span>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">v</span> <span class="id" title="var">w</span> <span class="id" title="var">r</span> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">t</span> : <a class="idref" href="LibSepReference.html#trm"><span class="id" title="inductive">trm</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">h</span> : <a class="idref" href="LibSepReference.html#heap"><span class="id" title="definition">heap</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">s</span> : <a class="idref" href="LibSepReference.html#state"><span class="id" title="definition">state</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">H</span> : <a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">Q</span> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>.<br/>
</div>

<div class="doc">
<a id="lab161"></a><h2 class="section">Review of the Structural Rules</h2>

<div class="paragraph"> </div>

 Let us review the essential structural rules, which were introduced
    in the previous chapters. These structural rules are involved in
    the practical verification proofs carried out further in this chapter. 
<div class="paragraph"> </div>

 The frame rule asserts that the precondition and the postcondition
    can be extended together by an arbitrary heap predicate.
    Recall that the definition of <span class="inlinecode"><span class="id" title="var">triple</span></span> was set up precisely to
    validate this frame rule, so in a sense in holds "by construction". 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_frame" class="idref" href="#triple_frame"><span class="id" title="axiom">triple_frame</span></a> : <span class="id" title="keyword">∀</span> <a id="t:79" class="idref" href="#t:79"><span class="id" title="binder">t</span></a> <a id="H:80" class="idref" href="#H:80"><span class="id" title="binder">H</span></a> <a id="Q:81" class="idref" href="#Q:81"><span class="id" title="binder">Q</span></a> <a id="H':82" class="idref" href="#H':82"><span class="id" title="binder">H'</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t:79"><span class="id" title="variable">t</span></a> <a class="idref" href="Rules.html#H:80"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:81"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t:79"><span class="id" title="variable">t</span></a> (<a class="idref" href="Rules.html#H:80"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Rules.html#H':82"><span class="id" title="variable">H'</span></a>) (<a class="idref" href="Rules.html#Q:81"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Rules.html#H':82"><span class="id" title="variable">H'</span></a>).<br/>
</div>

<div class="doc">
The consequence rule allows to strengthen the precondition and
    weaken the postcondition. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_conseq" class="idref" href="#triple_conseq"><span class="id" title="axiom">triple_conseq</span></a> : <span class="id" title="keyword">∀</span> <a id="t:84" class="idref" href="#t:84"><span class="id" title="binder">t</span></a> <a id="H':85" class="idref" href="#H':85"><span class="id" title="binder">H'</span></a> <a id="Q':86" class="idref" href="#Q':86"><span class="id" title="binder">Q'</span></a> <a id="H:87" class="idref" href="#H:87"><span class="id" title="binder">H</span></a> <a id="Q:88" class="idref" href="#Q:88"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t:84"><span class="id" title="variable">t</span></a> <a class="idref" href="Rules.html#H':85"><span class="id" title="variable">H'</span></a> <a class="idref" href="Rules.html#Q':86"><span class="id" title="variable">Q'</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#H:87"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Rules.html#H':85"><span class="id" title="variable">H'</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#Q':86"><span class="id" title="variable">Q'</span></a> <a class="idref" href="LibSepReference.html#9351a4f098e275023c32e0091e608189"><span class="id" title="notation">===&gt;</span></a> <a class="idref" href="Rules.html#Q:88"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t:84"><span class="id" title="variable">t</span></a> <a class="idref" href="Rules.html#H:87"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:88"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
In practice, it is most convenient to exploit a rule that combines
    both frame and consequence into a single rule, as stated next.
    (Note that this "combined structural rule" was proved as an exercise
    in chapter <a href="Himpl.html"><span class="inlineref">Himpl</span></a>.) 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_conseq_frame" class="idref" href="#triple_conseq_frame"><span class="id" title="axiom">triple_conseq_frame</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>2</sub>:90" class="idref" href="#H<sub>2</sub>:90"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="H<sub>1</sub>:91" class="idref" href="#H<sub>1</sub>:91"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="Q<sub>1</sub>:92" class="idref" href="#Q<sub>1</sub>:92"><span class="id" title="binder">Q<sub>1</sub></span></a> <a id="t:93" class="idref" href="#t:93"><span class="id" title="binder">t</span></a> <a id="H:94" class="idref" href="#H:94"><span class="id" title="binder">H</span></a> <a id="Q:95" class="idref" href="#Q:95"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t:93"><span class="id" title="variable">t</span></a> <a class="idref" href="Rules.html#H<sub>1</sub>:91"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Rules.html#Q<sub>1</sub>:92"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#H:94"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Rules.html#H<sub>1</sub>:91"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Rules.html#H<sub>2</sub>:90"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#Q<sub>1</sub>:92"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Rules.html#H<sub>2</sub>:90"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#9351a4f098e275023c32e0091e608189"><span class="id" title="notation">===&gt;</span></a> <a class="idref" href="Rules.html#Q:95"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t:93"><span class="id" title="variable">t</span></a> <a class="idref" href="Rules.html#H:94"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:95"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
The two extraction rules enable to extract pure facts and existentially
    quantified variables, from the precondition into the Coq context. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_hpure" class="idref" href="#triple_hpure"><span class="id" title="axiom">triple_hpure</span></a> : <span class="id" title="keyword">∀</span> <a id="t:97" class="idref" href="#t:97"><span class="id" title="binder">t</span></a> (<a id="P:98" class="idref" href="#P:98"><span class="id" title="binder">P</span></a>:<span class="id" title="keyword">Prop</span>) <a id="H:99" class="idref" href="#H:99"><span class="id" title="binder">H</span></a> <a id="Q:100" class="idref" href="#Q:100"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Rules.html#P:98"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t:97"><span class="id" title="variable">t</span></a> <a class="idref" href="Rules.html#H:99"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:100"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t:97"><span class="id" title="variable">t</span></a> (<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#P:98"><span class="id" title="variable">P</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Rules.html#H:99"><span class="id" title="variable">H</span></a>) <a class="idref" href="Rules.html#Q:100"><span class="id" title="variable">Q</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Parameter</span> <a id="triple_hexists" class="idref" href="#triple_hexists"><span class="id" title="axiom">triple_hexists</span></a> : <span class="id" title="keyword">∀</span> <a id="t:102" class="idref" href="#t:102"><span class="id" title="binder">t</span></a> (<a id="A:103" class="idref" href="#A:103"><span class="id" title="binder">A</span></a>:<span class="id" title="keyword">Type</span>) (<a id="J:104" class="idref" href="#J:104"><span class="id" title="binder">J</span></a>:<a class="idref" href="Rules.html#A:103"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>) <a id="Q:105" class="idref" href="#Q:105"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> (<a id="x:106" class="idref" href="#x:106"><span class="id" title="binder">x</span></a>:<a class="idref" href="Rules.html#A:103"><span class="id" title="variable">A</span></a>), <a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t:102"><span class="id" title="variable">t</span></a> (<a class="idref" href="Rules.html#J:104"><span class="id" title="variable">J</span></a> <a class="idref" href="Rules.html#x:106"><span class="id" title="variable">x</span></a>) <a class="idref" href="Rules.html#Q:105"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t:102"><span class="id" title="variable">t</span></a> (<a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">(</span></a><a id="x:107" class="idref" href="#x:107"><span class="id" title="binder">x</span></a>:<a class="idref" href="Rules.html#A:103"><span class="id" title="variable">A</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">),</span></a> <a class="idref" href="Rules.html#J:104"><span class="id" title="variable">J</span></a> <a class="idref" href="Rules.html#x:107"><span class="id" title="variable">x</span></a>) <a class="idref" href="Rules.html#Q:105"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
<a id="lab162"></a><h4 class="section">Exercise: 1 star, standard, optional (triple_hpure')</h4>
 The extraction rule <span class="inlinecode"><span class="id" title="var">triple_hpure</span></span> assumes a precondition of the form
    <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">P</span>]</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H</span></span>. The variant rule <span class="inlinecode"><span class="id" title="var">triple_hpure'</span></span>, stated below, assumes
    instead a precondition with only the pure part, i.e., of the form <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">P</span>]</span>.
    Prove that <span class="inlinecode"><span class="id" title="var">triple_hpure'</span></span> is indeed a corollary of <span class="inlinecode"><span class="id" title="var">triple_hpure</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_hpure'" class="idref" href="#triple_hpure'"><span class="id" title="lemma">triple_hpure'</span></a> : <span class="id" title="keyword">∀</span> <a id="t:109" class="idref" href="#t:109"><span class="id" title="binder">t</span></a> (<a id="P:110" class="idref" href="#P:110"><span class="id" title="binder">P</span></a>:<span class="id" title="keyword">Prop</span>) <a id="Q:111" class="idref" href="#Q:111"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Rules.html#P:110"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t:109"><span class="id" title="variable">t</span></a> <a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a> <a class="idref" href="Rules.html#Q:111"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t:109"><span class="id" title="variable">t</span></a> <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#P:110"><span class="id" title="variable">P</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="Rules.html#Q:111"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab163"></a><h2 class="section">Rules for Terms</h2>

<div class="paragraph"> </div>

 We next present reasoning rule for terms. Most of these Separation Logic
    rules have a statement essentially identical to the statement of the
    corresponding Hoare Logic rule. The main difference lies in their
    interpretation: whereas Hoare Logic pre- and post-conditions describe
    the full state, a Separation Logic rule describes only a fraction of
    the mutable state. 
</div>

<div class="doc">
<a id="lab164"></a><h3 class="section">Reasoning Rule for Sequences</h3>

<div class="paragraph"> </div>

 Let us begin with the reasoning rule for sequences.
    The Separation Logic reasoning rule for a sequence <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span>;<span class="id" title="var">t<sub>2</sub></span></span> is
    essentially the same as that from Hoare logic. The rule is:
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">{H} t<sub>1</sub> {fun v => H<sub>1</sub>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{H<sub>1</sub>} t<sub>2</sub> {Q}</td>
  <td class="infrulenamecol" rowspan="3">
    &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">{H} (t<sub>1</sub>;t<sub>2</sub>) {Q}</td>
  <td></td>
</td>
</table></center>    The Coq statement corresponding to the above rule is: 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_seq" class="idref" href="#triple_seq"><span class="id" title="axiom">triple_seq</span></a> : <span class="id" title="keyword">∀</span> <a id="t<sub>1</sub>:112" class="idref" href="#t<sub>1</sub>:112"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:113" class="idref" href="#t<sub>2</sub>:113"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="H:114" class="idref" href="#H:114"><span class="id" title="binder">H</span></a> <a id="Q:115" class="idref" href="#Q:115"><span class="id" title="binder">Q</span></a> <a id="H<sub>1</sub>:116" class="idref" href="#H<sub>1</sub>:116"><span class="id" title="binder">H<sub>1</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:112"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#H:114"><span class="id" title="variable">H</span></a> (<span class="id" title="keyword">fun</span> <a id="v:117" class="idref" href="#v:117"><span class="id" title="binder">v</span></a> ⇒ <a class="idref" href="Rules.html#H<sub>1</sub>:116"><span class="id" title="variable">H<sub>1</sub></span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:113"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="Rules.html#H<sub>1</sub>:116"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Rules.html#Q:115"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_seq"><span class="id" title="constructor">trm_seq</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:112"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:113"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#H:114"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:115"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
The variable <span class="inlinecode"><span class="id" title="var">v</span></span> denotes the result of the evaluation of <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>. For
    well-typed programs, this result would always be <span class="inlinecode"><span class="id" title="var">val_unit</span></span>. Yet,
    because we here consider an untyped language, we do not bother
    adding the constraint <span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">val_unit</span></span>. Instead, we simply treat the
    result of <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> as a value irrelevant to the remaining of the
    evaluation. 
</div>

<div class="doc">
<a id="lab165"></a><h3 class="section">Reasoning Rule for Let-Bindings</h3>

<div class="paragraph"> </div>

 Next, we present the reasoning rule for let-bindings. Here again,
    there is nothing specific to Separation Logic, the rule would be
    exactly the same in Hoare Logic.

<div class="paragraph"> </div>

    The reasoning rule for a let binding <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> could
    be stated, in informal writing, in the form:
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">{H} t<sub>1</sub> {Q<sub>1</sub>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall x, {Q<sub>1</sub> x} t<sub>2</sub> {Q})</td>
  <td class="infrulenamecol" rowspan="3">
    &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">{H} (let x = t<sub>1</sub> in t<sub>2</sub>) {Q}</td>
  <td></td>
</td>
</table></center>  Yet, such a presentation makes a confusion between the <span class="inlinecode"><span class="id" title="var">x</span></span> that
  denotes a program variable in <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>, and the <span class="inlinecode"><span class="id" title="var">x</span></span>
  that denotes a value when quantified as <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>.

<div class="paragraph"> </div>

  The correct statement involves a substitution from the variable
  <span class="inlinecode"><span class="id" title="var">x</span></span> to a value quantified as <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode">(<span class="id" title="var">v</span>:<span class="id" title="var">val</span>)</span>.
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">{H} t<sub>1</sub> {Q<sub>1</sub>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall v, {Q<sub>1</sub> v} (subst x v t<sub>2</sub>) {Q})</td>
  <td class="infrulenamecol" rowspan="3">
    &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">{H} (let x = t<sub>1</sub> in t<sub>2</sub>) {Q}</td>
  <td></td>
</td>
</table></center>  The corresponding Coq statement is thus as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_let" class="idref" href="#triple_let"><span class="id" title="axiom">triple_let</span></a> : <span class="id" title="keyword">∀</span> <a id="x:119" class="idref" href="#x:119"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:120" class="idref" href="#t<sub>1</sub>:120"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:121" class="idref" href="#t<sub>2</sub>:121"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="Q<sub>1</sub>:122" class="idref" href="#Q<sub>1</sub>:122"><span class="id" title="binder">Q<sub>1</sub></span></a> <a id="H:123" class="idref" href="#H:123"><span class="id" title="binder">H</span></a> <a id="Q:124" class="idref" href="#Q:124"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:120"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#H:123"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q<sub>1</sub>:122"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="v<sub>1</sub>:125" class="idref" href="#v<sub>1</sub>:125"><span class="id" title="binder">v<sub>1</sub></span></a>, <a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#subst"><span class="id" title="definition">subst</span></a> <a class="idref" href="Rules.html#x:119"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:125"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:121"><span class="id" title="variable">t<sub>2</sub></span></a>) (<a class="idref" href="Rules.html#Q<sub>1</sub>:122"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:125"><span class="id" title="variable">v<sub>1</sub></span></a>) <a class="idref" href="Rules.html#Q:124"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_let"><span class="id" title="constructor">trm_let</span></a> <a class="idref" href="Rules.html#x:119"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:120"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:121"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#H:123"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:124"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
<a id="lab166"></a><h3 class="section">Reasoning Rule for Conditionals</h3>

<div class="paragraph"> </div>

 The rule for a conditional is, again, exactly like in Hoare logic.
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">b = true <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> {H} t<sub>1</sub> {Q}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = false <span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> {H} t<sub>2</sub> {Q}</td>
  <td class="infrulenamecol" rowspan="3">
    &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">{H} (if b then t<sub>1</sub> in t<sub>2</sub>) {Q}</td>
  <td></td>
</td>
</table></center>  The corresponding Coq statement appears next.

</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_if_case" class="idref" href="#triple_if_case"><span class="id" title="axiom">triple_if_case</span></a> : <span class="id" title="keyword">∀</span> <a id="b:127" class="idref" href="#b:127"><span class="id" title="binder">b</span></a> <a id="t<sub>1</sub>:128" class="idref" href="#t<sub>1</sub>:128"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:129" class="idref" href="#t<sub>2</sub>:129"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="H:130" class="idref" href="#H:130"><span class="id" title="binder">H</span></a> <a id="Q:131" class="idref" href="#Q:131"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Rules.html#b:127"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:128"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#H:130"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:131"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Rules.html#b:127"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:129"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="Rules.html#H:130"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:131"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_if"><span class="id" title="constructor">trm_if</span></a> (<a class="idref" href="LibSepReference.html#val_bool"><span class="id" title="constructor">val_bool</span></a> <a class="idref" href="Rules.html#b:127"><span class="id" title="variable">b</span></a>) <a class="idref" href="Rules.html#t<sub>1</sub>:128"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:129"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#H:130"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:131"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
Note that the two premises may be factorized into a single one
    using Coq's conditional construct. Such an alternative
    statement is discussed further in this chapter. 
</div>

<div class="doc">
<a id="lab167"></a><h3 class="section">Reasoning Rule for Values</h3>

<div class="paragraph"> </div>

 The rule for a value <span class="inlinecode"><span class="id" title="var">v</span></span> can be written as a triple with an
    empty precondition and a postcondition asserting that the
    result value <span class="inlinecode"><span class="id" title="var">r</span></span> is equal to <span class="inlinecode"><span class="id" title="var">v</span></span>, in the empty heap. Formally:
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">{<span class='gray-font'>\</span>[]} v {fun r => <span class='gray-font'>\</span>[r = v]}</td>
  <td></td>
</td>
</table></center>    It is however more convenient in practice to work with a judgment
    whose conclusion is of the form <span class="inlinecode">{<span class="id" title="var">H</span>}</span> <span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode">{<span class="id" title="var">Q</span>}</span>, for an arbitrary
    <span class="inlinecode"><span class="id" title="var">H</span></span> and <span class="inlinecode"><span class="id" title="var">Q</span></span>. For this reason, we prefer the following rule for
    values.
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">H ==> Q v</td>
  <td class="infrulenamecol" rowspan="3">
    &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">{H} v {Q}</td>
  <td></td>
</td>
</table></center>    It may not be completely obvious at first sight why this alternative
    rule is equivalent to the former. We prove the equivalence further
    in this chapter.

<div class="paragraph"> </div>

    The Coq statement of the rule for values is thus as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_val" class="idref" href="#triple_val"><span class="id" title="axiom">triple_val</span></a> : <span class="id" title="keyword">∀</span> <a id="v:133" class="idref" href="#v:133"><span class="id" title="binder">v</span></a> <a id="H:134" class="idref" href="#H:134"><span class="id" title="binder">H</span></a> <a id="Q:135" class="idref" href="#Q:135"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#H:134"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Rules.html#Q:135"><span class="id" title="variable">Q</span></a> <a class="idref" href="Rules.html#v:133"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_val"><span class="id" title="constructor">trm_val</span></a> <a class="idref" href="Rules.html#v:133"><span class="id" title="variable">v</span></a>) <a class="idref" href="Rules.html#H:134"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:135"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
Let us prove that the "minimalistic" rule <span class="inlinecode">{<span class='gray-font'>\</span>[]}</span> <span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode">{<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">v</span>]}</span>
    is equivalent to <span class="inlinecode"><span class="id" title="var">triple_val</span></span>. 
<div class="paragraph"> </div>

<a id="lab168"></a><h4 class="section">Exercise: 1 star, standard, especially useful (triple_val_minimal)</h4>
 Prove that the alternative rule for values derivable from
    <span class="inlinecode"><span class="id" title="var">triple_val</span></span>. Hint: use the tactic <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> to conclude the proof. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_val_minimal" class="idref" href="#triple_val_minimal"><span class="id" title="lemma">triple_val_minimal</span></a> : <span class="id" title="keyword">∀</span> <a id="v:137" class="idref" href="#v:137"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_val"><span class="id" title="constructor">trm_val</span></a> <a class="idref" href="Rules.html#v:137"><span class="id" title="variable">v</span></a>) <a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a> (<span class="id" title="keyword">fun</span> <a id="r:138" class="idref" href="#r:138"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#r:138"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Rules.html#v:137"><span class="id" title="variable">v</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab169"></a><h4 class="section">Exercise: 2 stars, standard, especially useful (triple_val')</h4>
 More interestingly, prove that <span class="inlinecode"><span class="id" title="var">triple_val</span></span> is derivable
    from <span class="inlinecode"><span class="id" title="var">triple_val_minimal</span></span>. Hint: you will need to exploit
    the structural rule <span class="inlinecode"><span class="id" title="var">triple_conseq_frame</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_val'" class="idref" href="#triple_val'"><span class="id" title="lemma">triple_val'</span></a> : <span class="id" title="keyword">∀</span> <a id="v:139" class="idref" href="#v:139"><span class="id" title="binder">v</span></a> <a id="H:140" class="idref" href="#H:140"><span class="id" title="binder">H</span></a> <a id="Q:141" class="idref" href="#Q:141"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#H:140"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Rules.html#Q:141"><span class="id" title="variable">Q</span></a> <a class="idref" href="Rules.html#v:139"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_val"><span class="id" title="constructor">trm_val</span></a> <a class="idref" href="Rules.html#v:139"><span class="id" title="variable">v</span></a>) <a class="idref" href="Rules.html#H:140"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:141"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab170"></a><h4 class="section">Exercise: 4 stars, standard, especially useful (triple_let_val)</h4>
 Consider a term of the form <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">v<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>, that is, where the
    argument of the let-binding is already a value. State and prove a
    reasoning rule of the form:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">triple_let_val</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">v<sub>1</sub></span> <span class="id" title="var">t<sub>2</sub></span> <span class="id" title="var">H</span> <span class="id" title="var">Q</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">triple</span> (<span class="id" title="var">trm_let</span> <span class="id" title="var">x</span> <span class="id" title="var">v<sub>1</sub></span> <span class="id" title="var">t<sub>2</sub></span>) <span class="id" title="var">H</span> <span class="id" title="var">Q</span>.
</span>    Hint: you'll need to guess the intermediate postcondition <span class="inlinecode"><span class="id" title="var">Q<sub>1</sub></span></span> associated
    with the let-binding rule, and exploit the appropriate structural rules. 
</div>
<div class="code">

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab171"></a><h3 class="section">Reasoning Rule for Functions</h3>

<div class="paragraph"> </div>

 In addition to the reasoning rule for values, we need reasoning
    rules for functions and recursive functions that appear as terms
    in the source program (as opposed to appearing as values).

<div class="paragraph"> </div>

    A function definition <span class="inlinecode"><span class="id" title="var">trm_fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>, expressed as a subterm in a
    program, evaluates to a value, more precisely to <span class="inlinecode"><span class="id" title="var">val_fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>.
    Again, we could consider a rule with an empty precondition:
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">{<span class='gray-font'>\</span>[]} (trm_fun x t<sub>1</sub>) {fun r => <span class='gray-font'>\</span>[r = val_fun x t<sub>1</sub>]}</td>
  <td></td>
</td>
</table></center>   However, we prefer a conclusion of the form <span class="inlinecode">{<span class="id" title="var">H</span>}</span> <span class="inlinecode">(<span class="id" title="var">trm_fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span>)</span> <span class="inlinecode">{<span class="id" title="var">Q</span>}</span>.
   We thus consider the following rule, very similar to <span class="inlinecode"><span class="id" title="var">triple_val</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_fun" class="idref" href="#triple_fun"><span class="id" title="axiom">triple_fun</span></a> : <span class="id" title="keyword">∀</span> <a id="x:142" class="idref" href="#x:142"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:143" class="idref" href="#t<sub>1</sub>:143"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="H:144" class="idref" href="#H:144"><span class="id" title="binder">H</span></a> <a id="Q:145" class="idref" href="#Q:145"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#H:144"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Rules.html#Q:145"><span class="id" title="variable">Q</span></a> (<a class="idref" href="LibSepReference.html#val_fun"><span class="id" title="constructor">val_fun</span></a> <a class="idref" href="Rules.html#x:142"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:143"><span class="id" title="variable">t<sub>1</sub></span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_fun"><span class="id" title="constructor">trm_fun</span></a> <a class="idref" href="Rules.html#x:142"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:143"><span class="id" title="variable">t<sub>1</sub></span></a>) <a class="idref" href="Rules.html#H:144"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:145"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
The rule for recursive functions is similar. It is presented
    further in the file. 
<div class="paragraph"> </div>

 Last but not least, we need a reasoning rule to reason about a
    function application. Consider an application <span class="inlinecode"><span class="id" title="var">trm_app</span></span> <span class="inlinecode"><span class="id" title="var">v<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">v<sub>2</sub></span></span>.
    Assume <span class="inlinecode"><span class="id" title="var">v<sub>1</sub></span></span> to be a function, that is, to be of the form
    <span class="inlinecode"><span class="id" title="var">val_fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>. Then, according to the beta-reduction rule, the
    semantics of <span class="inlinecode"><span class="id" title="var">trm_app</span></span> <span class="inlinecode"><span class="id" title="var">v<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">v<sub>2</sub></span></span> is the same as that of <span class="inlinecode"><span class="id" title="tactic">subst</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">v<sub>2</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>.
    This reasoning rule is thus:
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">v<sub>1</sub> = val_fun x t<sub>1</sub>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{H} (subst x v<sub>2</sub> t<sub>1</sub>) {Q}</td>
  <td class="infrulenamecol" rowspan="3">
    &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">{H} (trm_app v<sub>1</sub> v<sub>2</sub>) {Q}</td>
  <td></td>
</td>
</table></center>   The corresponding Coq statement is as shown below. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_app_fun" class="idref" href="#triple_app_fun"><span class="id" title="axiom">triple_app_fun</span></a> : <span class="id" title="keyword">∀</span> <a id="x:147" class="idref" href="#x:147"><span class="id" title="binder">x</span></a> <a id="v<sub>1</sub>:148" class="idref" href="#v<sub>1</sub>:148"><span class="id" title="binder">v<sub>1</sub></span></a> <a id="v<sub>2</sub>:149" class="idref" href="#v<sub>2</sub>:149"><span class="id" title="binder">v<sub>2</sub></span></a> <a id="t<sub>1</sub>:150" class="idref" href="#t<sub>1</sub>:150"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="H:151" class="idref" href="#H:151"><span class="id" title="binder">H</span></a> <a id="Q:152" class="idref" href="#Q:152"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#v<sub>1</sub>:148"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_fun"><span class="id" title="constructor">val_fun</span></a> <a class="idref" href="Rules.html#x:147"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:150"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#subst"><span class="id" title="definition">subst</span></a> <a class="idref" href="Rules.html#x:147"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#v<sub>2</sub>:149"><span class="id" title="variable">v<sub>2</sub></span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:150"><span class="id" title="variable">t<sub>1</sub></span></a>) <a class="idref" href="Rules.html#H:151"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:152"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_app"><span class="id" title="constructor">trm_app</span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:148"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Rules.html#v<sub>2</sub>:149"><span class="id" title="variable">v<sub>2</sub></span></a>) <a class="idref" href="Rules.html#H:151"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:152"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
The generalization to the application of recursive functions is
    straightforward. It is discussed further in this chapter. 
</div>

<div class="doc">
<a id="lab172"></a><h2 class="section">Specification of Primitive Operations</h2>

<div class="paragraph"> </div>

 Before we can tackle verification of actual programs, there remains
    to present the specifications for the primitive operations.
    Let us begin with basic arithmetic operations: addition and division. 
</div>

<div class="doc">
<a id="lab173"></a><h3 class="section">Specification of Arithmetic Primitive Operations</h3>

<div class="paragraph"> </div>

 Consider a term of the form <span class="inlinecode"><span class="id" title="var">val_add</span></span> <span class="inlinecode"><span class="id" title="var">n<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">n<sub>2</sub></span></span>, which is short for
    <span class="inlinecode"><span class="id" title="var">trm_app</span></span> <span class="inlinecode">(<span class="id" title="var">trm_app</span></span> <span class="inlinecode">(<span class="id" title="var">trm_val</span></span> <span class="inlinecode"><span class="id" title="var">val_add</span>)</span> <span class="inlinecode">(<span class="id" title="var">val_int</span></span> <span class="inlinecode"><span class="id" title="var">n<sub>1</sub></span>))</span> <span class="inlinecode">(<span class="id" title="var">val_int</span></span> <span class="inlinecode"><span class="id" title="var">n<sub>2</sub></span>)</span>.
    Indeed, recall that <span class="inlinecode"><span class="id" title="var">val_int</span></span> is declared as a coercion.

<div class="paragraph"> </div>

    The addition operation may execute in an empty state. It does not
    modify the state, and returns the value <span class="inlinecode"><span class="id" title="var">val_int</span></span> <span class="inlinecode">(<span class="id" title="var">n<sub>1</sub></span>+<span class="id" title="var">n<sub>2</sub></span>)</span>.

<div class="paragraph"> </div>

    In the specification shown below, the precondition is written <span class="inlinecode"><span class='gray-font'>\</span>[]</span>
    and the postcondition binds a return value <span class="inlinecode"><span class="id" title="var">r</span></span> of type <span class="inlinecode"><span class="id" title="var">val</span></span>
    specified to be equal to <span class="inlinecode"><span class="id" title="var">val_int</span></span> <span class="inlinecode">(<span class="id" title="var">n<sub>1</sub></span>+<span class="id" title="var">n<sub>2</sub></span>)</span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_add" class="idref" href="#triple_add"><span class="id" title="axiom">triple_add</span></a> : <span class="id" title="keyword">∀</span> <a id="n<sub>1</sub>:154" class="idref" href="#n<sub>1</sub>:154"><span class="id" title="binder">n<sub>1</sub></span></a> <a id="n<sub>2</sub>:155" class="idref" href="#n<sub>2</sub>:155"><span class="id" title="binder">n<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_add"><span class="id" title="constructor">val_add</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:154"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:155"><span class="id" title="variable">n<sub>2</sub></span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:156" class="idref" href="#r:156"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#r:156"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> (<a class="idref" href="Rules.html#n<sub>1</sub>:154"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:155"><span class="id" title="variable">n<sub>2</sub></span></a>)<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
</div>

<div class="doc">
The specification of the division operation <span class="inlinecode"><span class="id" title="var">val_div</span></span> <span class="inlinecode"><span class="id" title="var">n<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">n<sub>2</sub></span></span> is similar,
    yet with the extra requirement that the argument <span class="inlinecode"><span class="id" title="var">n<sub>2</sub></span></span> must be nonzero.
    This requirement <span class="inlinecode"><span class="id" title="var">n<sub>2</sub></span></span> <span class="inlinecode">≠</span> <span class="inlinecode">0</span> is a pure fact, which can be asserted as
    part of the precondition, as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_div'" class="idref" href="#triple_div'"><span class="id" title="axiom">triple_div'</span></a> : <span class="id" title="keyword">∀</span> <a id="n<sub>1</sub>:158" class="idref" href="#n<sub>1</sub>:158"><span class="id" title="binder">n<sub>1</sub></span></a> <a id="n<sub>2</sub>:159" class="idref" href="#n<sub>2</sub>:159"><span class="id" title="binder">n<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_div"><span class="id" title="constructor">val_div</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:158"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:159"><span class="id" title="variable">n<sub>2</sub></span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#n<sub>2</sub>:159"><span class="id" title="variable">n<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;&gt;'_x"><span class="id" title="notation">≠</span></a> 0<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:160" class="idref" href="#r:160"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#r:160"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#Z.quot"><span class="id" title="definition">Z.quot</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:158"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:159"><span class="id" title="variable">n<sub>2</sub></span></a>)<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
</div>

<div class="doc">
Equivalently, the requirement <span class="inlinecode"><span class="id" title="var">n<sub>2</sub></span></span> <span class="inlinecode">≠</span> <span class="inlinecode">0</span> may be asserted as an
    hypothesis to the front of the triple judgment, in the form of
    a standard Coq hypothesis, as shown below. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_div" class="idref" href="#triple_div"><span class="id" title="axiom">triple_div</span></a> : <span class="id" title="keyword">∀</span> <a id="n<sub>1</sub>:162" class="idref" href="#n<sub>1</sub>:162"><span class="id" title="binder">n<sub>1</sub></span></a> <a id="n<sub>2</sub>:163" class="idref" href="#n<sub>2</sub>:163"><span class="id" title="binder">n<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#n<sub>2</sub>:163"><span class="id" title="variable">n<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;&gt;'_x"><span class="id" title="notation">≠</span></a> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_div"><span class="id" title="constructor">val_div</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:162"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:163"><span class="id" title="variable">n<sub>2</sub></span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:164" class="idref" href="#r:164"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#r:164"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#Z.quot"><span class="id" title="definition">Z.quot</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:162"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:163"><span class="id" title="variable">n<sub>2</sub></span></a>)<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
</div>

<div class="doc">
This latter presentation with pure facts such as <span class="inlinecode"><span class="id" title="var">n<sub>2</sub></span></span> <span class="inlinecode">≠</span> <span class="inlinecode">0</span> placed
    to the front of the triple turns out to be more practical to exploit
    in proofs. Hence, we always follow this style of presentation, and
    reserve the precondition for describing pieces of mutable state. 
</div>

<div class="doc">
<a id="lab174"></a><h3 class="section">Specification of Primitive Operations Acting on Memory</h3>

<div class="paragraph"> </div>

 There remains to describe the specification of operations on the heap. 
<div class="paragraph"> </div>

 Recall that <span class="inlinecode"><span class="id" title="var">val_get</span></span> denotes the operation for reading a memory cell.
    A call of the form <span class="inlinecode"><span class="id" title="var">val_get</span></span> <span class="inlinecode"><span class="id" title="var">v'</span></span> executes safely if <span class="inlinecode"><span class="id" title="var">v'</span></span> is of the
    form <span class="inlinecode"><span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> for some location <span class="inlinecode"><span class="id" title="var">p</span></span>, in a state that features
    a memory cell at location <span class="inlinecode"><span class="id" title="var">p</span></span>, storing some contents <span class="inlinecode"><span class="id" title="var">v</span></span>. Such a state
    is described as <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">v</span></span>. The read operation returns a value <span class="inlinecode"><span class="id" title="var">r</span></span>
    such that <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">v</span></span>, and the memory state of the operation remains
    unchanged. The specification of <span class="inlinecode"><span class="id" title="var">val_get</span></span> is thus expressed as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_get" class="idref" href="#triple_get"><span class="id" title="axiom">triple_get</span></a> : <span class="id" title="keyword">∀</span> <a id="v:166" class="idref" href="#v:166"><span class="id" title="binder">v</span></a> <a id="p:167" class="idref" href="#p:167"><span class="id" title="binder">p</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_get"><span class="id" title="constructor">val_get</span></a> (<a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:167"><span class="id" title="variable">p</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Rules.html#p:167"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:166"><span class="id" title="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:168" class="idref" href="#r:168"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#r:168"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Rules.html#v:166"><span class="id" title="variable">v</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Rules.html#p:167"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:166"><span class="id" title="variable">v</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a>).<br/>
</div>

<div class="doc">
Remark: <span class="inlinecode"><span class="id" title="var">val_loc</span></span> is registered as a coercion, so <span class="inlinecode"><span class="id" title="var">val_get</span></span> <span class="inlinecode">(<span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">p</span>)</span>
    could be written simply as <span class="inlinecode"><span class="id" title="var">val_get</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>, where <span class="inlinecode"><span class="id" title="var">p</span></span> has type <span class="inlinecode"><span class="id" title="var">loc</span></span>.
    We here chose to write <span class="inlinecode"><span class="id" title="var">val_loc</span></span> explicitly for clarity. 
<div class="paragraph"> </div>

 Recall that <span class="inlinecode"><span class="id" title="var">val_set</span></span> denotes the operation for writing a memory cell.
    A call of the form <span class="inlinecode"><span class="id" title="var">val_set</span></span> <span class="inlinecode"><span class="id" title="var">v'</span></span> <span class="inlinecode"><span class="id" title="var">w</span></span> executes safely if <span class="inlinecode"><span class="id" title="var">v'</span></span> is of the
    form <span class="inlinecode"><span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> for some location <span class="inlinecode"><span class="id" title="var">p</span></span>, in a state <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">v</span></span>.
    The write operation updates this state to <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">w</span></span>, and returns
    the unit value, which can be ignored. Hence, <span class="inlinecode"><span class="id" title="var">val_set</span></span> is specified
    as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_set" class="idref" href="#triple_set"><span class="id" title="axiom">triple_set</span></a> : <span class="id" title="keyword">∀</span> <a id="w:170" class="idref" href="#w:170"><span class="id" title="binder">w</span></a> <a id="p:171" class="idref" href="#p:171"><span class="id" title="binder">p</span></a> <a id="v:172" class="idref" href="#v:172"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_set"><span class="id" title="constructor">val_set</span></a> (<a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:171"><span class="id" title="variable">p</span></a>) <a class="idref" href="Rules.html#w:170"><span class="id" title="variable">w</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Rules.html#p:171"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:172"><span class="id" title="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Rules.html#p:171"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#w:170"><span class="id" title="variable">w</span></a>).<br/>
</div>

<div class="doc">
Recall that <span class="inlinecode"><span class="id" title="var">val_ref</span></span> denotes the operation for allocating a cell
    with a given contents. A call to <span class="inlinecode"><span class="id" title="var">val_ref</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> does not depend on
    the contents of the existing state. It extends the state with a fresh
    singleton cell, at some location <span class="inlinecode"><span class="id" title="var">p</span></span>, assigning it <span class="inlinecode"><span class="id" title="var">v</span></span> as contents.
    The fresh cell is then described by the heap predicate <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">v</span></span>.
    The evaluation of <span class="inlinecode"><span class="id" title="var">val_ref</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> produces the value <span class="inlinecode"><span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>. Thus,
    if <span class="inlinecode"><span class="id" title="var">r</span></span> denotes the result value, we have <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> for some <span class="inlinecode"><span class="id" title="var">p</span></span>.
    In the corresponding specification shown below, observe how the
    location <span class="inlinecode"><span class="id" title="var">p</span></span> is existentially quantified in the postcondition. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_ref" class="idref" href="#triple_ref"><span class="id" title="axiom">triple_ref</span></a> : <span class="id" title="keyword">∀</span> <a id="v:174" class="idref" href="#v:174"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_ref"><span class="id" title="constructor">val_ref</span></a> <a class="idref" href="Rules.html#v:174"><span class="id" title="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> (<a id="r:175" class="idref" href="#r:175"><span class="id" title="binder">r</span></a>:<a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a>) ⇒ <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">(</span></a><a id="p:176" class="idref" href="#p:176"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">),</span></a> <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#r:175"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:176"><span class="id" title="variable">p</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Rules.html#p:176"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:174"><span class="id" title="variable">v</span></a>).<br/>
</div>

<div class="doc">
Using the notation <span class="inlinecode"><span class="id" title="var">funloc</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">H</span></span> as a shorthand for
    <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode">(<span class="id" title="var">r</span>:<span class="id" title="var">val</span>)</span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode">(<span class="id" title="var">p</span>:<span class="id" title="var">loc</span>),</span> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">p</span>]</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H</span></span>,
    the specification for <span class="inlinecode"><span class="id" title="var">val_ref</span></span> becomes more concise. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_ref'" class="idref" href="#triple_ref'"><span class="id" title="axiom">triple_ref'</span></a> : <span class="id" title="keyword">∀</span> <a id="v:178" class="idref" href="#v:178"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_ref"><span class="id" title="constructor">val_ref</span></a> <a class="idref" href="Rules.html#v:178"><span class="id" title="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="LibSepReference.html#d1e35cef49ddf53b46b670034b3362a<sub>0</sub>"><span class="id" title="notation">funloc</span></a> <a id="p:181" class="idref" href="#p:181"><span class="id" title="binder">p</span></a> <a class="idref" href="LibSepReference.html#d1e35cef49ddf53b46b670034b3362a<sub>0</sub>"><span class="id" title="notation">⇒</span></a> <a class="idref" href="Rules.html#p:179"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:178"><span class="id" title="variable">v</span></a>).<br/>
</div>

<div class="doc">
Recall that <span class="inlinecode"><span class="id" title="var">val_free</span></span> denotes the operation for deallocating a cell
    at a given address. A call of the form <span class="inlinecode"><span class="id" title="var">val_free</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> executes safely
    in a state <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">v</span></span>. The operation leaves an empty state, and
    asserts that the return value, named <span class="inlinecode"><span class="id" title="var">r</span></span>, is equal to unit. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_free" class="idref" href="#triple_free"><span class="id" title="axiom">triple_free</span></a> : <span class="id" title="keyword">∀</span> <a id="p:183" class="idref" href="#p:183"><span class="id" title="binder">p</span></a> <a id="v:184" class="idref" href="#v:184"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_free"><span class="id" title="constructor">val_free</span></a> (<a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:183"><span class="id" title="variable">p</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Rules.html#p:183"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:184"><span class="id" title="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a>).<br/>
</div>

<div class="doc">
<a id="lab175"></a><h2 class="section">Verification Proof in Separation Logic</h2>

<div class="paragraph"> </div>

 We have at hand all the necessary rules for carrying out actual
    verification proofs in Separation Logic. Let's do it! 
</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="ExamplePrograms" class="idref" href="#ExamplePrograms"><span class="id" title="module">ExamplePrograms</span></a>.<br/>
<span class="id" title="keyword">Export</span> <span class="id" title="var">ProgramSyntax</span>.<br/>
</div>

<div class="doc">
<a id="lab176"></a><h3 class="section">Proof of <span class="inlinecode"><span class="id" title="var">incr</span></span></h3>

<div class="paragraph"> </div>

 First, we consider the verification of the increment function,
    which is written in OCaml syntax as:

<div class="paragraph"> </div>

<span class="inlinecode-ocaml">&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">incr</span> <span class="id" title="var">p</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">p</span> := !<span class="id" title="var">p</span> + 1
</span>    Recall that, for simplicity, we assume programs to be written in
    "A-normal form", that is, with all intermediate expressions named
    by a let-binding. Thereafter, we thus consider the following
    definition for the <span class="inlinecode"><span class="id" title="var">incr</span></span>.

<div class="paragraph"> </div>

<span class="inlinecode-ocaml">&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">incr</span> <span class="id" title="var">p</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">n</span> = !<span class="id" title="var">p</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">m</span> = <span class="id" title="var">n</span>+1 <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">p</span> := <span class="id" title="var">m</span>
</span>    Using the construct from our toy programming language, the definition
    of <span class="inlinecode"><span class="id" title="var">incr</span></span> is written as shown below. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="ExamplePrograms.incr" class="idref" href="#ExamplePrograms.incr"><span class="id" title="definition">incr</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#val_fun"><span class="id" title="constructor">val_fun</span></a> "p" (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#trm_let"><span class="id" title="constructor">trm_let</span></a> "n" (<a class="idref" href="LibSepReference.html#trm_app"><span class="id" title="constructor">trm_app</span></a> <a class="idref" href="LibSepReference.html#val_get"><span class="id" title="constructor">val_get</span></a> (<a class="idref" href="LibSepReference.html#trm_var"><span class="id" title="constructor">trm_var</span></a> "p")) (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#trm_let"><span class="id" title="constructor">trm_let</span></a> "m" (<a class="idref" href="LibSepReference.html#trm_app"><span class="id" title="constructor">trm_app</span></a> (<a class="idref" href="LibSepReference.html#trm_app"><span class="id" title="constructor">trm_app</span></a> <a class="idref" href="LibSepReference.html#val_add"><span class="id" title="constructor">val_add</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="LibSepReference.html#trm_var"><span class="id" title="constructor">trm_var</span></a> "n")) (<a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> 1)) (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#trm_app"><span class="id" title="constructor">trm_app</span></a> (<a class="idref" href="LibSepReference.html#trm_app"><span class="id" title="constructor">trm_app</span></a> <a class="idref" href="LibSepReference.html#val_set"><span class="id" title="constructor">val_set</span></a> (<a class="idref" href="LibSepReference.html#trm_var"><span class="id" title="constructor">trm_var</span></a> "p")) (<a class="idref" href="LibSepReference.html#trm_var"><span class="id" title="constructor">trm_var</span></a> "m")))).<br/>
</div>

<div class="doc">
Alternatively, using notation and coercions, the same program can be
    written as shown below. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="ExamplePrograms.incr'" class="idref" href="#ExamplePrograms.incr'"><span class="id" title="definition">incr'</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> 1 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#e0633f114fcb17e965cb872e30ce07a<sub>5</sub>"><span class="id" title="notation">:=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
Let us check that the two definitions are indeed the same. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ExamplePrograms.incr_eq_incr'" class="idref" href="#ExamplePrograms.incr_eq_incr'"><span class="id" title="lemma">incr_eq_incr'</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#ExamplePrograms.incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Rules.html#ExamplePrograms.incr'"><span class="id" title="definition">incr'</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Recall from the first chapter the specification of the increment function.
    Its precondition requires a singleton state of the form <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>.
    Its postcondition describes a state of the form <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ExamplePrograms.triple_incr" class="idref" href="#ExamplePrograms.triple_incr"><span class="id" title="lemma">triple_incr</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:186" class="idref" href="#p:186"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:187" class="idref" href="#n:187"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_app"><span class="id" title="constructor">trm_app</span></a> <a class="idref" href="Rules.html#ExamplePrograms.incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="Rules.html#p:186"><span class="id" title="variable">p</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Rules.html#p:186"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#n:187"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Rules.html#p:186"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Rules.html#n:187"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
</div>

<div class="doc">
We next show a detailed proof for this specification. It exploits:

<div class="paragraph"> </div>

<ul class="doclist">
<li> the structural reasoning rules,

</li>
<li> the reasoning rules for terms,

</li>
<li> the specification of the primitive functions,

</li>
<li> the <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> tactic for simplifying entailments.

</li>
</ul>

</div>
<div class="code">

<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;initialize&nbsp;the&nbsp;proof&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#triple_app_fun"><span class="id" title="axiom">triple_app_fun</span></a>. { <span class="id" title="tactic">reflexivity</span>. } <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;reason&nbsp;about&nbsp;<span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">..</span>&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="Rules.html#triple_let"><span class="id" title="axiom">triple_let</span></a>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;reason&nbsp;about&nbsp;<span class="inlinecode">!<span class="id" title="var">p</span></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">apply</span> <a class="idref" href="Rules.html#triple_get"><span class="id" title="axiom">triple_get</span></a>. }<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;name&nbsp;<span class="inlinecode"><span class="id" title="var">n'</span></span>&nbsp;the&nbsp;result&nbsp;of&nbsp;<span class="inlinecode">!<span class="id" title="var">p</span></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n'</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;substitute&nbsp;away&nbsp;the&nbsp;equality&nbsp;<span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Rules.html#triple_hpure"><span class="id" title="axiom">triple_hpure</span></a>. <span class="id" title="tactic">intros</span> →.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;reason&nbsp;about&nbsp;<span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode">..</span>&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="Rules.html#triple_let"><span class="id" title="axiom">triple_let</span></a>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;apply&nbsp;the&nbsp;frame&nbsp;rule&nbsp;to&nbsp;put&nbsp;aside&nbsp;<span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#triple_conseq_frame"><span class="id" title="axiom">triple_conseq_frame</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;reason&nbsp;about&nbsp;<span class="inlinecode"><span class="id" title="var">n</span>+1</span>&nbsp;in&nbsp;the&nbsp;empty&nbsp;state&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#triple_add"><span class="id" title="axiom">triple_add</span></a>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">xsimpl</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">xsimpl</span>. } }<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;name&nbsp;<span class="inlinecode"><span class="id" title="var">m'</span></span>&nbsp;the&nbsp;result&nbsp;of&nbsp;<span class="inlinecode"><span class="id" title="var">n</span>+1</span>&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">m'</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;substitute&nbsp;away&nbsp;the&nbsp;equality&nbsp;<span class="inlinecode"><span class="id" title="var">m'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Rules.html#triple_hpure"><span class="id" title="axiom">triple_hpure</span></a>. <span class="id" title="tactic">intros</span> →.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;reason&nbsp;about&nbsp;<span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#triple_set"><span class="id" title="axiom">triple_set</span></a>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab177"></a><h3 class="section">Proof of <span class="inlinecode"><span class="id" title="var">succ_using_incr</span></span></h3>

<div class="paragraph"> </div>

 Recall from <span class="inlinecode"><span class="id" title="var">Basic</span></span> the function <span class="inlinecode"><span class="id" title="var">succ_using_incr</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="ExamplePrograms.succ_using_incr" class="idref" href="#ExamplePrograms.succ_using_incr"><span class="id" title="definition">succ_using_incr</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">r</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_ref"><span class="id" title="constructor">val_ref</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#ExamplePrograms.incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">r</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">x</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">r</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#val_free"><span class="id" title="constructor">val_free</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">r</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">x</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
Recall the specification of <span class="inlinecode"><span class="id" title="var">succ_using_incr</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ExamplePrograms.triple_succ_using_incr" class="idref" href="#ExamplePrograms.triple_succ_using_incr"><span class="id" title="lemma">triple_succ_using_incr</span></a> : <span class="id" title="keyword">∀</span> (<a id="n:188" class="idref" href="#n:188"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_app"><span class="id" title="constructor">trm_app</span></a> <a class="idref" href="Rules.html#ExamplePrograms.succ_using_incr"><span class="id" title="definition">succ_using_incr</span></a> <a class="idref" href="Rules.html#n:188"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="v:189" class="idref" href="#v:189"><span class="id" title="binder">v</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#v:189"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> (<a class="idref" href="Rules.html#n:188"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1)<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
</div>

<div class="doc">
<a id="lab178"></a><h4 class="section">Exercise: 4 stars, standard, especially useful (triple_succ_using_incr)</h4>
 Verify the function <span class="inlinecode"><span class="id" title="var">triple_succ_using_incr</span></span>.
    Hint: follow the pattern of <span class="inlinecode"><span class="id" title="var">triple_incr</span></span>.
    Hint: use <span class="inlinecode"><span class="id" title="var">applys</span></span> <span class="inlinecode"><span class="id" title="var">triple_seq</span></span> for reasoning about a sequence.
    Hint: use <span class="inlinecode"><span class="id" title="var">applys</span></span> <span class="inlinecode"><span class="id" title="var">triple_val</span></span> for reasoning about the final
    return value, namely <span class="inlinecode"><span class="id" title="var">x</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab179"></a><h3 class="section">Proof of <span class="inlinecode"><span class="id" title="var">factorec</span></span></h3>

</div>
<div class="code">

<span class="id" title="keyword">Import</span> <span class="id" title="var">Basic.Facto</span>.<br/>
</div>

<div class="doc">
Recall from <span class="inlinecode"><span class="id" title="var">Basic</span></span> the function <span class="inlinecode"><span class="id" title="var">repeat_incr</span></span>.

<div class="paragraph"> </div>

<span class="inlinecode-ocaml">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="keyword">rec</span> <span class="id" title="var">factorec</span> <span class="id" title="var">n</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">n</span> ≤ 1 <span class="id" title="keyword">then</span> 1 <span class="id" title="keyword">else</span> <span class="id" title="var">n</span> * <span class="id" title="var">factorec</span> (<span class="id" title="var">n</span>-1)
</span>
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="ExamplePrograms.factorec" class="idref" href="#ExamplePrograms.factorec"><span class="id" title="definition">factorec</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#7809db93a49fc4341c1251bb4de79a<sub>62</sub>"><span class="id" title="notation">fix</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">f</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#7809db93a49fc4341c1251bb4de79a<sub>62</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#2b10480be1a1611f7c8b850ecabd4776"><span class="id" title="notation">(</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#9ff281c3872a35aaa31aa0ff16f0b827"><span class="id" title="notation">≤</span></a> 1<a class="idref" href="LibSepReference.html#2b10480be1a1611f7c8b850ecabd4776"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'else'_x"><span class="id" title="notation">if</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'else'_x"><span class="id" title="notation">then</span></a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'else'_x"><span class="id" title="notation">else</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">x</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:x_'-'_x"><span class="id" title="notation">-</span></a> 1 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''y'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''y'"><span class="id" title="notation">y</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">f</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">x</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#8687bd0de562fa8820387e422eed2db<sub>3</sub>"><span class="id" title="notation">*</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''y'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''y'"><span class="id" title="notation">y</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
<a id="lab180"></a><h4 class="section">Exercise: 4 stars, standard, especially useful (triple_factorec)</h4>
 Verify the function <span class="inlinecode"><span class="id" title="var">factorec</span></span>.
    Hint: exploit <span class="inlinecode"><span class="id" title="var">triple_app_fix</span></span> for reasoning about the recursive function.
    Hint: <span class="inlinecode"><span class="id" title="var">triple_hpure'</span></span>, the corollary of <span class="inlinecode"><span class="id" title="var">triple_hpure</span></span>, is helpful.
    Hint: exploit <span class="inlinecode"><span class="id" title="var">triple_le</span></span> and <span class="inlinecode"><span class="id" title="var">triple_sub</span></span> and <span class="inlinecode"><span class="id" title="var">triple_mul</span></span> to reason about
    the behavior of the primitive operations involved.
    Hint: exploit <span class="inlinecode"><span class="id" title="var">applys</span></span> <span class="inlinecode"><span class="id" title="var">triple_if</span>.</span> <span class="inlinecode"><span class="id" title="var">case_if</span></span> <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode"><span class="id" title="var">C</span>.</span> to reason about the
    conditional; alternatively, if using <span class="inlinecode"><span class="id" title="var">triple_if_case</span></span>, you'll need to use
    the tactic <span class="inlinecode"><span class="id" title="var">rew_bool_eq</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode">*</span> to simplify, e.g., the expression
    <span class="inlinecode"><span class="id" title="var">isTrue</span></span> <span class="inlinecode">(<span class="id" title="var">m</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">1))</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ExamplePrograms.triple_factorec" class="idref" href="#ExamplePrograms.triple_factorec"><span class="id" title="lemma">triple_factorec</span></a> : <span class="id" title="keyword">∀</span> <a id="n:190" class="idref" href="#n:190"><span class="id" title="binder">n</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#n:190"><span class="id" title="variable">n</span></a> <span class="id" title="notation">≥</span> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Rules.html#ExamplePrograms.factorec"><span class="id" title="definition">factorec</span></a> <a class="idref" href="Rules.html#n:190"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:191" class="idref" href="#r:191"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#r:191"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#Facto.facto"><span class="id" title="axiom">facto</span></a> <a class="idref" href="Rules.html#n:190"><span class="id" title="variable">n</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="code">

<span class="id" title="keyword">End</span> <a class="idref" href="Rules.html#ExamplePrograms"><span class="id" title="module">ExamplePrograms</span></a>.<br/>
</div>

<div class="doc">
<a id="lab181"></a><h2 class="section">What's Next</h2>

<div class="paragraph"> </div>

 The matter of the next chapter is to introduce additional
    technology to streamline the proof process, notably by:

<div class="paragraph"> </div>

<ul class="doclist">
<li> automating the application of the frame rule

</li>
<li> eliminating the need to manipulate program variables
      and substitutions during the verification proof. 
</li>
</ul>

<div class="paragraph"> </div>

 The rest of this chapter is concerned with alternative statements
    for the reasoning rules, and with the proofs of the reasoning rules. 
</div>

<div class="doc">
<a id="lab182"></a><h1 class="section">More Details</h1>

</div>

<div class="doc">
<a id="lab183"></a><h2 class="section">Alternative Specification Style for Pure Preconditions</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="DivSpec" class="idref" href="#DivSpec"><span class="id" title="module">DivSpec</span></a>.<br/>
</div>

<div class="doc">
Recall the specification for division. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="DivSpec.triple_div" class="idref" href="#DivSpec.triple_div"><span class="id" title="axiom">triple_div</span></a> : <span class="id" title="keyword">∀</span> <a id="n<sub>1</sub>:192" class="idref" href="#n<sub>1</sub>:192"><span class="id" title="binder">n<sub>1</sub></span></a> <a id="n<sub>2</sub>:193" class="idref" href="#n<sub>2</sub>:193"><span class="id" title="binder">n<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#n<sub>2</sub>:193"><span class="id" title="variable">n<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;&gt;'_x"><span class="id" title="notation">≠</span></a> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_div"><span class="id" title="constructor">val_div</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:192"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:193"><span class="id" title="variable">n<sub>2</sub></span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:194" class="idref" href="#r:194"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#r:194"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#Z.quot"><span class="id" title="definition">Z.quot</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:192"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:193"><span class="id" title="variable">n<sub>2</sub></span></a>)<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
</div>

<div class="doc">
Equivalently, we could place the requirement <span class="inlinecode"><span class="id" title="var">n<sub>2</sub></span></span> <span class="inlinecode">≠</span> <span class="inlinecode">0</span> in the
    precondition: 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="DivSpec.triple_div'" class="idref" href="#DivSpec.triple_div'"><span class="id" title="axiom">triple_div'</span></a> : <span class="id" title="keyword">∀</span> <a id="n<sub>1</sub>:196" class="idref" href="#n<sub>1</sub>:196"><span class="id" title="binder">n<sub>1</sub></span></a> <a id="n<sub>2</sub>:197" class="idref" href="#n<sub>2</sub>:197"><span class="id" title="binder">n<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_div"><span class="id" title="constructor">val_div</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:196"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:197"><span class="id" title="variable">n<sub>2</sub></span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#n<sub>2</sub>:197"><span class="id" title="variable">n<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;&gt;'_x"><span class="id" title="notation">≠</span></a> 0<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:198" class="idref" href="#r:198"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#r:198"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#Z.quot"><span class="id" title="definition">Z.quot</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:196"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:197"><span class="id" title="variable">n<sub>2</sub></span></a>)<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
</div>

<div class="doc">
Let us formally prove that the two presentations are equivalent.
    Frist, we prove <span class="inlinecode"><span class="id" title="var">triple_div'</span></span> by exploiting <span class="inlinecode"><span class="id" title="var">triple_div</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="DivSpec.triple_div'_from_triple_div" class="idref" href="#DivSpec.triple_div'_from_triple_div"><span class="id" title="lemma">triple_div'_from_triple_div</span></a> : <span class="id" title="keyword">∀</span> <a id="n<sub>1</sub>:200" class="idref" href="#n<sub>1</sub>:200"><span class="id" title="binder">n<sub>1</sub></span></a> <a id="n<sub>2</sub>:201" class="idref" href="#n<sub>2</sub>:201"><span class="id" title="binder">n<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_div"><span class="id" title="constructor">val_div</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:200"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:201"><span class="id" title="variable">n<sub>2</sub></span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#n<sub>2</sub>:201"><span class="id" title="variable">n<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;&gt;'_x"><span class="id" title="notation">≠</span></a> 0<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:202" class="idref" href="#r:202"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#r:202"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#Z.quot"><span class="id" title="definition">Z.quot</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:200"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:201"><span class="id" title="variable">n<sub>2</sub></span></a>)<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#triple_hpure'"><span class="id" title="axiom">triple_hpure'</span></a>. <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#DivSpec.triple_div"><span class="id" title="axiom">triple_div</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab184"></a><h4 class="section">Exercise: 1 star, standard, especially useful (triple_div_from_triple_div')</h4>
 Prove <span class="inlinecode"><span class="id" title="var">triple_div</span></span> by exploiting <span class="inlinecode"><span class="id" title="var">triple_div'</span></span>.
    Hint: the key proof step is <span class="inlinecode"><span class="id" title="var">applys</span></span> <span class="inlinecode"><span class="id" title="var">triple_conseq</span></span> 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="DivSpec.triple_div_from_triple_div'" class="idref" href="#DivSpec.triple_div_from_triple_div'"><span class="id" title="lemma">triple_div_from_triple_div'</span></a> : <span class="id" title="keyword">∀</span> <a id="n<sub>1</sub>:203" class="idref" href="#n<sub>1</sub>:203"><span class="id" title="binder">n<sub>1</sub></span></a> <a id="n<sub>2</sub>:204" class="idref" href="#n<sub>2</sub>:204"><span class="id" title="binder">n<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#n<sub>2</sub>:204"><span class="id" title="variable">n<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;&gt;'_x"><span class="id" title="notation">≠</span></a> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_div"><span class="id" title="constructor">val_div</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:203"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:204"><span class="id" title="variable">n<sub>2</sub></span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:205" class="idref" href="#r:205"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#r:205"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#Z.quot"><span class="id" title="definition">Z.quot</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:203"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:204"><span class="id" title="variable">n<sub>2</sub></span></a>)<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 As we said, placing pure preconditions outside of the triples
    makes it slightly more convenient to exploit specifications.
    For this reason, we adopt the style that precondition only
    contain the description of heap-allocated data structures. 
</div>
<div class="code">

<span class="id" title="keyword">End</span> <a class="idref" href="Rules.html#DivSpec"><span class="id" title="module">DivSpec</span></a>.<br/>
</div>

<div class="doc">
<a id="lab185"></a><h2 class="section">The Combined Let-Frame Rule</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="LetFrame" class="idref" href="#LetFrame"><span class="id" title="module">LetFrame</span></a>.<br/>
</div>

<div class="doc">
Recall the Separation Logic let rule. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="LetFrame.triple_let" class="idref" href="#LetFrame.triple_let"><span class="id" title="axiom">triple_let</span></a> : <span class="id" title="keyword">∀</span> <a id="x:206" class="idref" href="#x:206"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:207" class="idref" href="#t<sub>1</sub>:207"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:208" class="idref" href="#t<sub>2</sub>:208"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="Q<sub>1</sub>:209" class="idref" href="#Q<sub>1</sub>:209"><span class="id" title="binder">Q<sub>1</sub></span></a> <a id="H:210" class="idref" href="#H:210"><span class="id" title="binder">H</span></a> <a id="Q:211" class="idref" href="#Q:211"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:207"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#H:210"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q<sub>1</sub>:209"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="v<sub>1</sub>:212" class="idref" href="#v<sub>1</sub>:212"><span class="id" title="binder">v<sub>1</sub></span></a>, <a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#subst"><span class="id" title="definition">subst</span></a> <a class="idref" href="Rules.html#x:206"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:212"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:208"><span class="id" title="variable">t<sub>2</sub></span></a>) (<a class="idref" href="Rules.html#Q<sub>1</sub>:209"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:212"><span class="id" title="variable">v<sub>1</sub></span></a>) <a class="idref" href="Rules.html#Q:211"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_let"><span class="id" title="constructor">trm_let</span></a> <a class="idref" href="Rules.html#x:206"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:207"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:208"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#H:210"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:211"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
At first sight, it seems that, to reason about <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>
    in a state described by precondition <span class="inlinecode"><span class="id" title="var">H</span></span>, we need to first reason
    about <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> in that same state. Yet, <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> may well require only a
    subset of the state <span class="inlinecode"><span class="id" title="var">H</span></span> to evaluate, and not all of <span class="inlinecode"><span class="id" title="var">H</span></span>.

<div class="paragraph"> </div>

    The "let-frame" rule combines the rule for let-bindings with the
    frame rule to make it more explicit that the precondition <span class="inlinecode"><span class="id" title="var">H</span></span>
    may be decomposed in the form <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span>, where <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> is the part
    needed by <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>, and <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> denotes the rest of the state. The part
    of the state covered by <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> remains unmodified during the evaluation
    of <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>, and appears as part of the precondition of <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>.

<div class="paragraph"> </div>

    The corresponding statement is as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="LetFrame.triple_let_frame" class="idref" href="#LetFrame.triple_let_frame"><span class="id" title="lemma">triple_let_frame</span></a> : <span class="id" title="keyword">∀</span> <a id="x:214" class="idref" href="#x:214"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:215" class="idref" href="#t<sub>1</sub>:215"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:216" class="idref" href="#t<sub>2</sub>:216"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="Q<sub>1</sub>:217" class="idref" href="#Q<sub>1</sub>:217"><span class="id" title="binder">Q<sub>1</sub></span></a> <a id="H:218" class="idref" href="#H:218"><span class="id" title="binder">H</span></a> <a id="H<sub>1</sub>:219" class="idref" href="#H<sub>1</sub>:219"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:220" class="idref" href="#H<sub>2</sub>:220"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="Q:221" class="idref" href="#Q:221"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:215"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#H<sub>1</sub>:219"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Rules.html#Q<sub>1</sub>:217"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#H:218"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Rules.html#H<sub>1</sub>:219"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Rules.html#H<sub>2</sub>:220"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="v<sub>1</sub>:222" class="idref" href="#v<sub>1</sub>:222"><span class="id" title="binder">v<sub>1</sub></span></a>, <a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#subst"><span class="id" title="definition">subst</span></a> <a class="idref" href="Rules.html#x:214"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:222"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:216"><span class="id" title="variable">t<sub>2</sub></span></a>) (<a class="idref" href="Rules.html#Q<sub>1</sub>:217"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:222"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Rules.html#H<sub>2</sub>:220"><span class="id" title="variable">H<sub>2</sub></span></a>) <a class="idref" href="Rules.html#Q:221"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_let"><span class="id" title="constructor">trm_let</span></a> <a class="idref" href="Rules.html#x:214"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:215"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:216"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#H:218"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:221"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
<a id="lab186"></a><h4 class="section">Exercise: 3 stars, standard, especially useful (triple_let_frame)</h4>
 Prove the let-frame rule. 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="code">

<span class="id" title="keyword">End</span> <a class="idref" href="Rules.html#LetFrame"><span class="id" title="module">LetFrame</span></a>.<br/>
</div>

<div class="doc">
<a id="lab187"></a><h2 class="section">Proofs for the Rules for Terms</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="Proofs" class="idref" href="#Proofs"><span class="id" title="module">Proofs</span></a>.<br/>
</div>

<div class="doc">
The proofs for the Separation Logic reasoning rules all follow
    a similar pattern: first establish a corresponding rule for
    Hoare triples, then generalize it to a Separation Logic triple.

<div class="paragraph"> </div>

    To establish a reasoning rule w.r.t. a Hoare triple, we reveal
    the definition expressed in terms of the big-step semantics.
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">hoare</span> (<span class="id" title="var">t</span>:<span class="id" title="var">trm</span>) (<span class="id" title="var">H</span>:<span class="id" title="var">hprop</span>) (<span class="id" title="var">Q</span>:<span class="id" title="var">val</span>→<span class="id" title="var">hprop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">s</span>, <span class="id" title="var">H</span> <span class="id" title="var">s</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">s'</span> <span class="id" title="var">v</span>, <span class="id" title="tactic">eval</span> <span class="id" title="var">s</span> <span class="id" title="var">t</span> <span class="id" title="var">s'</span> <span class="id" title="var">v</span> ∧ <span class="id" title="var">Q</span> <span class="id" title="var">v</span> <span class="id" title="var">s'</span>.
</span>    Concretely, we consider a given initial state <span class="inlinecode"><span class="id" title="var">s</span></span> satisfying the
    precondition, and we have to provide witnesses for the output
    value <span class="inlinecode"><span class="id" title="var">v</span></span> and output state <span class="inlinecode"><span class="id" title="var">s'</span></span> such that the reduction holds and
    the postcondition holds.

<div class="paragraph"> </div>

    Then, to lift the reasoning rule from Hoare logic to Separation
    Logic, we reveal the definition of a Separation Logic triple.
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">triple</span> <span class="id" title="var">t</span> <span class="id" title="var">H</span> <span class="id" title="var">Q</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">H'</span>, <span class="id" title="var">hoare</span> <span class="id" title="var">t</span> (<span class="id" title="var">H</span> <span class='gray-font'>\</span>* <span class="id" title="var">H'</span>) (<span class="id" title="var">Q</span> <span class='gray-font'>\</span>*+ <span class="id" title="var">H'</span>).
</span>    Recall that we already employed this two-step scheme in the
    previous chapter, e.g., to establish the consequence rule
    (<span class="inlinecode"><span class="id" title="var">rule_conseq</span></span>). 
</div>

<div class="doc">
<a id="lab188"></a><h3 class="section">Proof of <span class="inlinecode"><span class="id" title="var">triple_val</span></span></h3>

<div class="paragraph"> </div>

 The big-step evaluation rule for values asserts that a value <span class="inlinecode"><span class="id" title="var">v</span></span>
    evaluates to itself, without modification to the current state <span class="inlinecode"><span class="id" title="var">s</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="Proofs.eval_val" class="idref" href="#Proofs.eval_val"><span class="id" title="axiom">eval_val</span></a> : <span class="id" title="keyword">∀</span> <a id="s:223" class="idref" href="#s:223"><span class="id" title="binder">s</span></a> <a id="v:224" class="idref" href="#v:224"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:223"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#v:224"><span class="id" title="variable">v</span></a> <a class="idref" href="Rules.html#s:223"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#v:224"><span class="id" title="variable">v</span></a>.<br/>
</div>

<div class="doc">
The Hoare version of the reasoning rule for values is as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="Proofs.hoare_val" class="idref" href="#Proofs.hoare_val"><span class="id" title="lemma">hoare_val</span></a> : <span class="id" title="keyword">∀</span> <a id="v:226" class="idref" href="#v:226"><span class="id" title="binder">v</span></a> <a id="H:227" class="idref" href="#H:227"><span class="id" title="binder">H</span></a> <a id="Q:228" class="idref" href="#Q:228"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#H:227"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Rules.html#Q:228"><span class="id" title="variable">Q</span></a> <a class="idref" href="Rules.html#v:226"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> (<a class="idref" href="LibSepReference.html#trm_val"><span class="id" title="constructor">trm_val</span></a> <a class="idref" href="Rules.html#v:226"><span class="id" title="variable">v</span></a>) <a class="idref" href="Rules.html#H:227"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:228"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
</div>

<div class="doc">
1. We unfold the definition of <span class="inlinecode"><span class="id" title="var">hoare</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">s</span> <span class="id" title="var">K<sub>0</sub></span>.<br/>
</div>

<div class="doc">
2. We provide the witnesses for the output value and heap.
        These witnesses are dictated by the statement of <span class="inlinecode"><span class="id" title="var">eval_val</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">s</span> <span class="id" title="var">v</span>. <span class="id" title="var">splits</span>.<br/>
</div>

<div class="doc">
3. We invoke the big-step rule <span class="inlinecode"><span class="id" title="var">eval_val</span></span> 
</div>
<div class="code">
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#Proofs.eval_val"><span class="id" title="axiom">eval_val</span></a>. }<br/>
</div>

<div class="doc">
4. We establish the postcondition, exploiting the entailment hypothesis. 
</div>
<div class="code">
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">auto</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The Separation Logic version of the rule then follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="Proofs.triple_val" class="idref" href="#Proofs.triple_val"><span class="id" title="lemma">triple_val</span></a> : <span class="id" title="keyword">∀</span> <a id="v:229" class="idref" href="#v:229"><span class="id" title="binder">v</span></a> <a id="H:230" class="idref" href="#H:230"><span class="id" title="binder">H</span></a> <a id="Q:231" class="idref" href="#Q:231"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#H:230"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Rules.html#Q:231"><span class="id" title="variable">Q</span></a> <a class="idref" href="Rules.html#v:229"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_val"><span class="id" title="constructor">trm_val</span></a> <a class="idref" href="Rules.html#v:229"><span class="id" title="variable">v</span></a>) <a class="idref" href="Rules.html#H:230"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:231"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
</div>

<div class="doc">
1. We unfold the definition of <span class="inlinecode"><span class="id" title="var">triple</span></span> to reveal a <span class="inlinecode"><span class="id" title="var">hoare</span></span> judgment. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>.<br/>
</div>

<div class="doc">
2. We invoke the reasoning rule <span class="inlinecode"><span class="id" title="var">hoare_val</span></span> that was just established. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="Rules.html#Proofs.hoare_val"><span class="id" title="lemma">hoare_val</span></a>.<br/>
</div>

<div class="doc">
3. We exploit the assumption and conclude using <span class="inlinecode"><span class="id" title="var">xchange</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">xchange</span> <span class="id" title="var">M</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab189"></a><h3 class="section">Proof of <span class="inlinecode"><span class="id" title="var">triple_seq</span></span></h3>

<div class="paragraph"> </div>

 The big-step evaluation rule for a sequence is given next. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="Proofs.eval_seq" class="idref" href="#Proofs.eval_seq"><span class="id" title="axiom">eval_seq</span></a> : <span class="id" title="keyword">∀</span> <a id="s<sub>1</sub>:232" class="idref" href="#s<sub>1</sub>:232"><span class="id" title="binder">s<sub>1</sub></span></a> <a id="s<sub>2</sub>:233" class="idref" href="#s<sub>2</sub>:233"><span class="id" title="binder">s<sub>2</sub></span></a> <a id="s<sub>3</sub>:234" class="idref" href="#s<sub>3</sub>:234"><span class="id" title="binder">s<sub>3</sub></span></a> <a id="t<sub>1</sub>:235" class="idref" href="#t<sub>1</sub>:235"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:236" class="idref" href="#t<sub>2</sub>:236"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="v<sub>1</sub>:237" class="idref" href="#v<sub>1</sub>:237"><span class="id" title="binder">v<sub>1</sub></span></a> <a id="v:238" class="idref" href="#v:238"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:232"><span class="id" title="variable">s<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:235"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#s<sub>2</sub>:233"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:237"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>2</sub>:233"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:236"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="Rules.html#s<sub>3</sub>:234"><span class="id" title="variable">s<sub>3</sub></span></a> <a class="idref" href="Rules.html#v:238"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:232"><span class="id" title="variable">s<sub>1</sub></span></a> (<a class="idref" href="LibSepReference.html#trm_seq"><span class="id" title="constructor">trm_seq</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:235"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:236"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#s<sub>3</sub>:234"><span class="id" title="variable">s<sub>3</sub></span></a> <a class="idref" href="Rules.html#v:238"><span class="id" title="variable">v</span></a>.<br/>
</div>

<div class="doc">
The Hoare triple version of the reasoning rule is proved as follows.
    This lemma, called <span class="inlinecode"><span class="id" title="var">hoare_seq</span></span>, has the same statement as <span class="inlinecode"><span class="id" title="var">triple_seq</span></span>,
    except with occurrences of <span class="inlinecode"><span class="id" title="var">triple</span></span> replaced with <span class="inlinecode"><span class="id" title="var">hoare</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="Proofs.hoare_seq" class="idref" href="#Proofs.hoare_seq"><span class="id" title="lemma">hoare_seq</span></a> : <span class="id" title="keyword">∀</span> <a id="t<sub>1</sub>:240" class="idref" href="#t<sub>1</sub>:240"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:241" class="idref" href="#t<sub>2</sub>:241"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="H:242" class="idref" href="#H:242"><span class="id" title="binder">H</span></a> <a id="Q:243" class="idref" href="#Q:243"><span class="id" title="binder">Q</span></a> <a id="H<sub>1</sub>:244" class="idref" href="#H<sub>1</sub>:244"><span class="id" title="binder">H<sub>1</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:240"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#H:242"><span class="id" title="variable">H</span></a> (<span class="id" title="keyword">fun</span> <a id="v:245" class="idref" href="#v:245"><span class="id" title="binder">v</span></a> ⇒ <a class="idref" href="Rules.html#H<sub>1</sub>:244"><span class="id" title="variable">H<sub>1</sub></span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:241"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="Rules.html#H<sub>1</sub>:244"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Rules.html#Q:243"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> (<a class="idref" href="LibSepReference.html#trm_seq"><span class="id" title="constructor">trm_seq</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:240"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:241"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#H:242"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:243"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
</div>

<div class="doc">
1. We unfold the definition of <span class="inlinecode"><span class="id" title="var">hoare</span></span>.
  Let <span class="inlinecode"><span class="id" title="var">K<sub>0</sub></span></span> describe the initial state. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">M<sub>1</sub></span> <span class="id" title="var">M<sub>2</sub></span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">s</span> <span class="id" title="var">K<sub>0</sub></span>. <span class="comment">(*&nbsp;optional:&nbsp;*)</span> <span class="id" title="var">unfolds</span> <a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a>.<br/>
</div>

<div class="doc">
2. We exploit the first hypothesis to obtain information about
       the evaluation of the first subterm <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>.
       The state before <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> executes is described by <span class="inlinecode"><span class="id" title="var">K<sub>0</sub></span></span>.
       The state after <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> executes is described by <span class="inlinecode"><span class="id" title="var">K<sub>1</sub></span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">forwards</span> (<span class="id" title="var">s<sub>1</sub>'</span>&amp;<span class="id" title="var">v<sub>1</sub></span>&amp;<span class="id" title="var">R<sub>1</sub></span>&amp;<span class="id" title="var">K<sub>1</sub></span>): (<span class="id" title="definition">rm</span> <span class="id" title="var">M<sub>1</sub></span>) <span class="id" title="var">K<sub>0</sub></span>.<br/>
</div>

<div class="doc">
3. We exploit the second hypothesis to obtain information about
       the evaluation of the first subterm <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>.
       The state before <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> executes is described by <span class="inlinecode"><span class="id" title="var">K<sub>1</sub></span></span>.
       The state after <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> executes is described by <span class="inlinecode"><span class="id" title="var">K<sub>2</sub></span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">forwards</span> (<span class="id" title="var">s<sub>2</sub>'</span>&amp;<span class="id" title="var">v<sub>2</sub></span>&amp;<span class="id" title="var">R<sub>2</sub></span>&amp;<span class="id" title="var">K<sub>2</sub></span>): (<span class="id" title="definition">rm</span> <span class="id" title="var">M<sub>2</sub></span>) <span class="id" title="var">K<sub>1</sub></span>.<br/>
</div>

<div class="doc">
4. We provide witness for the output value and heap.
       They correspond to those produced by the evaluation of <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">s<sub>2</sub>'</span> <span class="id" title="var">v<sub>2</sub></span>. <span class="id" title="tactic">split</span>.<br/>
</div>

<div class="doc">
5. We invoke the big-step rule. 
</div>
<div class="code">
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#Proofs.eval_seq"><span class="id" title="axiom">eval_seq</span></a> <span class="id" title="var">R<sub>1</sub></span> <span class="id" title="var">R<sub>2</sub></span>. }<br/>
</div>

<div class="doc">
6. We establish the final postcondition, which is directly
          inherited from the reasoning on <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;{ <span class="id" title="tactic">apply</span> <span class="id" title="var">K<sub>2</sub></span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The Separation Logic reasoning rule is proved as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="Proofs.triple_seq" class="idref" href="#Proofs.triple_seq"><span class="id" title="lemma">triple_seq</span></a> : <span class="id" title="keyword">∀</span> <a id="t<sub>1</sub>:246" class="idref" href="#t<sub>1</sub>:246"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:247" class="idref" href="#t<sub>2</sub>:247"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="H:248" class="idref" href="#H:248"><span class="id" title="binder">H</span></a> <a id="Q:249" class="idref" href="#Q:249"><span class="id" title="binder">Q</span></a> <a id="H<sub>1</sub>:250" class="idref" href="#H<sub>1</sub>:250"><span class="id" title="binder">H<sub>1</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:246"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#H:248"><span class="id" title="variable">H</span></a> (<span class="id" title="keyword">fun</span> <a id="v:251" class="idref" href="#v:251"><span class="id" title="binder">v</span></a> ⇒ <a class="idref" href="Rules.html#H<sub>1</sub>:250"><span class="id" title="variable">H<sub>1</sub></span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:247"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="Rules.html#H<sub>1</sub>:250"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Rules.html#Q:249"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_seq"><span class="id" title="constructor">trm_seq</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:246"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:247"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#H:248"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:249"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
</div>

<div class="doc">
1. We unfold the definition of <span class="inlinecode"><span class="id" title="var">triple</span></span> to reveal a <span class="inlinecode"><span class="id" title="var">hoare</span></span> judgment. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">M<sub>1</sub></span> <span class="id" title="var">M<sub>2</sub></span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>. <span class="comment">(*&nbsp;optional:&nbsp;*)</span> <span class="id" title="var">unfolds</span> <a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a>.<br/>
</div>

<div class="doc">
2. We invoke the reasoning rule <span class="inlinecode"><span class="id" title="var">hoare_seq</span></span> that we just established. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="Rules.html#Proofs.hoare_seq"><span class="id" title="lemma">hoare_seq</span></a>.<br/>
</div>

<div class="doc">
3. For the hypothesis on the first subterm <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>,
       we can invoke directly our first hypothesis. 
</div>
<div class="code">
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <span class="id" title="var">M<sub>1</sub></span>. }<br/>
</div>

<div class="doc">
4. Likewise, we invoke an induction hypothesis for <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <span class="id" title="var">M<sub>2</sub></span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab190"></a><h3 class="section">Proof of <span class="inlinecode"><span class="id" title="var">triple_let</span></span></h3>

<div class="paragraph"> </div>

 Recall the big-step evaluation rule for a let-binding. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="Proofs.eval_let" class="idref" href="#Proofs.eval_let"><span class="id" title="axiom">eval_let</span></a> : <span class="id" title="keyword">∀</span> <a id="s<sub>1</sub>:252" class="idref" href="#s<sub>1</sub>:252"><span class="id" title="binder">s<sub>1</sub></span></a> <a id="s<sub>2</sub>:253" class="idref" href="#s<sub>2</sub>:253"><span class="id" title="binder">s<sub>2</sub></span></a> <a id="s<sub>3</sub>:254" class="idref" href="#s<sub>3</sub>:254"><span class="id" title="binder">s<sub>3</sub></span></a> <a id="x:255" class="idref" href="#x:255"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:256" class="idref" href="#t<sub>1</sub>:256"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:257" class="idref" href="#t<sub>2</sub>:257"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="v<sub>1</sub>:258" class="idref" href="#v<sub>1</sub>:258"><span class="id" title="binder">v<sub>1</sub></span></a> <a id="v:259" class="idref" href="#v:259"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:252"><span class="id" title="variable">s<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:256"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#s<sub>2</sub>:253"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:258"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>2</sub>:253"><span class="id" title="variable">s<sub>2</sub></span></a> (<a class="idref" href="LibSepReference.html#subst"><span class="id" title="definition">subst</span></a> <a class="idref" href="Rules.html#x:255"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:258"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:257"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#s<sub>3</sub>:254"><span class="id" title="variable">s<sub>3</sub></span></a> <a class="idref" href="Rules.html#v:259"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:252"><span class="id" title="variable">s<sub>1</sub></span></a> (<a class="idref" href="LibSepReference.html#trm_let"><span class="id" title="constructor">trm_let</span></a> <a class="idref" href="Rules.html#x:255"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:256"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:257"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#s<sub>3</sub>:254"><span class="id" title="variable">s<sub>3</sub></span></a> <a class="idref" href="Rules.html#v:259"><span class="id" title="variable">v</span></a>.<br/>
</div>

<div class="doc">
<a id="lab191"></a><h4 class="section">Exercise: 3 stars, standard, especially useful (triple_let)</h4>
 Following the same proof scheme as for <span class="inlinecode"><span class="id" title="var">triple_seq</span></span>, establish
    the reasoning rule for <span class="inlinecode"><span class="id" title="var">triple_let</span></span>, whose statement appears
    earlier in this file. Make sure to first state and prove the
    lemma <span class="inlinecode"><span class="id" title="var">hoare_let</span></span>, which has the same statement as <span class="inlinecode"><span class="id" title="var">triple_let</span></span>
    yet with occurrences of <span class="inlinecode"><span class="id" title="var">triple</span></span> replaced with <span class="inlinecode"><span class="id" title="var">hoare</span></span>. 
</div>
<div class="code">

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab192"></a><h2 class="section">Proofs for the Arithmetic Primitive Operations</h2>

</div>

<div class="doc">
<a id="lab193"></a><h3 class="section">Addition</h3>

<div class="paragraph"> </div>

 Recall the evaluation rule for addition. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="Proofs.eval_add" class="idref" href="#Proofs.eval_add"><span class="id" title="axiom">eval_add</span></a> : <span class="id" title="keyword">∀</span> <a id="s:261" class="idref" href="#s:261"><span class="id" title="binder">s</span></a> <a id="n<sub>1</sub>:262" class="idref" href="#n<sub>1</sub>:262"><span class="id" title="binder">n<sub>1</sub></span></a> <a id="n<sub>2</sub>:263" class="idref" href="#n<sub>2</sub>:263"><span class="id" title="binder">n<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:261"><span class="id" title="variable">s</span></a> (<a class="idref" href="LibSepReference.html#val_add"><span class="id" title="constructor">val_add</span></a> (<a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:262"><span class="id" title="variable">n<sub>1</sub></span></a>) (<a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:263"><span class="id" title="variable">n<sub>2</sub></span></a>)) <a class="idref" href="Rules.html#s:261"><span class="id" title="variable">s</span></a> (<a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> (<a class="idref" href="Rules.html#n<sub>1</sub>:262"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:263"><span class="id" title="variable">n<sub>2</sub></span></a>)).<br/>
</div>

<div class="doc">
In the proof, we will need to use the following result,
    established in the first chapter. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="Proofs.hstar_hpure_l" class="idref" href="#Proofs.hstar_hpure_l"><span class="id" title="axiom">hstar_hpure_l</span></a> : <span class="id" title="keyword">∀</span> <a id="P:265" class="idref" href="#P:265"><span class="id" title="binder">P</span></a> <a id="H:266" class="idref" href="#H:266"><span class="id" title="binder">H</span></a> <a id="h:267" class="idref" href="#h:267"><span class="id" title="binder">h</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#P:265"><span class="id" title="variable">P</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Rules.html#H:266"><span class="id" title="variable">H</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><a class="idref" href="Rules.html#P:265"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="Rules.html#H:266"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#h:267"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
As usual, we first establish a Hoare triple. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="Proofs.hoare_add" class="idref" href="#Proofs.hoare_add"><span class="id" title="lemma">hoare_add</span></a> : <span class="id" title="keyword">∀</span> <a id="H:269" class="idref" href="#H:269"><span class="id" title="binder">H</span></a> <a id="n<sub>1</sub>:270" class="idref" href="#n<sub>1</sub>:270"><span class="id" title="binder">n<sub>1</sub></span></a> <a id="n<sub>2</sub>:271" class="idref" href="#n<sub>2</sub>:271"><span class="id" title="binder">n<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> (<a class="idref" href="LibSepReference.html#val_add"><span class="id" title="constructor">val_add</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:270"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:271"><span class="id" title="variable">n<sub>2</sub></span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#H:269"><span class="id" title="variable">H</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:272" class="idref" href="#r:272"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#r:272"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> (<a class="idref" href="Rules.html#n<sub>1</sub>:270"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:271"><span class="id" title="variable">n<sub>2</sub></span></a>)<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Rules.html#H:269"><span class="id" title="variable">H</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">s</span> <span class="id" title="var">K<sub>0</sub></span>. <span class="id" title="tactic">∃</span> <span class="id" title="var">s</span> (<a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> (<span class="id" title="var">n<sub>1</sub></span> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> <span class="id" title="var">n<sub>2</sub></span>)). <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#Proofs.eval_add"><span class="id" title="axiom">eval_add</span></a>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">rewrite</span> <a class="idref" href="Rules.html#Proofs.hstar_hpure_l"><span class="id" title="axiom">hstar_hpure_l</span></a>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">auto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <span class="id" title="var">K<sub>0</sub></span>. } }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Deriving <span class="inlinecode"><span class="id" title="var">triple_add</span></span> is then straightforward. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="Proofs.triple_add" class="idref" href="#Proofs.triple_add"><span class="id" title="lemma">triple_add</span></a> : <span class="id" title="keyword">∀</span> <a id="n<sub>1</sub>:273" class="idref" href="#n<sub>1</sub>:273"><span class="id" title="binder">n<sub>1</sub></span></a> <a id="n<sub>2</sub>:274" class="idref" href="#n<sub>2</sub>:274"><span class="id" title="binder">n<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_add"><span class="id" title="constructor">val_add</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:273"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:274"><span class="id" title="variable">n<sub>2</sub></span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:275" class="idref" href="#r:275"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#r:275"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> (<a class="idref" href="Rules.html#n<sub>1</sub>:273"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:274"><span class="id" title="variable">n<sub>2</sub></span></a>)<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#hoare_conseq"><span class="id" title="lemma">hoare_conseq</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#Proofs.hoare_add"><span class="id" title="lemma">hoare_add</span></a>. } { <span class="id" title="var">xsimpl</span>. } { <span class="id" title="var">xsimpl</span>. <span class="id" title="tactic">auto</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab194"></a><h3 class="section">Division</h3>

<div class="paragraph"> </div>

 Recall the evaluation rule for division. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="Proofs.eval_div'" class="idref" href="#Proofs.eval_div'"><span class="id" title="axiom">eval_div'</span></a> : <span class="id" title="keyword">∀</span> <a id="s:276" class="idref" href="#s:276"><span class="id" title="binder">s</span></a> <a id="n<sub>1</sub>:277" class="idref" href="#n<sub>1</sub>:277"><span class="id" title="binder">n<sub>1</sub></span></a> <a id="n<sub>2</sub>:278" class="idref" href="#n<sub>2</sub>:278"><span class="id" title="binder">n<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#n<sub>2</sub>:278"><span class="id" title="variable">n<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;&gt;'_x"><span class="id" title="notation">≠</span></a> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:276"><span class="id" title="variable">s</span></a> (<a class="idref" href="LibSepReference.html#val_div"><span class="id" title="constructor">val_div</span></a> (<a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:277"><span class="id" title="variable">n<sub>1</sub></span></a>) (<a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:278"><span class="id" title="variable">n<sub>2</sub></span></a>)) <a class="idref" href="Rules.html#s:276"><span class="id" title="variable">s</span></a> (<a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#Z.quot"><span class="id" title="definition">Z.quot</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:277"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:278"><span class="id" title="variable">n<sub>2</sub></span></a>)).<br/>
</div>

<div class="doc">
<a id="lab195"></a><h4 class="section">Exercise: 3 stars, standard, optional (triple_div)</h4>
 Following the same proof scheme as for <span class="inlinecode"><span class="id" title="var">triple_add</span></span>, establish
    the reasoning rule for <span class="inlinecode"><span class="id" title="var">triple_div</span></span>. Make sure to first state
    and prove <span class="inlinecode"><span class="id" title="var">hoare_div</span></span>, which is similar to <span class="inlinecode"><span class="id" title="var">triple_div</span></span>, except with
    <span class="inlinecode"><span class="id" title="var">hoare</span></span> instead of <span class="inlinecode"><span class="id" title="var">triple</span></span>, and with a precondition named <span class="inlinecode"><span class="id" title="var">H</span></span> for
    describing the input state. 
</div>
<div class="code">

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab196"></a><h2 class="section">Proofs for Primitive Operations Operating on the State</h2>

<div class="paragraph"> </div>

 The proofs for establishing the Separation Logic reasoning rules
    for <span class="inlinecode"><span class="id" title="var">ref</span></span>, <span class="inlinecode"><span class="id" title="var">get</span></span> and <span class="inlinecode"><span class="id" title="tactic">set</span></span> follow a similar proof pattern,
    that is, they go through the proofs of rules for Hoare triples.

<div class="paragraph"> </div>

    Unlike before, however, the Hoare triples are not directly
    established with respect to the big-step evaluation rules.
    Instead, we start by proving corollaries to the big-step rules
    to reformulate them in a way that give already them a flavor
    of "Separation Logic". Concretely, we reformulate the evaluation
    rules, which are expressed in terms of read and updates in finite
    maps, to be expressed instead entirely in terms of disjoint unions.

<div class="paragraph"> </div>

    The introduction of these disjoint union operations then
    significantly eases the justification of the separating
    conjunctions that appear in the targeted Separation Logic
    triples.

<div class="paragraph"> </div>

    In this section, the constructor <span class="inlinecode"><span class="id" title="var">hval_val</span></span> appears. This
    constructor converts a "value" into a "heap value". For the
    purpose, of this file, the two notion are identical. Yet,
    to allow for generalization to the semantics of allocation by
    blocks, we need to assume that states are finite maps from
    location to heap values. Heap values, of type <span class="inlinecode"><span class="id" title="var">hval</span></span>, can be
    assumed to be defined by the following inductive data type.
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <span class="id" title="var">hval</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">hval_val</span> : <span class="id" title="var">val</span> → <span class="id" title="var">hval</span>.
</span>
</div>

<div class="doc">
<a id="lab197"></a><h3 class="section">Read in a Reference</h3>

<div class="paragraph"> </div>

 The big-step rule for <span class="inlinecode"><span class="id" title="var">get</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> requires that <span class="inlinecode"><span class="id" title="var">p</span></span> be in the
    domain of the current state <span class="inlinecode"><span class="id" title="var">s</span></span>, and asserts that the output
    value is the result of reading in <span class="inlinecode"><span class="id" title="var">s</span></span> at location <span class="inlinecode"><span class="id" title="var">p</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="Proofs.eval_get" class="idref" href="#Proofs.eval_get"><span class="id" title="axiom">eval_get</span></a> : <span class="id" title="keyword">∀</span> <a id="v:280" class="idref" href="#v:280"><span class="id" title="binder">v</span></a> <a id="s:281" class="idref" href="#s:281"><span class="id" title="binder">s</span></a> <a id="p:282" class="idref" href="#p:282"><span class="id" title="binder">p</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.indom"><span class="id" title="definition">Fmap.indom</span></a> <a class="idref" href="Rules.html#s:281"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#p:282"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.read"><span class="id" title="definition">Fmap.read</span></a> <a class="idref" href="Rules.html#s:281"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#p:282"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Rules.html#v:280"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:281"><span class="id" title="variable">s</span></a> (<a class="idref" href="LibSepReference.html#val_get"><span class="id" title="constructor">val_get</span></a> (<a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:282"><span class="id" title="variable">p</span></a>)) <a class="idref" href="Rules.html#s:281"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#v:280"><span class="id" title="variable">v</span></a>.<br/>
</div>

<div class="doc">
We reformulate this rule by isolating from the current state <span class="inlinecode"><span class="id" title="var">s</span></span>
    the singleton heap made of the cell at location <span class="inlinecode"><span class="id" title="var">p</span></span>, and let <span class="inlinecode"><span class="id" title="var">s<sub>2</sub></span></span>
    denote the rest of the heap. When the singleton heap is described
    as <span class="inlinecode"><span class="id" title="var">Fmap.single</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span>, then <span class="inlinecode"><span class="id" title="var">v</span></span> is the result value returned by
    <span class="inlinecode"><span class="id" title="var">get</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="Proofs.eval_get_sep" class="idref" href="#Proofs.eval_get_sep"><span class="id" title="lemma">eval_get_sep</span></a> : <span class="id" title="keyword">∀</span> <a id="s:284" class="idref" href="#s:284"><span class="id" title="binder">s</span></a> <a id="s<sub>2</sub>:285" class="idref" href="#s<sub>2</sub>:285"><span class="id" title="binder">s<sub>2</sub></span></a> <a id="p:286" class="idref" href="#p:286"><span class="id" title="binder">p</span></a> <a id="v:287" class="idref" href="#v:287"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#s:284"><span class="id" title="variable">s</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#Fmap.union"><span class="id" title="definition">Fmap.union</span></a> (<a class="idref" href="LibSepReference.html#Fmap.single"><span class="id" title="definition">Fmap.single</span></a> <a class="idref" href="Rules.html#p:286"><span class="id" title="variable">p</span></a> <a class="idref" href="Rules.html#v:287"><span class="id" title="variable">v</span></a>) <a class="idref" href="Rules.html#s<sub>2</sub>:285"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:284"><span class="id" title="variable">s</span></a> (<a class="idref" href="LibSepReference.html#val_get"><span class="id" title="constructor">val_get</span></a> (<a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:286"><span class="id" title="variable">p</span></a>)) <a class="idref" href="Rules.html#s:284"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#v:287"><span class="id" title="variable">v</span></a>.<br/>
</div>

<div class="doc">
The proof of this lemma is of little interest. We show it only to
    demonstrate that it relies only a few basic facts related to finite
    maps. 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> →. <span class="id" title="var">forwards</span> <span class="id" title="var">Dv</span>: <a class="idref" href="LibSepReference.html#Fmap.indom_single"><span class="id" title="lemma">Fmap.indom_single</span></a> <span class="id" title="var">p</span> <span class="id" title="var">v</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="Rules.html#Proofs.eval_get"><span class="id" title="axiom">eval_get</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span>* <a class="idref" href="LibSepReference.html#Fmap.indom_union_l"><span class="id" title="lemma">Fmap.indom_union_l</span></a>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">rewrite</span>* <a class="idref" href="LibSepReference.html#Fmap.read_union_l"><span class="id" title="lemma">Fmap.read_union_l</span></a>. <span class="id" title="tactic">rewrite</span>* <a class="idref" href="LibSepReference.html#Fmap.read_single"><span class="id" title="lemma">Fmap.read_single</span></a>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Our goal is to establish the triple:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">triple</span> (<span class="id" title="var">val_get</span> <span class="id" title="var">p</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">p</span> ~~&gt; <span class="id" title="var">v</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">r</span> ⇒ <span class='gray-font'>\</span>[<span class="id" title="var">r</span> = <span class="id" title="var">v</span>] <span class='gray-font'>\</span>* (<span class="id" title="var">p</span> ~~&gt; <span class="id" title="var">v</span>)).
</span>    Establishing this lemma requires us to reason about propositions
    of the form <span class="inlinecode">(<span class='gray-font'>\</span>[<span class="id" title="var">P</span>]</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H</span>)</span> <span class="inlinecode"><span class="id" title="var">h</span></span> and <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">v</span>)</span> <span class="inlinecode"><span class="id" title="var">h</span></span>. To that end,
    recall lemma <span class="inlinecode"><span class="id" title="var">hstar_hpure_l</span></span>, which was already exploited in the
    proof of <span class="inlinecode"><span class="id" title="var">triple_add</span></span>, and recall <span class="inlinecode"><span class="id" title="var">hsingle_inv</span></span> from <span class="inlinecode"><span class="id" title="var">Hprop</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="Proofs.hsingle_inv" class="idref" href="#Proofs.hsingle_inv"><span class="id" title="axiom">hsingle_inv</span></a>: <span class="id" title="keyword">∀</span> <a id="p:288" class="idref" href="#p:288"><span class="id" title="binder">p</span></a> <a id="v:289" class="idref" href="#v:289"><span class="id" title="binder">v</span></a> <a id="h:290" class="idref" href="#h:290"><span class="id" title="binder">h</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Rules.html#p:288"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:289"><span class="id" title="variable">v</span></a><a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#h:290"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#Fmap.single"><span class="id" title="definition">Fmap.single</span></a> <a class="idref" href="Rules.html#p:288"><span class="id" title="variable">p</span></a> <a class="idref" href="Rules.html#v:289"><span class="id" title="variable">v</span></a>.<br/>
</div>

<div class="doc">
We establish the specification of <span class="inlinecode"><span class="id" title="var">get</span></span> first w.r.t. to
    the <span class="inlinecode"><span class="id" title="var">hoare</span></span> judgment. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="Proofs.hoare_get" class="idref" href="#Proofs.hoare_get"><span class="id" title="lemma">hoare_get</span></a> : <span class="id" title="keyword">∀</span> <a id="H:292" class="idref" href="#H:292"><span class="id" title="binder">H</span></a> <a id="v:293" class="idref" href="#v:293"><span class="id" title="binder">v</span></a> <a id="p:294" class="idref" href="#p:294"><span class="id" title="binder">p</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> (<a class="idref" href="LibSepReference.html#val_get"><span class="id" title="constructor">val_get</span></a> <a class="idref" href="Rules.html#p:294"><span class="id" title="variable">p</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Rules.html#p:294"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:293"><span class="id" title="variable">v</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Rules.html#H:292"><span class="id" title="variable">H</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:295" class="idref" href="#r:295"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#r:295"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Rules.html#v:293"><span class="id" title="variable">v</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Rules.html#p:294"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:293"><span class="id" title="variable">v</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Rules.html#H:292"><span class="id" title="variable">H</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;1.&nbsp;We&nbsp;unfold&nbsp;the&nbsp;definition&nbsp;of&nbsp;<span class="inlinecode"><span class="id" title="var">hoare</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">s</span> <span class="id" title="var">K<sub>0</sub></span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;2.&nbsp;We&nbsp;provide&nbsp;the&nbsp;witnesses&nbsp;for&nbsp;the&nbsp;reduction,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;dictated&nbsp;by&nbsp;<span class="inlinecode"><span class="id" title="var">eval_get_sep</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">s</span> <span class="id" title="var">v</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;{ <span class="comment">(*&nbsp;3.&nbsp;To&nbsp;justify&nbsp;the&nbsp;reduction&nbsp;using&nbsp;<span class="inlinecode"><span class="id" title="var">eval_get_sep</span></span>,&nbsp;we&nbsp;need&nbsp;to<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argue&nbsp;that&nbsp;the&nbsp;state&nbsp;<span class="inlinecode"><span class="id" title="var">s</span></span>&nbsp;decomposes&nbsp;as&nbsp;a&nbsp;singleton&nbsp;heap<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="inlinecode"><span class="id" title="var">Fmap.single</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span>&nbsp;and&nbsp;the&nbsp;rest&nbsp;of&nbsp;the&nbsp;state&nbsp;<span class="inlinecode"><span class="id" title="var">s<sub>2</sub></span></span>.&nbsp;This&nbsp;is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obtained&nbsp;by&nbsp;eliminating&nbsp;the&nbsp;star&nbsp;in&nbsp;hypothesis&nbsp;<span class="inlinecode"><span class="id" title="var">K<sub>0</sub></span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">K<sub>0</sub></span> <span class="id" title="keyword">as</span> (<span class="id" title="var">s<sub>1</sub></span>&amp;<span class="id" title="var">s<sub>2</sub></span>&amp;<span class="id" title="var">P<sub>1</sub></span>&amp;<span class="id" title="var">P<sub>2</sub></span>&amp;<span class="id" title="var">D</span>&amp;<span class="id" title="var">U</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;4.&nbsp;Inverting&nbsp;<span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">v</span>)</span> <span class="inlinecode"><span class="id" title="var">h<sub>1</sub></span></span>&nbsp;simplifies&nbsp;the&nbsp;goal.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lets</span> <span class="id" title="var">E<sub>1</sub></span>: <a class="idref" href="Rules.html#Proofs.hsingle_inv"><span class="id" title="axiom">hsingle_inv</span></a> <span class="id" title="var">P<sub>1</sub></span>. <span class="id" title="tactic">subst</span> <span class="id" title="var">s<sub>1</sub></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;5.&nbsp;At&nbsp;this&nbsp;point,&nbsp;the&nbsp;goal&nbsp;matches&nbsp;exactly&nbsp;<span class="inlinecode"><span class="id" title="var">eval_get_sep</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="Rules.html#Proofs.eval_get_sep"><span class="id" title="lemma">eval_get_sep</span></a> <span class="id" title="var">U</span>. }<br/>
&nbsp;&nbsp;{ <span class="comment">(*&nbsp;6.&nbsp;To&nbsp;establish&nbsp;the&nbsp;postcondition,&nbsp;we&nbsp;check&nbsp;the&nbsp;pure&nbsp;fact<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">v</span></span>,&nbsp;and&nbsp;check&nbsp;that&nbsp;the&nbsp;state,&nbsp;which&nbsp;has&nbsp;not&nbsp;changed,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;satisfies&nbsp;the&nbsp;same&nbsp;heap&nbsp;predicate&nbsp;as&nbsp;in&nbsp;the&nbsp;precondition.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Rules.html#Proofs.hstar_hpure_l"><span class="id" title="axiom">hstar_hpure_l</span></a>. <span class="id" title="tactic">auto</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Deriving the Separation Logic triple follows the usual pattern. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="Proofs.triple_get" class="idref" href="#Proofs.triple_get"><span class="id" title="lemma">triple_get</span></a> : <span class="id" title="keyword">∀</span> <a id="v:296" class="idref" href="#v:296"><span class="id" title="binder">v</span></a> <a id="p:297" class="idref" href="#p:297"><span class="id" title="binder">p</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_get"><span class="id" title="constructor">val_get</span></a> <a class="idref" href="Rules.html#p:297"><span class="id" title="variable">p</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Rules.html#p:297"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:296"><span class="id" title="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:298" class="idref" href="#r:298"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#r:298"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Rules.html#v:296"><span class="id" title="variable">v</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Rules.html#p:297"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:296"><span class="id" title="variable">v</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#hoare_conseq"><span class="id" title="lemma">hoare_conseq</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#Proofs.hoare_get"><span class="id" title="lemma">hoare_get</span></a>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xsimpl</span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xsimpl</span>. <span class="id" title="tactic">auto</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab198"></a><h3 class="section">Allocation of a Reference</h3>

<div class="paragraph"> </div>

 Next, we consider the reasoning rule for operation <span class="inlinecode"><span class="id" title="var">ref</span></span>, which
    involves a proof yet slightly more trickier than that for
    <span class="inlinecode"><span class="id" title="var">get</span></span> and <span class="inlinecode"><span class="id" title="tactic">set</span></span>. 
<div class="paragraph"> </div>

 The big-step evaluation rule for <span class="inlinecode"><span class="id" title="var">ref</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> extends the initial
    state <span class="inlinecode"><span class="id" title="var">s</span></span> with an extra binding from <span class="inlinecode"><span class="id" title="var">p</span></span> to <span class="inlinecode"><span class="id" title="var">v</span></span>, for some
    fresh location <span class="inlinecode"><span class="id" title="var">p</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="Proofs.eval_ref" class="idref" href="#Proofs.eval_ref"><span class="id" title="axiom">eval_ref</span></a> : <span class="id" title="keyword">∀</span> <a id="s:299" class="idref" href="#s:299"><span class="id" title="binder">s</span></a> <a id="v:300" class="idref" href="#v:300"><span class="id" title="binder">v</span></a> <a id="p:301" class="idref" href="#p:301"><span class="id" title="binder">p</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">¬</span></a> <a class="idref" href="LibSepReference.html#Fmap.indom"><span class="id" title="definition">Fmap.indom</span></a> <a class="idref" href="Rules.html#s:299"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#p:301"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:299"><span class="id" title="variable">s</span></a> (<a class="idref" href="LibSepReference.html#val_ref"><span class="id" title="constructor">val_ref</span></a> <a class="idref" href="Rules.html#v:300"><span class="id" title="variable">v</span></a>) (<a class="idref" href="LibSepReference.html#Fmap.update"><span class="id" title="definition">Fmap.update</span></a> <a class="idref" href="Rules.html#s:299"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#p:301"><span class="id" title="variable">p</span></a> <a class="idref" href="Rules.html#v:300"><span class="id" title="variable">v</span></a>) (<a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:301"><span class="id" title="variable">p</span></a>).<br/>
</div>

<div class="doc">
Let us reformulate <span class="inlinecode"><span class="id" title="var">eval_ref</span></span> to replace references to <span class="inlinecode"><span class="id" title="var">Fmap.indom</span></span>
    and <span class="inlinecode"><span class="id" title="var">Fmap.update</span></span> with references to <span class="inlinecode"><span class="id" title="var">Fmap.single</span></span> and <span class="inlinecode"><span class="id" title="var">Fmap.disjoint</span></span>.
    Concretely, <span class="inlinecode"><span class="id" title="var">ref</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> extends the state from <span class="inlinecode"><span class="id" title="var">s<sub>1</sub></span></span> to <span class="inlinecode"><span class="id" title="var">s<sub>1</sub></span></span> <span class="inlinecode">\<span class="id" title="var">u</span></span> <span class="inlinecode"><span class="id" title="var">s<sub>2</sub></span></span>,
    where <span class="inlinecode"><span class="id" title="var">s<sub>2</sub></span></span> denotes the singleton heap <span class="inlinecode"><span class="id" title="var">Fmap.single</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span>, and with
    the requirement that <span class="inlinecode"><span class="id" title="var">Fmap.disjoint</span></span> <span class="inlinecode"><span class="id" title="var">s<sub>2</sub></span></span> <span class="inlinecode"><span class="id" title="var">s<sub>1</sub></span></span>, to capture freshness. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="Proofs.eval_ref_sep" class="idref" href="#Proofs.eval_ref_sep"><span class="id" title="lemma">eval_ref_sep</span></a> : <span class="id" title="keyword">∀</span> <a id="s<sub>1</sub>:303" class="idref" href="#s<sub>1</sub>:303"><span class="id" title="binder">s<sub>1</sub></span></a> <a id="s<sub>2</sub>:304" class="idref" href="#s<sub>2</sub>:304"><span class="id" title="binder">s<sub>2</sub></span></a> <a id="v:305" class="idref" href="#v:305"><span class="id" title="binder">v</span></a> <a id="p:306" class="idref" href="#p:306"><span class="id" title="binder">p</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#s<sub>2</sub>:304"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#Fmap.single"><span class="id" title="definition">Fmap.single</span></a> <a class="idref" href="Rules.html#p:306"><span class="id" title="variable">p</span></a> <a class="idref" href="Rules.html#v:305"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.disjoint"><span class="id" title="definition">Fmap.disjoint</span></a> <a class="idref" href="Rules.html#s<sub>2</sub>:304"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:303"><span class="id" title="variable">s<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:303"><span class="id" title="variable">s<sub>1</sub></span></a> (<a class="idref" href="LibSepReference.html#val_ref"><span class="id" title="constructor">val_ref</span></a> <a class="idref" href="Rules.html#v:305"><span class="id" title="variable">v</span></a>) (<a class="idref" href="LibSepReference.html#Fmap.union"><span class="id" title="definition">Fmap.union</span></a> <a class="idref" href="Rules.html#s<sub>2</sub>:304"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:303"><span class="id" title="variable">s<sub>1</sub></span></a>) (<a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:306"><span class="id" title="variable">p</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
</div>

<div class="doc">
It is not needed to follow through this proof. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">introv</span> → <span class="id" title="var">D</span>. <span class="id" title="var">forwards</span> <span class="id" title="var">Dv</span>: <a class="idref" href="LibSepReference.html#Fmap.indom_single"><span class="id" title="lemma">Fmap.indom_single</span></a> <span class="id" title="var">p</span> <span class="id" title="var">v</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="LibSepReference.html#Fmap.update_eq_union_single"><span class="id" title="lemma">Fmap.update_eq_union_single</span></a>. <span class="id" title="var">applys</span>* <a class="idref" href="Rules.html#Proofs.eval_ref"><span class="id" title="axiom">eval_ref</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">N</span>. <span class="id" title="var">applys</span>* <a class="idref" href="LibSepReference.html#Fmap.disjoint_inv_not_indom_both"><span class="id" title="lemma">Fmap.disjoint_inv_not_indom_both</span></a> <span class="id" title="var">D</span> <span class="id" title="var">N</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
In order to apply the rules <span class="inlinecode"><span class="id" title="var">eval_ref</span></span> or <span class="inlinecode"><span class="id" title="var">eval_ref_sep</span></span>, we need
    to be able to synthetize fresh locations. The following lemma
    (from <span class="inlinecode"><span class="id" title="var">LibSepFmap.v</span></span>) captures the existence, for any state <span class="inlinecode"><span class="id" title="var">s</span></span>, of
    a (non-null) location <span class="inlinecode"><span class="id" title="var">p</span></span> not already bound in <span class="inlinecode"><span class="id" title="var">s</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="Proofs.exists_fresh" class="idref" href="#Proofs.exists_fresh"><span class="id" title="axiom">exists_fresh</span></a> : <span class="id" title="keyword">∀</span> <a id="s:307" class="idref" href="#s:307"><span class="id" title="binder">s</span></a>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="notation">∃</span> <a id="p:308" class="idref" href="#p:308"><span class="id" title="binder">p</span></a><span class="id" title="notation">,</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">¬</span></a> <a class="idref" href="LibSepReference.html#Fmap.indom"><span class="id" title="definition">Fmap.indom</span></a> <a class="idref" href="Rules.html#s:307"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#p:308"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="Rules.html#p:308"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;&gt;'_x"><span class="id" title="notation">≠</span></a> <a class="idref" href="LibSepReference.html#null"><span class="id" title="definition">null</span></a>.<br/>
</div>

<div class="doc">
We reformulate the lemma above in a way that better matches
    the premise of the lemma <span class="inlinecode"><span class="id" title="var">eval_ref_sep</span></span>, which we need to apply
    for establishing the specification of <span class="inlinecode"><span class="id" title="var">ref</span></span>.

<div class="paragraph"> </div>

    This reformulation, shown below, asserts that, for any <span class="inlinecode"><span class="id" title="var">h</span></span>,
    there existence a non-null location <span class="inlinecode"><span class="id" title="var">p</span></span> such that the singleton
    heap <span class="inlinecode"><span class="id" title="var">Fmap.single</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> is disjoint from <span class="inlinecode"><span class="id" title="var">h</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="Proofs.single_fresh" class="idref" href="#Proofs.single_fresh"><span class="id" title="lemma">single_fresh</span></a> : <span class="id" title="keyword">∀</span> <a id="h:310" class="idref" href="#h:310"><span class="id" title="binder">h</span></a> <a id="v:311" class="idref" href="#v:311"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<span class="id" title="notation">∃</span> <a id="p:312" class="idref" href="#p:312"><span class="id" title="binder">p</span></a><span class="id" title="notation">,</span> <a class="idref" href="LibSepReference.html#Fmap.disjoint"><span class="id" title="definition">Fmap.disjoint</span></a> (<a class="idref" href="LibSepReference.html#Fmap.single"><span class="id" title="definition">Fmap.single</span></a> <a class="idref" href="Rules.html#p:312"><span class="id" title="variable">p</span></a> <a class="idref" href="Rules.html#v:311"><span class="id" title="variable">v</span></a>) <a class="idref" href="Rules.html#h:310"><span class="id" title="variable">h</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
</div>

<div class="doc">
It is not needed to follow through this proof. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">forwards</span> (<span class="id" title="var">p</span>&amp;<span class="id" title="var">F</span>&amp;<span class="id" title="var">N</span>): <a class="idref" href="Rules.html#Proofs.exists_fresh"><span class="id" title="axiom">exists_fresh</span></a> <span class="id" title="var">h</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">p</span>. <span class="id" title="var">applys</span>* <a class="idref" href="LibSepReference.html#Fmap.disjoint_single_of_not_indom"><span class="id" title="lemma">Fmap.disjoint_single_of_not_indom</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The proof of the Hoare triple for <span class="inlinecode"><span class="id" title="var">ref</span></span> is as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="Proofs.hoare_ref" class="idref" href="#Proofs.hoare_ref"><span class="id" title="lemma">hoare_ref</span></a> : <span class="id" title="keyword">∀</span> <a id="H:313" class="idref" href="#H:313"><span class="id" title="binder">H</span></a> <a id="v:314" class="idref" href="#v:314"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> (<a class="idref" href="LibSepReference.html#val_ref"><span class="id" title="constructor">val_ref</span></a> <a class="idref" href="Rules.html#v:314"><span class="id" title="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Rules.html#H:313"><span class="id" title="variable">H</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:315" class="idref" href="#r:315"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="p:316" class="idref" href="#p:316"><span class="id" title="binder">p</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#r:315"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:316"><span class="id" title="variable">p</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Rules.html#p:316"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:314"><span class="id" title="variable">v</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Rules.html#H:313"><span class="id" title="variable">H</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;1.&nbsp;We&nbsp;unfold&nbsp;the&nbsp;definition&nbsp;of&nbsp;<span class="inlinecode"><span class="id" title="var">hoare</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">K<sub>0</sub></span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;2.&nbsp;We&nbsp;claim&nbsp;the&nbsp;disjointness&nbsp;relation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="inlinecode"><span class="id" title="var">Fmap.disjoint</span></span> <span class="inlinecode">(<span class="id" title="var">Fmap.single</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">v</span>)</span> <span class="inlinecode"><span class="id" title="var">s<sub>1</sub></span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="var">forwards</span>* (<span class="id" title="var">p</span>&amp;<span class="id" title="var">D</span>): (<a class="idref" href="Rules.html#Proofs.single_fresh"><span class="id" title="lemma">single_fresh</span></a> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">v</span>).<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;3.&nbsp;We&nbsp;provide&nbsp;the&nbsp;witnesses&nbsp;for&nbsp;the&nbsp;reduction,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;dictated&nbsp;by&nbsp;<span class="inlinecode"><span class="id" title="var">eval_ref_sep</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> (<a class="idref" href="LibSepReference.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="LibSepReference.html#Fmap.single"><span class="id" title="definition">Fmap.single</span></a> <span class="id" title="var">p</span> <span class="id" title="var">v</span><a class="idref" href="LibSepReference.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">u</span></a> <span class="id" title="var">s<sub>1</sub></span>) (<a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <span class="id" title="var">p</span>). <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;{ <span class="comment">(*&nbsp;4.&nbsp;We&nbsp;exploit&nbsp;<span class="inlinecode"><span class="id" title="var">eval_ref_sep</span></span>,&nbsp;which&nbsp;has&nbsp;exactly&nbsp;the&nbsp;desired&nbsp;shape!&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="Rules.html#Proofs.eval_ref_sep"><span class="id" title="lemma">eval_ref_sep</span></a> <span class="id" title="var">D</span>. <span class="id" title="tactic">auto</span>. }<br/>
&nbsp;&nbsp;{ <span class="comment">(*&nbsp;5.&nbsp;We&nbsp;establish&nbsp;the&nbsp;postcondition<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="inlinecode">(<span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">p</span>,</span> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">p</span>]</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">v</span>)</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by&nbsp;providing&nbsp;<span class="inlinecode"><span class="id" title="var">p</span></span>&nbsp;and&nbsp;the&nbsp;relevant&nbsp;pieces&nbsp;of&nbsp;heap.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.hstar_intro"><span class="id" title="lemma">hstar_intro</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">∃</span> <span class="id" title="var">p</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="Rules.html#Proofs.hstar_hpure_l"><span class="id" title="axiom">hstar_hpure_l</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>. { <span class="id" title="tactic">auto</span>. } { <span class="id" title="var">applys</span>¬<a class="idref" href="LibSepReference.html#SepSimplArgs.hsingle_intro"><span class="id" title="lemma">hsingle_intro</span></a>. } }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <span class="id" title="var">K<sub>0</sub></span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <span class="id" title="var">D</span>. } }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
We then derive the Separation Logic triple as usual. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="Proofs.triple_ref" class="idref" href="#Proofs.triple_ref"><span class="id" title="lemma">triple_ref</span></a> : <span class="id" title="keyword">∀</span> <a id="v:317" class="idref" href="#v:317"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_ref"><span class="id" title="constructor">val_ref</span></a> <a class="idref" href="Rules.html#v:317"><span class="id" title="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="LibSepReference.html#d1e35cef49ddf53b46b670034b3362a<sub>0</sub>"><span class="id" title="notation">funloc</span></a> <a id="p:320" class="idref" href="#p:320"><span class="id" title="binder">p</span></a> <a class="idref" href="LibSepReference.html#d1e35cef49ddf53b46b670034b3362a<sub>0</sub>"><span class="id" title="notation">⇒</span></a> <a class="idref" href="Rules.html#p:318"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:317"><span class="id" title="variable">v</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#hoare_conseq"><span class="id" title="lemma">hoare_conseq</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#Proofs.hoare_ref"><span class="id" title="lemma">hoare_ref</span></a>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xsimpl</span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xsimpl</span>. <span class="id" title="tactic">auto</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Rules.html#Proofs"><span class="id" title="module">Proofs</span></a>.<br/>
</div>

<div class="doc">
<a id="lab199"></a><h1 class="section">Optional Material</h1>

</div>

<div class="doc">
<a id="lab200"></a><h2 class="section">Reasoning Rules for Recursive Functions</h2>

<div class="paragraph"> </div>

 This reasoning rules for functions immediately generalizes
    to recursive functions. A term describing a recursive
    function is written <span class="inlinecode"><span class="id" title="var">trm_fix</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>, and the corresponding
    value is written <span class="inlinecode"><span class="id" title="var">val_fix</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_fix" class="idref" href="#triple_fix"><span class="id" title="axiom">triple_fix</span></a> : <span class="id" title="keyword">∀</span> <a id="f:321" class="idref" href="#f:321"><span class="id" title="binder">f</span></a> <a id="x:322" class="idref" href="#x:322"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:323" class="idref" href="#t<sub>1</sub>:323"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="H:324" class="idref" href="#H:324"><span class="id" title="binder">H</span></a> <a id="Q:325" class="idref" href="#Q:325"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#H:324"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Rules.html#Q:325"><span class="id" title="variable">Q</span></a> (<a class="idref" href="LibSepReference.html#val_fix"><span class="id" title="constructor">val_fix</span></a> <a class="idref" href="Rules.html#f:321"><span class="id" title="variable">f</span></a> <a class="idref" href="Rules.html#x:322"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:323"><span class="id" title="variable">t<sub>1</sub></span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_fix"><span class="id" title="constructor">trm_fix</span></a> <a class="idref" href="Rules.html#f:321"><span class="id" title="variable">f</span></a> <a class="idref" href="Rules.html#x:322"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:323"><span class="id" title="variable">t<sub>1</sub></span></a>) <a class="idref" href="Rules.html#H:324"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:325"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
The reasoning rule that corresponds to beta-reduction for
    a recursive function involves two substitutions: a first
    substitution for recursive occurrences of the function,
    followed with a second substitution for the argument
    provided to the call. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_app_fix" class="idref" href="#triple_app_fix"><span class="id" title="axiom">triple_app_fix</span></a> : <span class="id" title="keyword">∀</span> <a id="v<sub>1</sub>:327" class="idref" href="#v<sub>1</sub>:327"><span class="id" title="binder">v<sub>1</sub></span></a> <a id="v<sub>2</sub>:328" class="idref" href="#v<sub>2</sub>:328"><span class="id" title="binder">v<sub>2</sub></span></a> <a id="f:329" class="idref" href="#f:329"><span class="id" title="binder">f</span></a> <a id="x:330" class="idref" href="#x:330"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:331" class="idref" href="#t<sub>1</sub>:331"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="H:332" class="idref" href="#H:332"><span class="id" title="binder">H</span></a> <a id="Q:333" class="idref" href="#Q:333"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#v<sub>1</sub>:327"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_fix"><span class="id" title="constructor">val_fix</span></a> <a class="idref" href="Rules.html#f:329"><span class="id" title="variable">f</span></a> <a class="idref" href="Rules.html#x:330"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:331"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#subst"><span class="id" title="definition">subst</span></a> <a class="idref" href="Rules.html#x:330"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#v<sub>2</sub>:328"><span class="id" title="variable">v<sub>2</sub></span></a> (<a class="idref" href="LibSepReference.html#subst"><span class="id" title="definition">subst</span></a> <a class="idref" href="Rules.html#f:329"><span class="id" title="variable">f</span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:327"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:331"><span class="id" title="variable">t<sub>1</sub></span></a>)) <a class="idref" href="Rules.html#H:332"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:333"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_app"><span class="id" title="constructor">trm_app</span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:327"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Rules.html#v<sub>2</sub>:328"><span class="id" title="variable">v<sub>2</sub></span></a>) <a class="idref" href="Rules.html#H:332"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:333"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
<a id="lab201"></a><h3 class="section">Other Proofs of Reasoning Rules for Terms</h3>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="ProofsContinued" class="idref" href="#ProofsContinued"><span class="id" title="module">ProofsContinued</span></a>.<br/>
</div>

<div class="doc">
<a id="lab202"></a><h3 class="section">Proof of <span class="inlinecode"><span class="id" title="var">triple_fun</span></span> and <span class="inlinecode"><span class="id" title="var">triple_fix</span></span></h3>

<div class="paragraph"> </div>

 The proofs for <span class="inlinecode"><span class="id" title="var">triple_fun</span></span> and <span class="inlinecode"><span class="id" title="var">triple_fix</span></span> are essentially
    identical to that of <span class="inlinecode"><span class="id" title="var">triple_val</span></span>, so we do not include them
    here. 
</div>

<div class="doc">
<a id="lab203"></a><h3 class="section">Proof of <span class="inlinecode"><span class="id" title="var">triple_if</span></span></h3>

<div class="paragraph"> </div>

 Recall the reasoning rule for conditionals. Recall that this
    rule is stated by factorizing the premises. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsContinued.eval_if" class="idref" href="#ProofsContinued.eval_if"><span class="id" title="lemma">eval_if</span></a> : <span class="id" title="keyword">∀</span> <a id="s<sub>1</sub>:335" class="idref" href="#s<sub>1</sub>:335"><span class="id" title="binder">s<sub>1</sub></span></a> <a id="s<sub>2</sub>:336" class="idref" href="#s<sub>2</sub>:336"><span class="id" title="binder">s<sub>2</sub></span></a> <a id="b:337" class="idref" href="#b:337"><span class="id" title="binder">b</span></a> <a id="v:338" class="idref" href="#v:338"><span class="id" title="binder">v</span></a> <a id="t<sub>1</sub>:339" class="idref" href="#t<sub>1</sub>:339"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:340" class="idref" href="#t<sub>2</sub>:340"><span class="id" title="binder">t<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:335"><span class="id" title="variable">s<sub>1</sub></span></a> (<span class="id" title="keyword">if</span> <a class="idref" href="Rules.html#b:337"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">then</span> <a class="idref" href="Rules.html#t<sub>1</sub>:339"><span class="id" title="variable">t<sub>1</sub></span></a> <span class="id" title="keyword">else</span> <a class="idref" href="Rules.html#t<sub>2</sub>:340"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#s<sub>2</sub>:336"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Rules.html#v:338"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:335"><span class="id" title="variable">s<sub>1</sub></span></a> (<a class="idref" href="LibSepReference.html#trm_if"><span class="id" title="constructor">trm_if</span></a> <a class="idref" href="Rules.html#b:337"><span class="id" title="variable">b</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:339"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:340"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#s<sub>2</sub>:336"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Rules.html#v:338"><span class="id" title="variable">v</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">case_if</span>; <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#eval_if"><span class="id" title="constructor">eval_if</span></a>; <span class="id" title="var">auto_false</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The reasoning rule for conditional w.r.t. Hoare triples is as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsContinued.hoare_if_case" class="idref" href="#ProofsContinued.hoare_if_case"><span class="id" title="lemma">hoare_if_case</span></a> : <span class="id" title="keyword">∀</span> <a id="b:341" class="idref" href="#b:341"><span class="id" title="binder">b</span></a> <a id="t<sub>1</sub>:342" class="idref" href="#t<sub>1</sub>:342"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:343" class="idref" href="#t<sub>2</sub>:343"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="H:344" class="idref" href="#H:344"><span class="id" title="binder">H</span></a> <a id="Q:345" class="idref" href="#Q:345"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Rules.html#b:341"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:342"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#H:344"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:345"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Rules.html#b:341"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:343"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="Rules.html#H:344"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:345"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> (<a class="idref" href="LibSepReference.html#trm_if"><span class="id" title="constructor">trm_if</span></a> <a class="idref" href="Rules.html#b:341"><span class="id" title="variable">b</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:342"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:343"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#H:344"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:345"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">M<sub>1</sub></span> <span class="id" title="var">M<sub>2</sub></span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">s</span> <span class="id" title="var">K<sub>0</sub></span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">forwards</span>* (<span class="id" title="var">s<sub>1</sub>'</span>&amp;<span class="id" title="var">v<sub>1</sub></span>&amp;<span class="id" title="var">R<sub>1</sub></span>&amp;<span class="id" title="var">K<sub>1</sub></span>): (<span class="id" title="definition">rm</span> <span class="id" title="var">M<sub>1</sub></span>) <span class="id" title="var">K<sub>0</sub></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">s<sub>1</sub>'</span> <span class="id" title="var">v<sub>1</sub></span>. <span class="id" title="tactic">split</span>*. { <span class="id" title="var">applys</span>* <a class="idref" href="Rules.html#ProofsContinued.eval_if"><span class="id" title="lemma">eval_if</span></a>. } }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">forwards</span>* (<span class="id" title="var">s<sub>1</sub>'</span>&amp;<span class="id" title="var">v<sub>1</sub></span>&amp;<span class="id" title="var">R<sub>1</sub></span>&amp;<span class="id" title="var">K<sub>1</sub></span>): (<span class="id" title="definition">rm</span> <span class="id" title="var">M<sub>2</sub></span>) <span class="id" title="var">K<sub>0</sub></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">s<sub>1</sub>'</span> <span class="id" title="var">v<sub>1</sub></span>. <span class="id" title="tactic">split</span>*. { <span class="id" title="var">applys</span>* <a class="idref" href="Rules.html#ProofsContinued.eval_if"><span class="id" title="lemma">eval_if</span></a>. } }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The corresponding Separation Logic reasoning rule is as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsContinued.triple_if_case" class="idref" href="#ProofsContinued.triple_if_case"><span class="id" title="lemma">triple_if_case</span></a> : <span class="id" title="keyword">∀</span> <a id="b:346" class="idref" href="#b:346"><span class="id" title="binder">b</span></a> <a id="t<sub>1</sub>:347" class="idref" href="#t<sub>1</sub>:347"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:348" class="idref" href="#t<sub>2</sub>:348"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="H:349" class="idref" href="#H:349"><span class="id" title="binder">H</span></a> <a id="Q:350" class="idref" href="#Q:350"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Rules.html#b:346"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:347"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#H:349"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:350"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Rules.html#b:346"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:348"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="Rules.html#H:349"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:350"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_if"><span class="id" title="constructor">trm_if</span></a> (<a class="idref" href="LibSepReference.html#val_bool"><span class="id" title="constructor">val_bool</span></a> <a class="idref" href="Rules.html#b:346"><span class="id" title="variable">b</span></a>) <a class="idref" href="Rules.html#t<sub>1</sub>:347"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:348"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#H:349"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:350"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a>. <span class="id" title="var">introv</span> <span class="id" title="var">M<sub>1</sub></span> <span class="id" title="var">M<sub>2</sub></span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="Rules.html#ProofsContinued.hoare_if_case"><span class="id" title="lemma">hoare_if_case</span></a>; <span class="id" title="tactic">intros</span> <span class="id" title="var">Eb</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span>* <span class="id" title="var">M<sub>1</sub></span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span>* <span class="id" title="var">M<sub>2</sub></span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Observe that the above proofs contain a fair amount of duplication,
    due to the symmetry between the <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> and <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">false</span></span> branches.

<div class="paragraph"> </div>

    If we state the reasoning rules using Coq's conditional just like
    it appears in the evaluation rule <span class="inlinecode"><span class="id" title="var">eval_if</span></span>, we can better factorize
    the proof script. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsContinued.hoare_if" class="idref" href="#ProofsContinued.hoare_if"><span class="id" title="lemma">hoare_if</span></a> : <span class="id" title="keyword">∀</span> (<a id="b:351" class="idref" href="#b:351"><span class="id" title="binder">b</span></a>:<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>) <a id="t<sub>1</sub>:352" class="idref" href="#t<sub>1</sub>:352"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:353" class="idref" href="#t<sub>2</sub>:353"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="H:354" class="idref" href="#H:354"><span class="id" title="binder">H</span></a> <a id="Q:355" class="idref" href="#Q:355"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> (<span class="id" title="keyword">if</span> <a class="idref" href="Rules.html#b:351"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">then</span> <a class="idref" href="Rules.html#t<sub>1</sub>:352"><span class="id" title="variable">t<sub>1</sub></span></a> <span class="id" title="keyword">else</span> <a class="idref" href="Rules.html#t<sub>2</sub>:353"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#H:354"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:355"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> (<a class="idref" href="LibSepReference.html#trm_if"><span class="id" title="constructor">trm_if</span></a> <a class="idref" href="Rules.html#b:351"><span class="id" title="variable">b</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:352"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:353"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#H:354"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:355"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">M<sub>1</sub></span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">s</span> <span class="id" title="var">K<sub>0</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">forwards</span> (<span class="id" title="var">s'</span>&amp;<span class="id" title="var">v</span>&amp;<span class="id" title="var">R<sub>1</sub></span>&amp;<span class="id" title="var">K<sub>1</sub></span>): (<span class="id" title="definition">rm</span> <span class="id" title="var">M<sub>1</sub></span>) <span class="id" title="var">K<sub>0</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">s'</span> <span class="id" title="var">v</span>. <span class="id" title="tactic">split</span>. { <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#ProofsContinued.eval_if"><span class="id" title="lemma">eval_if</span></a> <span class="id" title="var">R<sub>1</sub></span>. } { <span class="id" title="var">applys</span> <span class="id" title="var">K<sub>1</sub></span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="ProofsContinued.triple_if" class="idref" href="#ProofsContinued.triple_if"><span class="id" title="lemma">triple_if</span></a> : <span class="id" title="keyword">∀</span> <a id="b:356" class="idref" href="#b:356"><span class="id" title="binder">b</span></a> <a id="t<sub>1</sub>:357" class="idref" href="#t<sub>1</sub>:357"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:358" class="idref" href="#t<sub>2</sub>:358"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="H:359" class="idref" href="#H:359"><span class="id" title="binder">H</span></a> <a id="Q:360" class="idref" href="#Q:360"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<span class="id" title="keyword">if</span> <a class="idref" href="Rules.html#b:356"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">then</span> <a class="idref" href="Rules.html#t<sub>1</sub>:357"><span class="id" title="variable">t<sub>1</sub></span></a> <span class="id" title="keyword">else</span> <a class="idref" href="Rules.html#t<sub>2</sub>:358"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#H:359"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:360"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_if"><span class="id" title="constructor">trm_if</span></a> (<a class="idref" href="LibSepReference.html#val_bool"><span class="id" title="constructor">val_bool</span></a> <a class="idref" href="Rules.html#b:356"><span class="id" title="variable">b</span></a>) <a class="idref" href="Rules.html#t<sub>1</sub>:357"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:358"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#H:359"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:360"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a>. <span class="id" title="var">introv</span> <span class="id" title="var">M<sub>1</sub></span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>. <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#ProofsContinued.hoare_if"><span class="id" title="lemma">hoare_if</span></a>. <span class="id" title="var">applys</span> <span class="id" title="var">M<sub>1</sub></span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab204"></a><h3 class="section">Proof of <span class="inlinecode"><span class="id" title="var">triple_app_fun</span></span></h3>

<div class="paragraph"> </div>

 The reasoning rule for an application asserts that the
    a pre- and poscondition hold for a beta-redex <span class="inlinecode">(<span class="id" title="var">val_fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span>)</span> <span class="inlinecode"><span class="id" title="var">v<sub>2</sub></span></span>
    provided that they hold for the term <span class="inlinecode"><span class="id" title="tactic">subst</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">v<sub>2</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>.

<div class="paragraph"> </div>

    This result follows directly from the big-step evaluation rule
    for applications. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="ProofsContinued.eval_app_fun" class="idref" href="#ProofsContinued.eval_app_fun"><span class="id" title="axiom">eval_app_fun</span></a> : <span class="id" title="keyword">∀</span> <a id="s<sub>1</sub>:361" class="idref" href="#s<sub>1</sub>:361"><span class="id" title="binder">s<sub>1</sub></span></a> <a id="s<sub>2</sub>:362" class="idref" href="#s<sub>2</sub>:362"><span class="id" title="binder">s<sub>2</sub></span></a> <a id="v<sub>1</sub>:363" class="idref" href="#v<sub>1</sub>:363"><span class="id" title="binder">v<sub>1</sub></span></a> <a id="v<sub>2</sub>:364" class="idref" href="#v<sub>2</sub>:364"><span class="id" title="binder">v<sub>2</sub></span></a> <a id="x:365" class="idref" href="#x:365"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:366" class="idref" href="#t<sub>1</sub>:366"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="v:367" class="idref" href="#v:367"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#v<sub>1</sub>:363"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_fun"><span class="id" title="constructor">val_fun</span></a> <a class="idref" href="Rules.html#x:365"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:366"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:361"><span class="id" title="variable">s<sub>1</sub></span></a> (<a class="idref" href="LibSepReference.html#subst"><span class="id" title="definition">subst</span></a> <a class="idref" href="Rules.html#x:365"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#v<sub>2</sub>:364"><span class="id" title="variable">v<sub>2</sub></span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:366"><span class="id" title="variable">t<sub>1</sub></span></a>) <a class="idref" href="Rules.html#s<sub>2</sub>:362"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Rules.html#v:367"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:361"><span class="id" title="variable">s<sub>1</sub></span></a> (<a class="idref" href="LibSepReference.html#trm_app"><span class="id" title="constructor">trm_app</span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:363"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Rules.html#v<sub>2</sub>:364"><span class="id" title="variable">v<sub>2</sub></span></a>) <a class="idref" href="Rules.html#s<sub>2</sub>:362"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="Rules.html#v:367"><span class="id" title="variable">v</span></a>.<br/>
</div>

<div class="doc">
<a id="lab205"></a><h4 class="section">Exercise: 2 stars, standard, optional (hoare_app_fun)</h4>
 Prove the lemma <span class="inlinecode"><span class="id" title="var">hoare_app_fun</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsContinued.hoare_app_fun" class="idref" href="#ProofsContinued.hoare_app_fun"><span class="id" title="lemma">hoare_app_fun</span></a> : <span class="id" title="keyword">∀</span> <a id="v<sub>1</sub>:369" class="idref" href="#v<sub>1</sub>:369"><span class="id" title="binder">v<sub>1</sub></span></a> <a id="v<sub>2</sub>:370" class="idref" href="#v<sub>2</sub>:370"><span class="id" title="binder">v<sub>2</sub></span></a> <a id="x:371" class="idref" href="#x:371"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:372" class="idref" href="#t<sub>1</sub>:372"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="H:373" class="idref" href="#H:373"><span class="id" title="binder">H</span></a> <a id="Q:374" class="idref" href="#Q:374"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#v<sub>1</sub>:369"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_fun"><span class="id" title="constructor">val_fun</span></a> <a class="idref" href="Rules.html#x:371"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:372"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> (<a class="idref" href="LibSepReference.html#subst"><span class="id" title="definition">subst</span></a> <a class="idref" href="Rules.html#x:371"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#v<sub>2</sub>:370"><span class="id" title="variable">v<sub>2</sub></span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:372"><span class="id" title="variable">t<sub>1</sub></span></a>) <a class="idref" href="Rules.html#H:373"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:374"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> (<a class="idref" href="LibSepReference.html#trm_app"><span class="id" title="constructor">trm_app</span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:369"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Rules.html#v<sub>2</sub>:370"><span class="id" title="variable">v<sub>2</sub></span></a>) <a class="idref" href="Rules.html#H:373"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:374"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab206"></a><h4 class="section">Exercise: 2 stars, standard, optional (triple_app_fun)</h4>
 Prove the lemma <span class="inlinecode"><span class="id" title="var">triple_app_fun</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsContinued.triple_app_fun" class="idref" href="#ProofsContinued.triple_app_fun"><span class="id" title="lemma">triple_app_fun</span></a> : <span class="id" title="keyword">∀</span> <a id="x:375" class="idref" href="#x:375"><span class="id" title="binder">x</span></a> <a id="v<sub>1</sub>:376" class="idref" href="#v<sub>1</sub>:376"><span class="id" title="binder">v<sub>1</sub></span></a> <a id="v<sub>2</sub>:377" class="idref" href="#v<sub>2</sub>:377"><span class="id" title="binder">v<sub>2</sub></span></a> <a id="t<sub>1</sub>:378" class="idref" href="#t<sub>1</sub>:378"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="H:379" class="idref" href="#H:379"><span class="id" title="binder">H</span></a> <a id="Q:380" class="idref" href="#Q:380"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#v<sub>1</sub>:376"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_fun"><span class="id" title="constructor">val_fun</span></a> <a class="idref" href="Rules.html#x:375"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:378"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#subst"><span class="id" title="definition">subst</span></a> <a class="idref" href="Rules.html#x:375"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#v<sub>2</sub>:377"><span class="id" title="variable">v<sub>2</sub></span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:378"><span class="id" title="variable">t<sub>1</sub></span></a>) <a class="idref" href="Rules.html#H:379"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:380"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_app"><span class="id" title="constructor">trm_app</span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:376"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Rules.html#v<sub>2</sub>:377"><span class="id" title="variable">v<sub>2</sub></span></a>) <a class="idref" href="Rules.html#H:379"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:380"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab207"></a><h3 class="section">Deallocation of a Reference</h3>

<div class="paragraph"> </div>

 Optional contents: this section may be safely skipped.

<div class="paragraph"> </div>

    Last, we consider the reasoning rule for operation <span class="inlinecode"><span class="id" title="var">free</span></span>.
    We leave this one as exercise. 
<div class="paragraph"> </div>

 Recall the big-step evaluation rule for <span class="inlinecode"><span class="id" title="var">free</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="ProofsContinued.eval_free" class="idref" href="#ProofsContinued.eval_free"><span class="id" title="axiom">eval_free</span></a> : <span class="id" title="keyword">∀</span> <a id="s:381" class="idref" href="#s:381"><span class="id" title="binder">s</span></a> <a id="p:382" class="idref" href="#p:382"><span class="id" title="binder">p</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.indom"><span class="id" title="definition">Fmap.indom</span></a> <a class="idref" href="Rules.html#s:381"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#p:382"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:381"><span class="id" title="variable">s</span></a> (<a class="idref" href="LibSepReference.html#val_set"><span class="id" title="constructor">val_set</span></a> (<a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:382"><span class="id" title="variable">p</span></a>)) (<a class="idref" href="LibSepReference.html#Fmap.remove"><span class="id" title="definition">Fmap.remove</span></a> <a class="idref" href="Rules.html#s:381"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#p:382"><span class="id" title="variable">p</span></a>) <a class="idref" href="LibSepReference.html#val_unit"><span class="id" title="constructor">val_unit</span></a>.<br/>
</div>

<div class="doc">
Let us reformulate <span class="inlinecode"><span class="id" title="var">eval_free</span></span> to replace references to <span class="inlinecode"><span class="id" title="var">Fmap.indom</span></span>
    and <span class="inlinecode"><span class="id" title="var">Fmap.remove</span></span> with references to <span class="inlinecode"><span class="id" title="var">Fmap.single</span></span> and <span class="inlinecode"><span class="id" title="var">Fmap.union</span></span>
    and <span class="inlinecode"><span class="id" title="var">Fmap.disjoint</span></span>. The details are not essential, thus omitted. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="ProofsContinued.eval_free_sep" class="idref" href="#ProofsContinued.eval_free_sep"><span class="id" title="axiom">eval_free_sep</span></a> : <span class="id" title="keyword">∀</span> <a id="s<sub>1</sub>:384" class="idref" href="#s<sub>1</sub>:384"><span class="id" title="binder">s<sub>1</sub></span></a> <a id="s<sub>2</sub>:385" class="idref" href="#s<sub>2</sub>:385"><span class="id" title="binder">s<sub>2</sub></span></a> <a id="v:386" class="idref" href="#v:386"><span class="id" title="binder">v</span></a> <a id="p:387" class="idref" href="#p:387"><span class="id" title="binder">p</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#s<sub>1</sub>:384"><span class="id" title="variable">s<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#Fmap.union"><span class="id" title="definition">Fmap.union</span></a> (<a class="idref" href="LibSepReference.html#Fmap.single"><span class="id" title="definition">Fmap.single</span></a> <a class="idref" href="Rules.html#p:387"><span class="id" title="variable">p</span></a> <a class="idref" href="Rules.html#v:386"><span class="id" title="variable">v</span></a>) <a class="idref" href="Rules.html#s<sub>2</sub>:385"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.disjoint"><span class="id" title="definition">Fmap.disjoint</span></a> (<a class="idref" href="LibSepReference.html#Fmap.single"><span class="id" title="definition">Fmap.single</span></a> <a class="idref" href="Rules.html#p:387"><span class="id" title="variable">p</span></a> <a class="idref" href="Rules.html#v:386"><span class="id" title="variable">v</span></a>) <a class="idref" href="Rules.html#s<sub>2</sub>:385"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:384"><span class="id" title="variable">s<sub>1</sub></span></a> (<a class="idref" href="LibSepReference.html#val_free"><span class="id" title="constructor">val_free</span></a> <a class="idref" href="Rules.html#p:387"><span class="id" title="variable">p</span></a>) <a class="idref" href="Rules.html#s<sub>2</sub>:385"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#val_unit"><span class="id" title="constructor">val_unit</span></a>.<br/>
</div>

<div class="doc">
<a id="lab208"></a><h4 class="section">Exercise: 3 stars, standard, optional (hoare_free)</h4>
 Prove the Hoare triple for the operation <span class="inlinecode"><span class="id" title="var">free</span></span>.
    Hint: exploit the lemma <span class="inlinecode"><span class="id" title="var">eval_free_sep</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsContinued.hoare_free" class="idref" href="#ProofsContinued.hoare_free"><span class="id" title="lemma">hoare_free</span></a> : <span class="id" title="keyword">∀</span> <a id="H:389" class="idref" href="#H:389"><span class="id" title="binder">H</span></a> <a id="p:390" class="idref" href="#p:390"><span class="id" title="binder">p</span></a> <a id="v:391" class="idref" href="#v:391"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> (<a class="idref" href="LibSepReference.html#val_free"><span class="id" title="constructor">val_free</span></a> (<a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:390"><span class="id" title="variable">p</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Rules.html#p:390"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:391"><span class="id" title="variable">v</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Rules.html#H:389"><span class="id" title="variable">H</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒  <a class="idref" href="Rules.html#H:389"><span class="id" title="variable">H</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab209"></a><h4 class="section">Exercise: 1 star, standard, optional (triple_free)</h4>
 Derive from the Hoare triple for the operation <span class="inlinecode"><span class="id" title="var">free</span></span>
    the corresponding Separation Logic triple.
    Hint: adapt the proof of lemma <span class="inlinecode"><span class="id" title="var">triple_set</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsContinued.triple_free" class="idref" href="#ProofsContinued.triple_free"><span class="id" title="lemma">triple_free</span></a> : <span class="id" title="keyword">∀</span> <a id="p:392" class="idref" href="#p:392"><span class="id" title="binder">p</span></a> <a id="v:393" class="idref" href="#v:393"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_free"><span class="id" title="constructor">val_free</span></a> (<a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:392"><span class="id" title="variable">p</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Rules.html#p:392"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:393"><span class="id" title="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab210"></a><h3 class="section">Write in a Reference</h3>

<div class="paragraph"> </div>

 The big-step evaluation rule for <span class="inlinecode"><span class="id" title="tactic">set</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> updates the initial
    state <span class="inlinecode"><span class="id" title="var">s</span></span> by re-binding the location <span class="inlinecode"><span class="id" title="var">p</span></span> to the value <span class="inlinecode"><span class="id" title="var">v</span></span>.
    The location <span class="inlinecode"><span class="id" title="var">p</span></span> must already belong to the domain of <span class="inlinecode"><span class="id" title="var">s</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="ProofsContinued.eval_set" class="idref" href="#ProofsContinued.eval_set"><span class="id" title="axiom">eval_set</span></a> : <span class="id" title="keyword">∀</span> <a id="m:394" class="idref" href="#m:394"><span class="id" title="binder">m</span></a> <a id="p:395" class="idref" href="#p:395"><span class="id" title="binder">p</span></a> <a id="v:396" class="idref" href="#v:396"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.indom"><span class="id" title="definition">Fmap.indom</span></a> <a class="idref" href="Rules.html#m:394"><span class="id" title="variable">m</span></a> <a class="idref" href="Rules.html#p:395"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#m:394"><span class="id" title="variable">m</span></a> (<a class="idref" href="LibSepReference.html#val_set"><span class="id" title="constructor">val_set</span></a> (<a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:395"><span class="id" title="variable">p</span></a>) <a class="idref" href="Rules.html#v:396"><span class="id" title="variable">v</span></a>) (<a class="idref" href="LibSepReference.html#Fmap.update"><span class="id" title="definition">Fmap.update</span></a> <a class="idref" href="Rules.html#m:394"><span class="id" title="variable">m</span></a> <a class="idref" href="Rules.html#p:395"><span class="id" title="variable">p</span></a> <a class="idref" href="Rules.html#v:396"><span class="id" title="variable">v</span></a>) <a class="idref" href="LibSepReference.html#val_unit"><span class="id" title="constructor">val_unit</span></a>.<br/>
</div>

<div class="doc">
As for <span class="inlinecode"><span class="id" title="var">get</span></span>, we first reformulate this lemma, to replace
    references to <span class="inlinecode"><span class="id" title="var">Fmap.indom</span></span> and <span class="inlinecode"><span class="id" title="var">Fmap.update</span></span> with references
    to <span class="inlinecode"><span class="id" title="var">Fmap.union</span></span>, <span class="inlinecode"><span class="id" title="var">Fmap.single</span></span>, and <span class="inlinecode"><span class="id" title="var">Fmap.disjoint</span></span>, to
    prepare for the introduction of separating conjunctions. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsContinued.eval_set_sep" class="idref" href="#ProofsContinued.eval_set_sep"><span class="id" title="lemma">eval_set_sep</span></a> : <span class="id" title="keyword">∀</span> <a id="s<sub>1</sub>:398" class="idref" href="#s<sub>1</sub>:398"><span class="id" title="binder">s<sub>1</sub></span></a> <a id="s<sub>2</sub>:399" class="idref" href="#s<sub>2</sub>:399"><span class="id" title="binder">s<sub>2</sub></span></a> <a id="h<sub>2</sub>:400" class="idref" href="#h<sub>2</sub>:400"><span class="id" title="binder">h<sub>2</sub></span></a> <a id="p:401" class="idref" href="#p:401"><span class="id" title="binder">p</span></a> <a id="v<sub>1</sub>:402" class="idref" href="#v<sub>1</sub>:402"><span class="id" title="binder">v<sub>1</sub></span></a> <a id="v<sub>2</sub>:403" class="idref" href="#v<sub>2</sub>:403"><span class="id" title="binder">v<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#s<sub>1</sub>:398"><span class="id" title="variable">s<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#Fmap.union"><span class="id" title="definition">Fmap.union</span></a> (<a class="idref" href="LibSepReference.html#Fmap.single"><span class="id" title="definition">Fmap.single</span></a> <a class="idref" href="Rules.html#p:401"><span class="id" title="variable">p</span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:402"><span class="id" title="variable">v<sub>1</sub></span></a>) <a class="idref" href="Rules.html#h<sub>2</sub>:400"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#s<sub>2</sub>:399"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#Fmap.union"><span class="id" title="definition">Fmap.union</span></a> (<a class="idref" href="LibSepReference.html#Fmap.single"><span class="id" title="definition">Fmap.single</span></a> <a class="idref" href="Rules.html#p:401"><span class="id" title="variable">p</span></a> <a class="idref" href="Rules.html#v<sub>2</sub>:403"><span class="id" title="variable">v<sub>2</sub></span></a>) <a class="idref" href="Rules.html#h<sub>2</sub>:400"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.disjoint"><span class="id" title="definition">Fmap.disjoint</span></a> (<a class="idref" href="LibSepReference.html#Fmap.single"><span class="id" title="definition">Fmap.single</span></a> <a class="idref" href="Rules.html#p:401"><span class="id" title="variable">p</span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:402"><span class="id" title="variable">v<sub>1</sub></span></a>) <a class="idref" href="Rules.html#h<sub>2</sub>:400"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s<sub>1</sub>:398"><span class="id" title="variable">s<sub>1</sub></span></a> (<a class="idref" href="LibSepReference.html#val_set"><span class="id" title="constructor">val_set</span></a> (<a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:401"><span class="id" title="variable">p</span></a>) <a class="idref" href="Rules.html#v<sub>2</sub>:403"><span class="id" title="variable">v<sub>2</sub></span></a>) <a class="idref" href="Rules.html#s<sub>2</sub>:399"><span class="id" title="variable">s<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#val_unit"><span class="id" title="constructor">val_unit</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
</div>

<div class="doc">
It is not needed to follow through this proof. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">introv</span> → → <span class="id" title="var">D</span>. <span class="id" title="var">forwards</span> <span class="id" title="var">Dv</span>: <a class="idref" href="LibSepReference.html#Fmap.indom_single"><span class="id" title="lemma">Fmap.indom_single</span></a> <span class="id" title="var">p</span> <span class="id" title="var">v<sub>1</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">applys_eq</span> <a class="idref" href="Rules.html#ProofsContinued.eval_set"><span class="id" title="axiom">eval_set</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">rewrite</span>* <a class="idref" href="LibSepReference.html#Fmap.update_union_l"><span class="id" title="lemma">Fmap.update_union_l</span></a>. <span class="id" title="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span>* <a class="idref" href="LibSepReference.html#Fmap.update_single"><span class="id" title="lemma">Fmap.update_single</span></a>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span>* <a class="idref" href="LibSepReference.html#Fmap.indom_union_l"><span class="id" title="lemma">Fmap.indom_union_l</span></a>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The proof of the Hoare rule for <span class="inlinecode"><span class="id" title="tactic">set</span></span> makes use of the following
    fact (from <span class="inlinecode"><span class="id" title="var">LibSepFmap.v</span></span>) about <span class="inlinecode"><span class="id" title="var">Fmap.disjoint</span></span>: when one of its argument
    is a singleton map, the value stored in that singleton map is irrelevant.
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <span class="id" title="var">Fmap.disjoint_single_set</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">p</span> <span class="id" title="var">v<sub>1</sub></span> <span class="id" title="var">v<sub>2</sub></span> <span class="id" title="var">h<sub>2</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Fmap.disjoint</span> (<span class="id" title="var">Fmap.single</span> <span class="id" title="var">p</span> <span class="id" title="var">v<sub>1</sub></span>) <span class="id" title="var">h<sub>2</sub></span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Fmap.disjoint</span> (<span class="id" title="var">Fmap.single</span> <span class="id" title="var">p</span> <span class="id" title="var">v<sub>2</sub></span>) <span class="id" title="var">h<sub>2</sub></span>.
</span>
<div class="paragraph"> </div>

<a id="lab211"></a><h4 class="section">Exercise: 5 stars, standard, optional (hoare_set)</h4>
 Prove the lemma <span class="inlinecode"><span class="id" title="var">hoare_set</span></span>.
    Hints:
<ul class="doclist">
<li> exploit the evaluation rule <span class="inlinecode"><span class="id" title="var">eval_set_sep</span></span> presented above,

</li>
<li> exploit the lemma <span class="inlinecode"><span class="id" title="var">Fmap.disjoint_single_set</span></span> presented above,

</li>
<li> to obtain an elegant proof, prefer invoking the lemmas
      <span class="inlinecode"><span class="id" title="var">hsingle_intro</span></span>, <span class="inlinecode"><span class="id" title="var">hsingle_inv</span></span>, <span class="inlinecode"><span class="id" title="var">hstar_intro</span></span>, and <span class="inlinecode"><span class="id" title="var">hstar_inv</span></span>,
      rather than unfolding the definitions of <span class="inlinecode"><span class="id" title="var">hstar</span></span> and <span class="inlinecode"><span class="id" title="var">hsingle</span></span>. 

</li>
</ul>
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsContinued.hoare_set" class="idref" href="#ProofsContinued.hoare_set"><span class="id" title="lemma">hoare_set</span></a> : <span class="id" title="keyword">∀</span> <a id="H:404" class="idref" href="#H:404"><span class="id" title="binder">H</span></a> <a id="v:405" class="idref" href="#v:405"><span class="id" title="binder">v</span></a> <a id="p:406" class="idref" href="#p:406"><span class="id" title="binder">p</span></a> <a id="v':407" class="idref" href="#v':407"><span class="id" title="binder">v'</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> (<a class="idref" href="LibSepReference.html#val_set"><span class="id" title="constructor">val_set</span></a> (<a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:406"><span class="id" title="variable">p</span></a>) <a class="idref" href="Rules.html#v:405"><span class="id" title="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Rules.html#p:406"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v':407"><span class="id" title="variable">v'</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Rules.html#H:404"><span class="id" title="variable">H</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Rules.html#p:406"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:405"><span class="id" title="variable">v</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Rules.html#H:404"><span class="id" title="variable">H</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 We then derive the Separation Logic triple as usual. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsContinued.triple_set" class="idref" href="#ProofsContinued.triple_set"><span class="id" title="lemma">triple_set</span></a> : <span class="id" title="keyword">∀</span> <a id="w:408" class="idref" href="#w:408"><span class="id" title="binder">w</span></a> <a id="p:409" class="idref" href="#p:409"><span class="id" title="binder">p</span></a> <a id="v:410" class="idref" href="#v:410"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_set"><span class="id" title="constructor">val_set</span></a> (<a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:409"><span class="id" title="variable">p</span></a>) <a class="idref" href="Rules.html#w:408"><span class="id" title="variable">w</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Rules.html#p:409"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:410"><span class="id" title="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Rules.html#p:409"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#w:408"><span class="id" title="variable">w</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>. <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#ProofsContinued.hoare_set"><span class="id" title="axiom">hoare_set</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Rules.html#ProofsContinued"><span class="id" title="module">ProofsContinued</span></a>.<br/>
</div>

<div class="doc">
<a id="lab212"></a><h3 class="section">Proofs Revisited using the <span class="inlinecode"><span class="id" title="var">triple_of_hoare</span></span> Lemma</h3>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="ProofsFactorization" class="idref" href="#ProofsFactorization"><span class="id" title="module">ProofsFactorization</span></a>.<br/>
</div>

<div class="doc">
The proof that, e.g., <span class="inlinecode"><span class="id" title="var">triple_add</span></span> is a consequence of
   <span class="inlinecode"><span class="id" title="var">hoare_add</span></span> follows the same pattern as many other similar
   proofs, each time invoking the lemma <span class="inlinecode"><span class="id" title="var">hoare_conseq</span></span>.
   Thus, we could attempt at factorizing this proof pattern.
   The following lemma corresponds to such an attempt. 
<div class="paragraph"> </div>

<a id="lab213"></a><h4 class="section">Exercise: 2 stars, standard, optional (triple_of_hoare)</h4>
 Prove the lemma <span class="inlinecode"><span class="id" title="var">triple_of_hoare</span></span> stated below. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsFactorization.triple_of_hoare" class="idref" href="#ProofsFactorization.triple_of_hoare"><span class="id" title="lemma">triple_of_hoare</span></a> : <span class="id" title="keyword">∀</span> <a id="t:411" class="idref" href="#t:411"><span class="id" title="binder">t</span></a> <a id="H:412" class="idref" href="#H:412"><span class="id" title="binder">H</span></a> <a id="Q:413" class="idref" href="#Q:413"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="H':414" class="idref" href="#H':414"><span class="id" title="binder">H'</span></a>, <span class="id" title="notation">∃</span> <a id="Q':415" class="idref" href="#Q':415"><span class="id" title="binder">Q'</span></a><span class="id" title="notation">,</span> <a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> <a class="idref" href="Rules.html#t:411"><span class="id" title="variable">t</span></a> (<a class="idref" href="Rules.html#H:412"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Rules.html#H':414"><span class="id" title="variable">H'</span></a>) <a class="idref" href="Rules.html#Q':415"><span class="id" title="variable">Q'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a>  <a class="idref" href="Rules.html#Q':415"><span class="id" title="variable">Q'</span></a> <a class="idref" href="LibSepReference.html#9351a4f098e275023c32e0091e608189"><span class="id" title="notation">===&gt;</span></a> <a class="idref" href="Rules.html#Q:413"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Rules.html#H':414"><span class="id" title="variable">H'</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t:411"><span class="id" title="variable">t</span></a> <a class="idref" href="Rules.html#H:412"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:413"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab214"></a><h4 class="section">Exercise: 2 stars, standard, optional (triple_add')</h4>
 Prove that <span class="inlinecode"><span class="id" title="var">triple_add</span></span> is a consequence of <span class="inlinecode"><span class="id" title="var">hoare_add</span></span> by
    exploiting <span class="inlinecode"><span class="id" title="var">triple_of_hoare</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsFactorization.triple_add'" class="idref" href="#ProofsFactorization.triple_add'"><span class="id" title="lemma">triple_add'</span></a> : <span class="id" title="keyword">∀</span> <a id="n<sub>1</sub>:416" class="idref" href="#n<sub>1</sub>:416"><span class="id" title="binder">n<sub>1</sub></span></a> <a id="n<sub>2</sub>:417" class="idref" href="#n<sub>2</sub>:417"><span class="id" title="binder">n<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_add"><span class="id" title="constructor">val_add</span></a> <a class="idref" href="Rules.html#n<sub>1</sub>:416"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:417"><span class="id" title="variable">n<sub>2</sub></span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:418" class="idref" href="#r:418"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#r:418"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> (<a class="idref" href="Rules.html#n<sub>1</sub>:416"><span class="id" title="variable">n<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> <a class="idref" href="Rules.html#n<sub>2</sub>:417"><span class="id" title="variable">n<sub>2</sub></span></a>)<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="code">

<span class="id" title="keyword">End</span> <a class="idref" href="Rules.html#ProofsFactorization"><span class="id" title="module">ProofsFactorization</span></a>.<br/>
</div>

<div class="doc">
<a id="lab215"></a><h3 class="section">Triple for Terms with Same Semantics</h3>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="ProofsSameSemantics" class="idref" href="#ProofsSameSemantics"><span class="id" title="module">ProofsSameSemantics</span></a>.<br/>
</div>

<div class="doc">
A general principle is that if <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> has the same semantics
    as <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> (w.r.t. the big-step evaluation judgment <span class="inlinecode"><span class="id" title="tactic">eval</span></span>),
    then <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> satisfy the same triples.

<div class="paragraph"> </div>

    Let us formalize this principle. 
<div class="paragraph"> </div>

 Two (closed) terms are semantically equivalent, written
    <span class="inlinecode"><span class="id" title="var">trm_equiv</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>, if two terms, when evaluated in the same
    state, produce the same output. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="ProofsSameSemantics.trm_equiv" class="idref" href="#ProofsSameSemantics.trm_equiv"><span class="id" title="definition">trm_equiv</span></a> (<a id="t<sub>1</sub>:419" class="idref" href="#t<sub>1</sub>:419"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:420" class="idref" href="#t<sub>2</sub>:420"><span class="id" title="binder">t<sub>2</sub></span></a>:<a class="idref" href="LibSepReference.html#trm"><span class="id" title="inductive">trm</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a id="s:421" class="idref" href="#s:421"><span class="id" title="binder">s</span></a> <a id="s':422" class="idref" href="#s':422"><span class="id" title="binder">s'</span></a> <a id="v:423" class="idref" href="#v:423"><span class="id" title="binder">v</span></a>, <a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:421"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:419"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#s':422"><span class="id" title="variable">s'</span></a> <a class="idref" href="Rules.html#v:423"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:421"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:420"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="Rules.html#s':422"><span class="id" title="variable">s'</span></a> <a class="idref" href="Rules.html#v:423"><span class="id" title="variable">v</span></a>.<br/>
</div>

<div class="doc">
Two terms that are equivalent satisfy the same Separation Logic
    triples (and the same Hoare triples).

<div class="paragraph"> </div>

    Indeed, the definition of a Separation Logic triple directly depends
    on the notion of Hoare triple, and the latter directly depends
    on the semantics captured by the predicate <span class="inlinecode"><span class="id" title="tactic">eval</span></span>.

<div class="paragraph"> </div>

    Let us formalize the result in three steps. 
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">eval_like</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> asserts that <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> evaluates like <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>.
    In particular, this relation hold whenever <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> reduces
    in small-step to <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="ProofsSameSemantics.eval_like" class="idref" href="#ProofsSameSemantics.eval_like"><span class="id" title="definition">eval_like</span></a> (<a id="t<sub>1</sub>:424" class="idref" href="#t<sub>1</sub>:424"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:425" class="idref" href="#t<sub>2</sub>:425"><span class="id" title="binder">t<sub>2</sub></span></a>:<a class="idref" href="LibSepReference.html#trm"><span class="id" title="inductive">trm</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a id="s:426" class="idref" href="#s:426"><span class="id" title="binder">s</span></a> <a id="s':427" class="idref" href="#s':427"><span class="id" title="binder">s'</span></a> <a id="v:428" class="idref" href="#v:428"><span class="id" title="binder">v</span></a>, <a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:426"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:424"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#s':427"><span class="id" title="variable">s'</span></a> <a class="idref" href="Rules.html#v:428"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Rules.html#s:426"><span class="id" title="variable">s</span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:425"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="Rules.html#s':427"><span class="id" title="variable">s'</span></a> <a class="idref" href="Rules.html#v:428"><span class="id" title="variable">v</span></a>.<br/>
</div>

<div class="doc">
For example <span class="inlinecode"><span class="id" title="var">eval_like</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">(<span class="id" title="var">trm_let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span> holds, reflecting the
    fact that <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> reduces in small-step to <span class="inlinecode"><span class="id" title="var">t</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsSameSemantics.eval_like_eta_reduction" class="idref" href="#ProofsSameSemantics.eval_like_eta_reduction"><span class="id" title="lemma">eval_like_eta_reduction</span></a> : <span class="id" title="keyword">∀</span> (<a id="t:429" class="idref" href="#t:429"><span class="id" title="binder">t</span></a>:<a class="idref" href="LibSepReference.html#trm"><span class="id" title="inductive">trm</span></a>) (<a id="x:430" class="idref" href="#x:430"><span class="id" title="binder">x</span></a>:<a class="idref" href="LibSepVar.html#var"><span class="id" title="definition">var</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#ProofsSameSemantics.eval_like"><span class="id" title="definition">eval_like</span></a> <a class="idref" href="Rules.html#t:429"><span class="id" title="variable">t</span></a> (<a class="idref" href="LibSepReference.html#trm_let"><span class="id" title="constructor">trm_let</span></a> <a class="idref" href="Rules.html#x:430"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t:429"><span class="id" title="variable">t</span></a> <a class="idref" href="Rules.html#x:430"><span class="id" title="variable">x</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">R</span>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#eval_let"><span class="id" title="constructor">eval_let</span></a> <span class="id" title="var">R</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="LibSepVar.html#var_eq_spec"><span class="id" title="lemma">var_eq_spec</span></a>. <span class="id" title="var">case_if</span>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#eval_val"><span class="id" title="constructor">eval_val</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
It turns out that the symmetric relation <span class="inlinecode"><span class="id" title="var">eval_like</span></span> <span class="inlinecode">(<span class="id" title="var">trm_let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span> <span class="inlinecode"><span class="id" title="var">t</span></span>
    also holds: the term <span class="inlinecode"><span class="id" title="var">t</span></span> does not exhibit more behaviors than those
    of <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsSameSemantics.eval_like_eta_expansion" class="idref" href="#ProofsSameSemantics.eval_like_eta_expansion"><span class="id" title="lemma">eval_like_eta_expansion</span></a> : <span class="id" title="keyword">∀</span> (<a id="t:431" class="idref" href="#t:431"><span class="id" title="binder">t</span></a>:<a class="idref" href="LibSepReference.html#trm"><span class="id" title="inductive">trm</span></a>) (<a id="x:432" class="idref" href="#x:432"><span class="id" title="binder">x</span></a>:<a class="idref" href="LibSepVar.html#var"><span class="id" title="definition">var</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#ProofsSameSemantics.eval_like"><span class="id" title="definition">eval_like</span></a> (<a class="idref" href="LibSepReference.html#trm_let"><span class="id" title="constructor">trm_let</span></a> <a class="idref" href="Rules.html#x:432"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t:431"><span class="id" title="variable">t</span></a> <a class="idref" href="Rules.html#x:432"><span class="id" title="variable">x</span></a>) <a class="idref" href="Rules.html#t:431"><span class="id" title="variable">t</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">R</span>. <span class="id" title="var">inverts</span> <span class="id" title="var">R</span> <span class="id" title="keyword">as</span>. <span class="id" title="var">introv</span> <span class="id" title="var">R<sub>1</sub></span> <span class="id" title="var">R<sub>2</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">R<sub>2</sub></span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="LibSepVar.html#var_eq_spec"><span class="id" title="lemma">var_eq_spec</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">R<sub>2</sub></span>. <span class="id" title="var">case_if</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">inverts</span> <span class="id" title="var">R<sub>2</sub></span>. <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
We deduce that a term <span class="inlinecode"><span class="id" title="var">t</span></span> denotes a program equivalent to
    the program <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsSameSemantics.trm_equiv_eta" class="idref" href="#ProofsSameSemantics.trm_equiv_eta"><span class="id" title="lemma">trm_equiv_eta</span></a> : <span class="id" title="keyword">∀</span> (<a id="t:433" class="idref" href="#t:433"><span class="id" title="binder">t</span></a>:<a class="idref" href="LibSepReference.html#trm"><span class="id" title="inductive">trm</span></a>) (<a id="x:434" class="idref" href="#x:434"><span class="id" title="binder">x</span></a>:<a class="idref" href="LibSepVar.html#var"><span class="id" title="definition">var</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#ProofsSameSemantics.trm_equiv"><span class="id" title="definition">trm_equiv</span></a> <a class="idref" href="Rules.html#t:433"><span class="id" title="variable">t</span></a> (<a class="idref" href="LibSepReference.html#trm_let"><span class="id" title="constructor">trm_let</span></a> <a class="idref" href="Rules.html#x:434"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t:433"><span class="id" title="variable">t</span></a> <a class="idref" href="Rules.html#x:434"><span class="id" title="variable">x</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">s</span> <span class="id" title="var">s'</span> <span class="id" title="var">v</span>. <span class="id" title="var">iff</span> <span class="id" title="var">M</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#ProofsSameSemantics.eval_like_eta_reduction"><span class="id" title="lemma">eval_like_eta_reduction</span></a> <span class="id" title="var">M</span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#ProofsSameSemantics.eval_like_eta_expansion"><span class="id" title="lemma">eval_like_eta_expansion</span></a> <span class="id" title="var">M</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
If <span class="inlinecode"><span class="id" title="var">eval_like</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>, then any triple that holds for <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span>
    also holds for <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsSameSemantics.hoare_eval_like" class="idref" href="#ProofsSameSemantics.hoare_eval_like"><span class="id" title="lemma">hoare_eval_like</span></a> : <span class="id" title="keyword">∀</span> <a id="t<sub>1</sub>:435" class="idref" href="#t<sub>1</sub>:435"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:436" class="idref" href="#t<sub>2</sub>:436"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="H:437" class="idref" href="#H:437"><span class="id" title="binder">H</span></a> <a id="Q:438" class="idref" href="#Q:438"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#ProofsSameSemantics.eval_like"><span class="id" title="definition">eval_like</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:435"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:436"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:435"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#H:437"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:438"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:436"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="Rules.html#H:437"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:438"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">E</span> <span class="id" title="var">M<sub>1</sub></span> <span class="id" title="var">K<sub>0</sub></span>. <span class="id" title="var">forwards</span> (<span class="id" title="var">s'</span>&amp;<span class="id" title="var">v</span>&amp;<span class="id" title="var">R<sub>1</sub></span>&amp;<span class="id" title="var">K<sub>1</sub></span>): <span class="id" title="var">M<sub>1</sub></span> <span class="id" title="var">K<sub>0</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">s'</span> <span class="id" title="var">v</span>. <span class="id" title="tactic">split</span>. { <span class="id" title="var">applys</span> <span class="id" title="var">E</span> <span class="id" title="var">R<sub>1</sub></span>. } { <span class="id" title="var">applys</span> <span class="id" title="var">K<sub>1</sub></span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="ProofsSameSemantics.triple_eval_like" class="idref" href="#ProofsSameSemantics.triple_eval_like"><span class="id" title="lemma">triple_eval_like</span></a> : <span class="id" title="keyword">∀</span> <a id="t<sub>1</sub>:439" class="idref" href="#t<sub>1</sub>:439"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:440" class="idref" href="#t<sub>2</sub>:440"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="H:441" class="idref" href="#H:441"><span class="id" title="binder">H</span></a> <a id="Q:442" class="idref" href="#Q:442"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#ProofsSameSemantics.eval_like"><span class="id" title="definition">eval_like</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:439"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:440"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:439"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#H:441"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:442"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:440"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="Rules.html#H:441"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:442"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">E</span> <span class="id" title="var">M<sub>1</sub></span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>. <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#ProofsSameSemantics.hoare_eval_like"><span class="id" title="lemma">hoare_eval_like</span></a> <span class="id" title="var">E</span>. <span class="id" title="var">applys</span> <span class="id" title="var">M<sub>1</sub></span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
It follows that if two terms are equivalent, then they admit
    the same triples. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsSameSemantics.triple_trm_equiv" class="idref" href="#ProofsSameSemantics.triple_trm_equiv"><span class="id" title="lemma">triple_trm_equiv</span></a> : <span class="id" title="keyword">∀</span> <a id="t<sub>1</sub>:443" class="idref" href="#t<sub>1</sub>:443"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:444" class="idref" href="#t<sub>2</sub>:444"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="H:445" class="idref" href="#H:445"><span class="id" title="binder">H</span></a> <a id="Q:446" class="idref" href="#Q:446"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#ProofsSameSemantics.trm_equiv"><span class="id" title="definition">trm_equiv</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:443"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:444"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:443"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#H:445"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:446"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:444"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="Rules.html#H:445"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:446"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">E</span>. <span class="id" title="var">unfolds</span> <a class="idref" href="Rules.html#ProofsSameSemantics.trm_equiv"><span class="id" title="definition">trm_equiv</span></a>. <span class="id" title="var">iff</span> <span class="id" title="var">M</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#ProofsSameSemantics.triple_eval_like"><span class="id" title="lemma">triple_eval_like</span></a> <span class="id" title="var">M</span>. <span class="id" title="var">introv</span> <span class="id" title="var">R</span>. <span class="id" title="var">applys</span>* <span class="id" title="var">E</span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#ProofsSameSemantics.triple_eval_like"><span class="id" title="lemma">triple_eval_like</span></a> <span class="id" title="var">M</span>. <span class="id" title="var">introv</span> <span class="id" title="var">R</span>. <span class="id" title="var">applys</span>* <span class="id" title="var">E</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The reasoning rule <span class="inlinecode"><span class="id" title="var">triple_eval_like</span></span> has a number of practical
    applications. One, show below, is to revisit the proof of <span class="inlinecode"><span class="id" title="var">triple_app_fun</span></span>
    in a much more succint way, by arguing that <span class="inlinecode"><span class="id" title="var">trm_app</span></span> <span class="inlinecode">(<span class="id" title="var">val_fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span>)</span> <span class="inlinecode"><span class="id" title="var">v<sub>2</sub></span></span> and
    <span class="inlinecode"><span class="id" title="tactic">subst</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">v<sub>2</sub></span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> are equivalent terms, hence they admit the same behavior. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsSameSemantics.triple_app_fun" class="idref" href="#ProofsSameSemantics.triple_app_fun"><span class="id" title="lemma">triple_app_fun</span></a> : <span class="id" title="keyword">∀</span> <a id="x:447" class="idref" href="#x:447"><span class="id" title="binder">x</span></a> <a id="v<sub>1</sub>:448" class="idref" href="#v<sub>1</sub>:448"><span class="id" title="binder">v<sub>1</sub></span></a> <a id="v<sub>2</sub>:449" class="idref" href="#v<sub>2</sub>:449"><span class="id" title="binder">v<sub>2</sub></span></a> <a id="t<sub>1</sub>:450" class="idref" href="#t<sub>1</sub>:450"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="H:451" class="idref" href="#H:451"><span class="id" title="binder">H</span></a> <a id="Q:452" class="idref" href="#Q:452"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Rules.html#v<sub>1</sub>:448"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_fun"><span class="id" title="constructor">val_fun</span></a> <a class="idref" href="Rules.html#x:447"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:450"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#subst"><span class="id" title="definition">subst</span></a> <a class="idref" href="Rules.html#x:447"><span class="id" title="variable">x</span></a> <a class="idref" href="Rules.html#v<sub>2</sub>:449"><span class="id" title="variable">v<sub>2</sub></span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:450"><span class="id" title="variable">t<sub>1</sub></span></a>) <a class="idref" href="Rules.html#H:451"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:452"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_app"><span class="id" title="constructor">trm_app</span></a> <a class="idref" href="Rules.html#v<sub>1</sub>:448"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Rules.html#v<sub>2</sub>:449"><span class="id" title="variable">v<sub>2</sub></span></a>) <a class="idref" href="Rules.html#H:451"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:452"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">E</span> <span class="id" title="var">M<sub>1</sub></span>. <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#ProofsSameSemantics.triple_eval_like"><span class="id" title="lemma">triple_eval_like</span></a> <span class="id" title="var">M<sub>1</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">R</span>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#eval_app_fun"><span class="id" title="constructor">eval_app_fun</span></a> <span class="id" title="var">E</span> <span class="id" title="var">R</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Another application is the following rule, which allows to modify the
    parenthesis structure of a sequence. 
<div class="paragraph"> </div>

<a id="lab216"></a><h4 class="section">Exercise: 3 stars, standard, optional (triple_trm_seq_assoc)</h4>
 Prove that the term <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span>;</span> <span class="inlinecode">(<span class="id" title="var">t<sub>2</sub></span>;</span> <span class="inlinecode"><span class="id" title="var">t<sub>3</sub></span>)</span> satisfies the same triples as the
    term <span class="inlinecode">(<span class="id" title="var">t<sub>1</sub></span>;<span class="id" title="var">t<sub>2</sub></span>);</span> <span class="inlinecode"><span class="id" title="var">t<sub>3</sub></span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="ProofsSameSemantics.triple_trm_seq_assoc" class="idref" href="#ProofsSameSemantics.triple_trm_seq_assoc"><span class="id" title="lemma">triple_trm_seq_assoc</span></a> : <span class="id" title="keyword">∀</span> <a id="t<sub>1</sub>:453" class="idref" href="#t<sub>1</sub>:453"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:454" class="idref" href="#t<sub>2</sub>:454"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="t<sub>3</sub>:455" class="idref" href="#t<sub>3</sub>:455"><span class="id" title="binder">t<sub>3</sub></span></a> <a id="H:456" class="idref" href="#H:456"><span class="id" title="binder">H</span></a> <a id="Q:457" class="idref" href="#Q:457"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_seq"><span class="id" title="constructor">trm_seq</span></a> (<a class="idref" href="LibSepReference.html#trm_seq"><span class="id" title="constructor">trm_seq</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:453"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:454"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Rules.html#t<sub>3</sub>:455"><span class="id" title="variable">t<sub>3</sub></span></a>) <a class="idref" href="Rules.html#H:456"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:457"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_seq"><span class="id" title="constructor">trm_seq</span></a> <a class="idref" href="Rules.html#t<sub>1</sub>:453"><span class="id" title="variable">t<sub>1</sub></span></a> (<a class="idref" href="LibSepReference.html#trm_seq"><span class="id" title="constructor">trm_seq</span></a> <a class="idref" href="Rules.html#t<sub>2</sub>:454"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="Rules.html#t<sub>3</sub>:455"><span class="id" title="variable">t<sub>3</sub></span></a>)) <a class="idref" href="Rules.html#H:456"><span class="id" title="variable">H</span></a> <a class="idref" href="Rules.html#Q:457"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 Such a change in the parenthesis structure of a sequence can be helfpul
    to apply the frame rule around <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span>;<span class="id" title="var">t<sub>2</sub></span></span>, for example. 
<div class="paragraph"> </div>

 Another useful application of the lemma <span class="inlinecode"><span class="id" title="var">triple_eval_like</span></span> appears in
    chapter <a href="Affine.html"><span class="inlineref">Affine</span></a>, for proving the equivalence of two versions of the
    garbage collection rule. 
</div>
<div class="code">

<span class="id" title="keyword">End</span> <a class="idref" href="Rules.html#ProofsSameSemantics"><span class="id" title="module">ProofsSameSemantics</span></a>.<br/>
</div>

<div class="doc">
<a id="lab217"></a><h2 class="section">Alternative Specification Style for Result Values.</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="MatchStyle" class="idref" href="#MatchStyle"><span class="id" title="module">MatchStyle</span></a>.<br/>
</div>

<div class="doc">
Recall the specification for the function <span class="inlinecode"><span class="id" title="var">ref</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="MatchStyle.triple_ref" class="idref" href="#MatchStyle.triple_ref"><span class="id" title="axiom">triple_ref</span></a> : <span class="id" title="keyword">∀</span> <a id="v:458" class="idref" href="#v:458"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_ref"><span class="id" title="constructor">val_ref</span></a> <a class="idref" href="Rules.html#v:458"><span class="id" title="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:459" class="idref" href="#r:459"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="p:460" class="idref" href="#p:460"><span class="id" title="binder">p</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Rules.html#r:459"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Rules.html#p:460"><span class="id" title="variable">p</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Rules.html#p:460"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:458"><span class="id" title="variable">v</span></a>).<br/>
</div>

<div class="doc">
Its postcondition could be equivalently stated by using, instead
    of an existential quantifier <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span>, a pattern matching. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="MatchStyle.triple_ref'" class="idref" href="#MatchStyle.triple_ref'"><span class="id" title="axiom">triple_ref'</span></a> : <span class="id" title="keyword">∀</span> <a id="v:462" class="idref" href="#v:462"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_ref"><span class="id" title="constructor">val_ref</span></a> <a class="idref" href="Rules.html#v:462"><span class="id" title="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:463" class="idref" href="#r:463"><span class="id" title="binder">r</span></a> ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="Rules.html#r:463"><span class="id" title="variable">r</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <span class="id" title="var">p</span> ⇒ (<span class="id" title="var">p</span> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Rules.html#v:462"><span class="id" title="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>
</div>

<div class="doc">
However, the pattern-matching presentation is less readable and
    would be fairly cumbersome to work with in practice. Thus, we
    systematically prefer using existentials. 
</div>
<div class="code">

<span class="id" title="keyword">End</span> <a class="idref" href="Rules.html#MatchStyle"><span class="id" title="module">MatchStyle</span></a>.<br/>
</div>

<div class="doc">
<a id="lab218"></a><h2 class="section">Historical Notes</h2>

<div class="paragraph"> </div>

 <a href="Bib.html#Gordon-1989"><span class="inlineref">[Gordon 1989]</span></a> presents the first mechanization of Hoare logic in a
    proof assistant, using the HOL tool. Gordon's pioneering work was followed
    by numerous formalizations of Hoare logic, targeting various programming
    languages.

<div class="paragraph"> </div>

    The original presentation of Separation Logic (1999-2001) consists of a set
    of rules written down on paper. These rules were not formally described in
    a proof assistant. Nevertheless, mechanized presentation of Separation Logic
    emerged a few years later.

<div class="paragraph"> </div>

    <a href="Bib.html#Yu,-Hamid, and Shao 2003"><span class="inlineref">[Yu, Hamid, and Shao 2003]</span></a> present the CAP framework for the
    verification in Coq of assembly-level code. This framework exploits
    separation logic style specifications, with predicate for lists and list
    segments involving the separating conjunction operator.

<div class="paragraph"> </div>

    In parallel, <a href="Bib.html#Weber-2004"><span class="inlineref">[Weber 2004]</span></a>, advised by Nipkow, developed the first
    mechanization of the rules of Separation Logic for a while language, using
    the Isabelle/HOL tool. His presentation is quite close from the original,
    paper presentation.

<div class="paragraph"> </div>

    Numerous mechanized presentations of Separation Logic, targeting various
    languages (assembly, C, core-Java, ML, etc.) and using various tools
    (Isabelle/HOL, Coq, PVS, HOL4, HOL). For a detailed list, as of 2020,
    we refer to Section 10.3 from the paper:
    <a href='http://www.chargueraud.org/research/2020/seq_seplogic/seq_seplogic.pdf'>http://www.chargueraud.org/research/2020/seq_seplogic/seq_seplogic.pdf</a>. 
</div>
<div class="code">

<span class="comment">(*&nbsp;2022-06-02&nbsp;21:12&nbsp;*)</span><br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>