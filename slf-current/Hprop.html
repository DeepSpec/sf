<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>Hprop: Heap Predicates</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/slf.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<div id="page">

<div id="header">
<div id='logoinheader'><a href='https://softwarefoundations.cis.upenn.edu'>
<img src='common/media/image/sf_logo_sm.png' alt='Software Foundations Logo'></a></div>
<div class='booktitleinheader'><a href='index.html'>Volume 6: Separation Logic Foundations</a></div>
<ul id='menu'>
   <li class='section_name'><a href='toc.html'>Table of Contents</a></li>
   <li class='section_name'><a href='coqindex.html'>Index</a></li>
   <li class='section_name'><a href='deps.html'>Roadmap</a></li>
</ul>
</div>

<div id="main">

<h1 class="libtitle">Hprop<span class="subtitle">Heap Predicates</span></h1>


<div class="code">

<span class="id" title="keyword">Set Implicit Arguments</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">SLF</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="LibSepReference.html#"><span class="id" title="library">LibSepReference</span></a>.<br/>
<span class="id" title="keyword">Import</span> <a class="idref" href="LibSepReference.html#ProgramSyntax"><span class="id" title="module">ProgramSyntax</span></a>.<br/>
</div>

<div class="doc">
<a id="lab96"></a><h1 class="section">First Pass</h1>

<div class="paragraph"> </div>

 The first two chapters have illustrated how to specify and verify programs
    using Separation Logic. The purpose of the coming chapters is to explain how
    to formally assign meaning to the tokens used in the statement of
    specifications (e.g., the star operator), formally define the notion of
    Separation Triples, and prove the reasoning rules of Separation Logic. These
    rules are exploited by the "x-tactics" used in the first two chapters. 
<div class="paragraph"> </div>

 This chapter presents the formal definitions of the key heap predicate
    operators from Separation Logic:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class='gray-font'>\</span>[]</span> denotes the empty heap predicate,

</li>
<li> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">P</span>]</span> denotes a pure fact,

</li>
<li> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">v</span></span> denotes a predicate that characterizes a singleton heap,

</li>
<li> <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> denotes the separating conjunction,

</li>
<li> <span class="inlinecode"><span class="id" title="var">Q<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*+</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> denotes the separating conjunction between a
                  postcondition and a heap predicate,

</li>
<li> <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">H</span></span> denotes an existential quantifier. 
</li>
</ul>

<div class="paragraph"> </div>

 To begin with, we define the types <span class="inlinecode"><span class="id" title="var">heap</span></span>, used to represent a memory state,
    or a piece of a memory state.

<div class="paragraph"> </div>

    In Separation Logic, specifications are expressed using "heap predicates",
    predicates over heaps, of type <span class="inlinecode"><span class="id" title="var">heap</span>→<span class="id" title="keyword">Prop</span></span>. We define <span class="inlinecode"><span class="id" title="var">hprop</span></span> to be a
    shorthand for that type.

<div class="paragraph"> </div>

    By convention, throughout the course:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">H</span></span> denotes a heap predicate of type <span class="inlinecode"><span class="id" title="var">hprop</span></span>; it describes a
      piece of state,

</li>
<li> <span class="inlinecode"><span class="id" title="var">Q</span></span> denotes a postcondition, of type <span class="inlinecode"><span class="id" title="var">val</span>→<span class="id" title="var">hprop</span></span>; it describes
      both a result value and a piece of state. 

</li>
</ul>
</div>

<div class="doc">
<a id="lab97"></a><h2 class="section">Description of Memory States</h2>

<div class="paragraph"> </div>

 To reason about imperative programs, Separation Logic relies on heap
    predicates for describing memory states. As the name suggests, a "heap
    predicate" is a predicate over heaps, i.e., over memory states. Heap
    predicates such as <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>, or <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> admit the type <span class="inlinecode"><span class="id" title="var">heap</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>,
    where the type <span class="inlinecode"><span class="id" title="var">heap</span></span> corresponds to a finite map used to describe the
    contents of a piece of the memory. In what follows, we give the formal
    definition of <span class="inlinecode"><span class="id" title="var">heap</span></span> and of the type of heap predicates. 
<div class="paragraph"> </div>

 In the previous chapters, we have assumed a type <span class="inlinecode"><span class="id" title="var">val</span></span> to range over program
    values and a type <span class="inlinecode"><span class="id" title="var">loc</span></span> to denote memory locations. Concrete definitions
    will be provided later on, in chapter <a href="Rules.html"><span class="inlineref">Rules</span></a>. At this point, we are
    interested in the definition of the type <span class="inlinecode"><span class="id" title="var">heap</span></span>, used to describe the
    contents of the memory during the execution of a program. 
<div class="paragraph"> </div>

 A <span class="inlinecode"><span class="id" title="var">heap</span></span> is a finite map from locations to values. The file <span class="inlinecode"><span class="id" title="var">LibSepFmap.v</span></span>
    provides a self-contained formalization of finite maps. An object of type
    <span class="inlinecode"><span class="id" title="var">fmap</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> represents a finite map binding keys of type <span class="inlinecode"><span class="id" title="var">A</span></span> to values of
    type <span class="inlinecode"><span class="id" title="var">B</span></span>. We define the type <span class="inlinecode"><span class="id" title="var">heap</span></span> as a map from locations, of type <span class="inlinecode"><span class="id" title="var">loc</span></span>,
    to program values, of type <span class="inlinecode"><span class="id" title="var">val</span></span>. Internally, <span class="inlinecode"><span class="id" title="var">fmap</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> is implemented as a
    function of type <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>, like in <span class="inlinecode"><span class="id" title="var">Maps.v</span></span> from the LF volume. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="heap" class="idref" href="#heap"><span class="id" title="definition">heap</span></a> : <span class="id" title="keyword">Type</span> := <a class="idref" href="LibSepFmap.html#fmap"><span class="id" title="record">fmap</span></a> <a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a> <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a>.<br/>
</div>

<div class="doc">
The file <span class="inlinecode"><span class="id" title="var">LibSepReference</span></span> introduces the module name <span class="inlinecode"><span class="id" title="var">Fmap</span></span> as a shorthand
    for <span class="inlinecode"><span class="id" title="var">LibSepFmap</span></span>. The key operations associated with finite maps are:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">Fmap.empty</span></span> denotes the empty state,

</li>
<li> <span class="inlinecode"><span class="id" title="var">Fmap.single</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> denotes a singleton state, that is, a unique cell
      at location <span class="inlinecode"><span class="id" title="var">p</span></span> with contents <span class="inlinecode"><span class="id" title="var">v</span></span>,

</li>
<li> <span class="inlinecode"><span class="id" title="var">Fmap.union</span></span> <span class="inlinecode"><span class="id" title="var">h<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">h<sub>2</sub></span></span> denotes the union of the two states <span class="inlinecode"><span class="id" title="var">h<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" title="var">h<sub>2</sub></span></span>.

</li>
<li> <span class="inlinecode"><span class="id" title="var">Fmap.disjoint</span></span> <span class="inlinecode"><span class="id" title="var">h<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">h<sub>2</sub></span></span> asserts that <span class="inlinecode"><span class="id" title="var">h<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" title="var">h<sub>2</sub></span></span> have disjoint domains.

</li>
</ul>

<div class="paragraph"> </div>

    Note that the union operation is commutative only when its arguments have
    disjoint domains. Throughout the course, we only consider disjoint unions,
    for which commutativity holds.

<div class="paragraph"> </div>

    Hereafter, to improve readability of statements in proofs, we introduce the
    notation <span class="inlinecode"><span class="id" title="var">h<sub>1</sub></span></span> <span class="inlinecode">\<span class="id" title="var">u</span></span> <span class="inlinecode"><span class="id" title="var">h<sub>2</sub></span></span> for heap union. 
</div>
<div class="code">

<span class="id" title="keyword">Notation</span> <a id="11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>" class="idref" href="#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">&quot;</span></a>h<sub>1</sub> \u h<sub>2</sub>" := (<a class="idref" href="LibSepReference.html#Fmap.union"><span class="id" title="definition">Fmap.union</span></a> <span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>2</sub></span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 37, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>).<br/>
</div>

<div class="doc">
<a id="lab98"></a><h2 class="section">Heap Predicates</h2>

<div class="paragraph"> </div>

 In Separation Logic, the state is described using "heap predicates", of type
    <span class="inlinecode"><span class="id" title="var">hprop</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="hprop" class="idref" href="#hprop"><span class="id" title="definition">hprop</span></a> := <a class="idref" href="Hprop.html#heap"><span class="id" title="definition">heap</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">H</span></span> ranges over heap predicates. 
</div>
<div class="code">

<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Type</span> <span class="id" title="var">H</span> : <a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a>.<br/>
</div>

<div class="doc">
An essential aspect of Separation Logic is that all heap predicates defined
    and used in practice are built using a few basic combinators. In other
    words, except for the definition of the combinators themselves, we will
    never define a custom heap predicate directly as a function of the state. 
<div class="paragraph"> </div>

 We next describe the most important combinators, which were used pervasively
    throughout the first two chapters. 
<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" title="var">hempty</span></span> predicate, usually written <span class="inlinecode"><span class='gray-font'>\</span>[]</span>, characterizes an empty heap.
    
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="hempty" class="idref" href="#hempty"><span class="id" title="definition">hempty</span></a> : <a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<a id="h:1" class="idref" href="#h:1"><span class="id" title="binder">h</span></a>:<a class="idref" href="Hprop.html#heap"><span class="id" title="definition">heap</span></a>) ⇒ (<a class="idref" href="Hprop.html#h:1"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#Fmap.empty"><span class="id" title="definition">Fmap.empty</span></a>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> <a id="cb6b4bc70cb30142f9711e4deb4cb93a" class="idref" href="#cb6b4bc70cb30142f9711e4deb4cb93a"><span class="id" title="notation">&quot;</span></a><span class='gray-font'>\</span>[]" := (<a class="idref" href="Hprop.html#hempty"><span class="id" title="definition">hempty</span></a>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0).<br/>
</div>

<div class="doc">
The pure fact predicate, written <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">P</span>]</span>, characterizes an empty state and
    moreover asserts that the proposition <span class="inlinecode"><span class="id" title="var">P</span></span> is true. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="hpure" class="idref" href="#hpure"><span class="id" title="definition">hpure</span></a> (<a id="P:2" class="idref" href="#P:2"><span class="id" title="binder">P</span></a>:<span class="id" title="keyword">Prop</span>) : <a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<a id="h:3" class="idref" href="#h:3"><span class="id" title="binder">h</span></a>:<a class="idref" href="Hprop.html#heap"><span class="id" title="definition">heap</span></a>) ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#h:3"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#Fmap.empty"><span class="id" title="definition">Fmap.empty</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="Hprop.html#P:2"><span class="id" title="variable">P</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> <a id="53316c5a9a53e765aefbae8243c4b1dc" class="idref" href="#53316c5a9a53e765aefbae8243c4b1dc"><span class="id" title="notation">&quot;</span></a><span class='gray-font'>\</span>[ P ]" := (<a class="idref" href="Hprop.html#hpure"><span class="id" title="definition">hpure</span></a> <span class="id" title="var">P</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span> "<span class='gray-font'>\</span>[ P ]").<br/>
</div>

<div class="doc">
The singleton heap predicate, written <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">v</span></span>, characterizes a state with
    a single allocated cell, at location <span class="inlinecode"><span class="id" title="var">p</span></span>, storing the value <span class="inlinecode"><span class="id" title="var">v</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="hsingle" class="idref" href="#hsingle"><span class="id" title="definition">hsingle</span></a> (<a id="p:4" class="idref" href="#p:4"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="v:5" class="idref" href="#v:5"><span class="id" title="binder">v</span></a>:<a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a>) : <a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<a id="h:6" class="idref" href="#h:6"><span class="id" title="binder">h</span></a>:<a class="idref" href="Hprop.html#heap"><span class="id" title="definition">heap</span></a>) ⇒ (<a class="idref" href="Hprop.html#h:6"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#Fmap.single"><span class="id" title="definition">Fmap.single</span></a> <a class="idref" href="Hprop.html#p:4"><span class="id" title="variable">p</span></a> <a class="idref" href="Hprop.html#v:5"><span class="id" title="variable">v</span></a>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> <a id="7322bfa5d36ce5cf12f68db819774432" class="idref" href="#7322bfa5d36ce5cf12f68db819774432"><span class="id" title="notation">&quot;</span></a>p '~~&gt;' v" := (<a class="idref" href="Hprop.html#hsingle"><span class="id" title="definition">hsingle</span></a> <span class="id" title="var">p</span> <span class="id" title="var">v</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 32).<br/>
</div>

<div class="doc">
The "separating conjunction", written <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span>, characterizes a state that
    can be decomposed in two disjoint parts, one that satisfies <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> and another
    that satisfies <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="hstar" class="idref" href="#hstar"><span class="id" title="definition">hstar</span></a> (<a id="H<sub>1</sub>:7" class="idref" href="#H<sub>1</sub>:7"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:8" class="idref" href="#H<sub>2</sub>:8"><span class="id" title="binder">H<sub>2</sub></span></a> : <a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a>) : <a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<a id="h:9" class="idref" href="#h:9"><span class="id" title="binder">h</span></a>:<a class="idref" href="Hprop.html#heap"><span class="id" title="definition">heap</span></a>) ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">∃</span></a> <a id="h<sub>1</sub>:10" class="idref" href="#h<sub>1</sub>:10"><span class="id" title="binder">h<sub>1</sub></span></a> <a id="h<sub>2</sub>:11" class="idref" href="#h<sub>2</sub>:11"><span class="id" title="binder">h<sub>2</sub></span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Hprop.html#H<sub>1</sub>:7"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#h<sub>1</sub>:10"><span class="id" title="variable">h<sub>1</sub></span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:8"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="Hprop.html#h<sub>2</sub>:11"><span class="id" title="variable">h<sub>2</sub></span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="LibSepReference.html#Fmap.disjoint"><span class="id" title="definition">Fmap.disjoint</span></a> <a class="idref" href="Hprop.html#h<sub>1</sub>:10"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="Hprop.html#h<sub>2</sub>:11"><span class="id" title="variable">h<sub>2</sub></span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="Hprop.html#h:9"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#h<sub>1</sub>:10"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="Hprop.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">\</span></a><a class="idref" href="Hprop.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">u</span></a> <a class="idref" href="Hprop.html#h<sub>2</sub>:11"><span class="id" title="variable">h<sub>2</sub></span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> <a id="1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>" class="idref" href="#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">&quot;</span></a>H<sub>1</sub> '<span class='gray-font'>\</span>*' H<sub>2</sub>" := (<a class="idref" href="Hprop.html#hstar"><span class="id" title="definition">hstar</span></a> <span class="id" title="var">H<sub>1</sub></span> <span class="id" title="var">H<sub>2</sub></span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 41, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>).<br/>
</div>

<div class="doc">
The existential quantifier for heap predicates, written <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">H</span></span>
    characterizes a heap that satisfies <span class="inlinecode"><span class="id" title="var">H</span></span> for some <span class="inlinecode"><span class="id" title="var">x</span></span>. The variable <span class="inlinecode"><span class="id" title="var">x</span></span> has
    type <span class="inlinecode"><span class="id" title="var">A</span></span>, for some arbitrary <span class="inlinecode"><span class="id" title="var">A</span></span>. 
<div class="paragraph"> </div>

 The notation <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">H</span></span> stands for <span class="inlinecode"><span class="id" title="var">hexists</span></span> <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">H</span>)</span>. The
    generalized notation <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x<sub>1</sub></span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">xn</span>,</span> <span class="inlinecode"><span class="id" title="var">H</span></span> is also available.

<div class="paragraph"> </div>

    The definition of <span class="inlinecode"><span class="id" title="var">hexists</span></span> is a bit technical, and it is not essential to
    master it at this point. Additional explanations are provided near the end
    of this chapter. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="hexists" class="idref" href="#hexists"><span class="id" title="definition">hexists</span></a> (<a id="A:12" class="idref" href="#A:12"><span class="id" title="binder">A</span></a>:<span class="id" title="keyword">Type</span>) (<a id="J:13" class="idref" href="#J:13"><span class="id" title="binder">J</span></a>:<a class="idref" href="Hprop.html#A:12"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a>) : <a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<a id="h:14" class="idref" href="#h:14"><span class="id" title="binder">h</span></a>:<a class="idref" href="Hprop.html#heap"><span class="id" title="definition">heap</span></a>) ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">∃</span></a> <a id="x:15" class="idref" href="#x:15"><span class="id" title="binder">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Hprop.html#J:13"><span class="id" title="variable">J</span></a> <a class="idref" href="Hprop.html#x:15"><span class="id" title="variable">x</span></a> <a class="idref" href="Hprop.html#h:14"><span class="id" title="variable">h</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> <a id="427157b8047cdf158af6c4e7232eb7ce" class="idref" href="#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">&quot;</span></a>'\exists' x<sub>1</sub> .. xn , H" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Hprop.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <a id="x<sub>1</sub>:16" class="idref" href="#x<sub>1</sub>:16"><span class="id" title="binder">x<sub>1</sub></span></a> ⇒ .. (<a class="idref" href="Hprop.html#hexists"><span class="id" title="definition">hexists</span></a> (<span class="id" title="keyword">fun</span> <a id="xn:17" class="idref" href="#xn:17"><span class="id" title="binder">xn</span></a> ⇒ <span class="id" title="var">H</span>)) ..))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 39, <span class="id" title="var">x<sub>1</sub></span> <span class="id" title="var">binder</span>, <span class="id" title="var">H</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "'[' '\exists' '/ '  x<sub>1</sub>  ..  xn , '/ '  H ']'").<br/>
</div>

<div class="doc">
Universal quantification in <span class="inlinecode"><span class="id" title="var">hprop</span></span> is also possible, but it is only useful
    for more advanced features of Separation Logic. We postpone its introduction
    to chapter <a href="Wand.html"><span class="inlineref">Wand</span></a>. 
<div class="paragraph"> </div>

 All the definitions above will eventually be made <span class="inlinecode"><span class="id" title="keyword">Opaque</span></span>, after the
    appropriate introduction and elimination lemmas have been established,
    making it no longer possible to execute, say, <span class="inlinecode"><span class="id" title="tactic">unfold</span></span> <span class="inlinecode"><span class="id" title="var">hstar</span></span>. Opacity is
    essential to ensure that proofs do not depend on the details of the
    definitions. 
</div>

<div class="doc">
<a id="lab99"></a><h2 class="section">Extensionality for Heap Predicates</h2>

<div class="paragraph"> </div>

 To work in Separation Logic, it is extremely convenient to be able to state
    equalities between heap predicates. For example, we wish to establish the
    associativity property for the star operator in the form of an equality: 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="hstar_assoc_statement" class="idref" href="#hstar_assoc_statement"><span class="id" title="axiom">hstar_assoc_statement</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:18" class="idref" href="#H<sub>1</sub>:18"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:19" class="idref" href="#H<sub>2</sub>:19"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="H<sub>3</sub>:20" class="idref" href="#H<sub>3</sub>:20"><span class="id" title="binder">H<sub>3</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#H<sub>1</sub>:18"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:19"><span class="id" title="variable">H<sub>2</sub></span></a><a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">)</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>3</sub>:20"><span class="id" title="variable">H<sub>3</sub></span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#H<sub>1</sub>:18"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#H<sub>2</sub>:19"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>3</sub>:20"><span class="id" title="variable">H<sub>3</sub></span></a><a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">)</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
How can we prove a goal of the form <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> when <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> have type
    <span class="inlinecode"><span class="id" title="var">hprop</span></span>, that is, <span class="inlinecode"><span class="id" title="var">heap</span>→<span class="id" title="keyword">Prop</span></span>? Intuitively, <span class="inlinecode"><span class="id" title="var">H</span></span> and <span class="inlinecode"><span class="id" title="var">H'</span></span> are equal if and
    only if they characterize exactly the same set of heaps, that is, if
    <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode">(<span class="id" title="var">h</span>:<span class="id" title="var">heap</span>),</span> <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode">↔</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> <span class="inlinecode"><span class="id" title="var">h</span></span>.

<div class="paragraph"> </div>

    This reasoning principle, a specific form of extensionality property, is not
    available by default in Coq. But we can safely assume it if we extend the
    logic of Coq with a standard axiom called "predicate extensionality". 
</div>
<div class="code">

<span class="id" title="keyword">Axiom</span> <a id="predicate_extensionality" class="idref" href="#predicate_extensionality"><span class="id" title="axiom">predicate_extensionality</span></a> : <span class="id" title="keyword">∀</span> (<a id="A:22" class="idref" href="#A:22"><span class="id" title="binder">A</span></a>:<span class="id" title="keyword">Type</span>) (<a id="P:23" class="idref" href="#P:23"><span class="id" title="binder">P</span></a> <a id="Q:24" class="idref" href="#Q:24"><span class="id" title="binder">Q</span></a>:<a class="idref" href="Hprop.html#A:22"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="x:25" class="idref" href="#x:25"><span class="id" title="binder">x</span></a>, <a class="idref" href="Hprop.html#P:23"><span class="id" title="variable">P</span></a> <a class="idref" href="Hprop.html#x:25"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="Hprop.html#Q:24"><span class="id" title="variable">Q</span></a> <a class="idref" href="Hprop.html#x:25"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#P:23"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#Q:24"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
By specializing <span class="inlinecode"><span class="id" title="var">P</span></span> and <span class="inlinecode"><span class="id" title="var">Q</span></span> above to the type <span class="inlinecode"><span class="id" title="var">hprop</span></span>, we obtain exactly the
    desired extensionality principle. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="hprop_eq" class="idref" href="#hprop_eq"><span class="id" title="lemma">hprop_eq</span></a> : <span class="id" title="keyword">∀</span> (<a id="H<sub>1</sub>:27" class="idref" href="#H<sub>1</sub>:27"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:28" class="idref" href="#H<sub>2</sub>:28"><span class="id" title="binder">H<sub>2</sub></span></a>:<a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> (<a id="h:29" class="idref" href="#h:29"><span class="id" title="binder">h</span></a>:<a class="idref" href="Hprop.html#heap"><span class="id" title="definition">heap</span></a>), <a class="idref" href="Hprop.html#H<sub>1</sub>:27"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#h:29"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:28"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="Hprop.html#h:29"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#H<sub>1</sub>:27"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:28"><span class="id" title="variable">H<sub>2</sub></span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="Hprop.html#predicate_extensionality"><span class="id" title="axiom">predicate_extensionality</span></a>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
More information about extensionality axioms may be found near the end of
    this chapter. 
</div>

<div class="doc">
<a id="lab100"></a><h2 class="section">Fundamental Properties of Operators</h2>

<div class="paragraph"> </div>

 By exploiting extensionality, the following properties of Separation Logic
    operators can be established (they are proved further on in the chapter). 
<div class="paragraph"> </div>

 (1) The star operator is associative. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="hstar_assoc" class="idref" href="#hstar_assoc"><span class="id" title="axiom">hstar_assoc</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:30" class="idref" href="#H<sub>1</sub>:30"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:31" class="idref" href="#H<sub>2</sub>:31"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="H<sub>3</sub>:32" class="idref" href="#H<sub>3</sub>:32"><span class="id" title="binder">H<sub>3</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#H<sub>1</sub>:30"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:31"><span class="id" title="variable">H<sub>2</sub></span></a><a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">)</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>3</sub>:32"><span class="id" title="variable">H<sub>3</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#H<sub>1</sub>:30"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#H<sub>2</sub>:31"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>3</sub>:32"><span class="id" title="variable">H<sub>3</sub></span></a><a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
(2) The star operator is commutative. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="hstar_comm" class="idref" href="#hstar_comm"><span class="id" title="axiom">hstar_comm</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:34" class="idref" href="#H<sub>1</sub>:34"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:35" class="idref" href="#H<sub>2</sub>:35"><span class="id" title="binder">H<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Hprop.html#H<sub>1</sub>:34"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:35"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:35"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>1</sub>:34"><span class="id" title="variable">H<sub>1</sub></span></a>.<br/>
</div>

<div class="doc">
(3) The empty heap predicate is a neutral element for the star.

<div class="paragraph"> </div>

    Because star is commutative, it is equivalent to state that <span class="inlinecode"><span class="id" title="var">hempty</span></span> is a
    left or a right neutral element for <span class="inlinecode"><span class="id" title="var">hstar</span></span>. We choose, arbitrarily, to
    state the left-neutrality property. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="hstar_hempty_l" class="idref" href="#hstar_hempty_l"><span class="id" title="axiom">hstar_hempty_l</span></a> : <span class="id" title="keyword">∀</span> <a id="H:37" class="idref" href="#H:37"><span class="id" title="binder">H</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#cb6b4bc70cb30142f9711e4deb4cb93a"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H:37"><span class="id" title="variable">H</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#H:37"><span class="id" title="variable">H</span></a>.<br/>
</div>

<div class="doc">
(4) Existentials can be "extruded" out of stars, that is:
    <span class="inlinecode">(<span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">J</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H</span></span> is equivalent to <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode">(<span class="id" title="var">J</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H</span>)</span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="hstar_hexists" class="idref" href="#hstar_hexists"><span class="id" title="axiom">hstar_hexists</span></a> : <span class="id" title="keyword">∀</span> <a id="A:39" class="idref" href="#A:39"><span class="id" title="binder">A</span></a> (<a id="J:40" class="idref" href="#J:40"><span class="id" title="binder">J</span></a>:<a class="idref" href="Hprop.html#A:39"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a>) <a id="H:41" class="idref" href="#H:41"><span class="id" title="binder">H</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">\</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">∃</span></a> <a id="x:42" class="idref" href="#x:42"><span class="id" title="binder">x</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">,</span></a> <a class="idref" href="Hprop.html#J:40"><span class="id" title="variable">J</span></a> <a class="idref" href="Hprop.html#x:42"><span class="id" title="variable">x</span></a><a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">)</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H:41"><span class="id" title="variable">H</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">\</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">∃</span></a> <a id="x:43" class="idref" href="#x:43"><span class="id" title="binder">x</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">,</span></a> <a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#J:40"><span class="id" title="variable">J</span></a> <a class="idref" href="Hprop.html#x:43"><span class="id" title="variable">x</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H:41"><span class="id" title="variable">H</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
(5) Pure facts can be extruded out of stars. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="hstar_hpure_l" class="idref" href="#hstar_hpure_l"><span class="id" title="axiom">hstar_hpure_l</span></a> : <span class="id" title="keyword">∀</span> <a id="P:45" class="idref" href="#P:45"><span class="id" title="binder">P</span></a> <a id="H:46" class="idref" href="#H:46"><span class="id" title="binder">H</span></a> <a id="h:47" class="idref" href="#h:47"><span class="id" title="binder">h</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#53316c5a9a53e765aefbae8243c4b1dc"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Hprop.html#P:45"><span class="id" title="variable">P</span></a><a class="idref" href="Hprop.html#53316c5a9a53e765aefbae8243c4b1dc"><span class="id" title="notation">]</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H:46"><span class="id" title="variable">H</span></a><a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">)</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#P:45"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="Hprop.html#H:46"><span class="id" title="variable">H</span></a> <a class="idref" href="Hprop.html#h:47"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
<a id="lab101"></a><h2 class="section">Postconditions: Type, Syntax, and Extensionality</h2>

<div class="paragraph"> </div>

 A specification takes the form <span class="inlinecode"><span class="id" title="var">triple</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span>, where <span class="inlinecode"><span class="id" title="var">t</span></span> is a term, <span class="inlinecode"><span class="id" title="var">H</span></span> is a
    precondition of type <span class="inlinecode"><span class="id" title="var">hprop</span></span>, and <span class="inlinecode"><span class="id" title="var">Q</span></span> is a postcondition.

<div class="paragraph"> </div>

    For example, a read at location <span class="inlinecode"><span class="id" title="var">p</span></span>, written <span class="inlinecode">!<span class="id" title="var">p</span></span> in OCaml, is specified as:
    <span class="inlinecode"><span class="id" title="var">triple</span></span> <span class="inlinecode">&lt;{</span> <span class="inlinecode">!<span class="id" title="var">p</span></span> <span class="inlinecode">}&gt;</span> <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">v</span>)</span> <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">v</span>)</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">v</span>])</span>.

<div class="paragraph"> </div>

    In general, a postcondition has type <span class="inlinecode"><span class="id" title="var">val</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">hprop</span></span>, which is equivalent to
    <span class="inlinecode"><span class="id" title="var">val</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">heap</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. The postcondition thereby capture the properties of
    both the output value and the output state. 
</div>
<div class="code">

<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Type</span> <span class="id" title="var">Q</span> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a>.<br/>
</div>

<div class="doc">
One common operation is augmenting a postcondition with a description of
    another piece of state. This operation is written as <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*+</span> <span class="inlinecode"><span class="id" title="var">H</span></span>, which is
    just a convenient notation for <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode">(<span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H</span>)</span>. We will use this
    operator in particular in the statement of the frame rule in the next
    chapter. 
</div>
<div class="code">

<span class="id" title="keyword">Notation</span> <a id="9c07dc3fe866f600abcbb5cdf7c0a7fa" class="idref" href="#9c07dc3fe866f600abcbb5cdf7c0a7fa"><span class="id" title="notation">&quot;</span></a>Q <span class='gray-font'>\</span>*+ H" := (<span class="id" title="keyword">fun</span> <a id="x:49" class="idref" href="#x:49"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="Hprop.html#hstar"><span class="id" title="definition">hstar</span></a> (<span class="id" title="var">Q</span> <a class="idref" href="Hprop.html#x:49"><span class="id" title="variable">x</span></a>) <span class="id" title="var">H</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 40).<br/>
</div>

<div class="doc">
Intuitively, in order to prove that two postconditions <span class="inlinecode"><span class="id" title="var">Q<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" title="var">Q<sub>2</sub></span></span> are
    equal, it suffices to show that the heap predicates <span class="inlinecode"><span class="id" title="var">Q<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> and <span class="inlinecode"><span class="id" title="var">Q<sub>2</sub></span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> are
    equal for any value <span class="inlinecode"><span class="id" title="var">v</span></span>.

<div class="paragraph"> </div>

    Again, the extensionality property that we need is not built into Coq. We
    need another axiom called "functional extensionality". 
</div>
<div class="code">

<span class="id" title="keyword">Axiom</span> <a id="functional_extensionality" class="idref" href="#functional_extensionality"><span class="id" title="axiom">functional_extensionality</span></a> : <span class="id" title="keyword">∀</span> <a id="A:50" class="idref" href="#A:50"><span class="id" title="binder">A</span></a> <a id="B:51" class="idref" href="#B:51"><span class="id" title="binder">B</span></a> (<a id="f:52" class="idref" href="#f:52"><span class="id" title="binder">f</span></a> <a id="g:53" class="idref" href="#g:53"><span class="id" title="binder">g</span></a>:<a class="idref" href="Hprop.html#A:50"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="Hprop.html#B:51"><span class="id" title="variable">B</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="x:54" class="idref" href="#x:54"><span class="id" title="binder">x</span></a>, <a class="idref" href="Hprop.html#f:52"><span class="id" title="variable">f</span></a> <a class="idref" href="Hprop.html#x:54"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#g:53"><span class="id" title="variable">g</span></a> <a class="idref" href="Hprop.html#x:54"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#f:52"><span class="id" title="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#g:53"><span class="id" title="variable">g</span></a>.<br/>
</div>

<div class="doc">
The desired equality property for postconditions follows directly from this
    axiom. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="qprop_eq" class="idref" href="#qprop_eq"><span class="id" title="lemma">qprop_eq</span></a> : <span class="id" title="keyword">∀</span> (<a id="Q<sub>1</sub>:56" class="idref" href="#Q<sub>1</sub>:56"><span class="id" title="binder">Q<sub>1</sub></span></a> <a id="Q<sub>2</sub>:57" class="idref" href="#Q<sub>2</sub>:57"><span class="id" title="binder">Q<sub>2</sub></span></a>:<a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> (<a id="v:58" class="idref" href="#v:58"><span class="id" title="binder">v</span></a>:<a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a>), <a class="idref" href="Hprop.html#Q<sub>1</sub>:56"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="Hprop.html#v:58"><span class="id" title="variable">v</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#Q<sub>2</sub>:57"><span class="id" title="variable">Q<sub>2</sub></span></a> <a class="idref" href="Hprop.html#v:58"><span class="id" title="variable">v</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#Q<sub>1</sub>:56"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#Q<sub>2</sub>:57"><span class="id" title="variable">Q<sub>2</sub></span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="Hprop.html#functional_extensionality"><span class="id" title="axiom">functional_extensionality</span></a>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab102"></a><h2 class="section">Introduction and Inversion Lemmas for Basic Operators</h2>

<div class="paragraph"> </div>

 This section presents a collection of lemmas capturing the properties of the
    definitions of heap predicates. They include "introduction lemmas" for
    proving goals of the form <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span>, and "inversion lemmas" for extracting
    information from hypotheses of the form <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span>. These lemmas will be
    exploited pervasively in the next chapters for establishing reasoning rules.
    
</div>
<div class="code">

<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">v</span> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a>.<br/>
</div>

<div class="doc">
The introduction lemmas show how to prove goals of the form <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span>, for
    various forms of the heap predicate <span class="inlinecode"><span class="id" title="var">H</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="hempty_intro" class="idref" href="#hempty_intro"><span class="id" title="lemma">hempty_intro</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#cb6b4bc70cb30142f9711e4deb4cb93a"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a> <a class="idref" href="Hprop.html#cb6b4bc70cb30142f9711e4deb4cb93a"><span class="id" title="notation">Fmap.empty</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
</div>

<div class="doc">
The tactic <span class="inlinecode"><span class="id" title="tactic">hnf</span></span>, for "head normal form", unfolds the head constants. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">hnf</span>. <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="hpure_intro" class="idref" href="#hpure_intro"><span class="id" title="lemma">hpure_intro</span></a> : <span class="id" title="keyword">∀</span> <a id="P:59" class="idref" href="#P:59"><span class="id" title="binder">P</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#P:59"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#53316c5a9a53e765aefbae8243c4b1dc"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Hprop.html#P:59"><span class="id" title="variable">P</span></a><a class="idref" href="Hprop.html#53316c5a9a53e765aefbae8243c4b1dc"><span class="id" title="notation">]</span></a> <a class="idref" href="Hprop.html#53316c5a9a53e765aefbae8243c4b1dc"><span class="id" title="notation">Fmap.empty</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">hnf</span>. <span class="id" title="tactic">auto</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="hsingle_intro" class="idref" href="#hsingle_intro"><span class="id" title="lemma">hsingle_intro</span></a> : <span class="id" title="keyword">∀</span> <a id="p:60" class="idref" href="#p:60"><span class="id" title="binder">p</span></a> <a id="v:61" class="idref" href="#v:61"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#7322bfa5d36ce5cf12f68db819774432"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#p:60"><span class="id" title="variable">p</span></a> <a class="idref" href="Hprop.html#7322bfa5d36ce5cf12f68db819774432"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Hprop.html#v:61"><span class="id" title="variable">v</span></a><a class="idref" href="Hprop.html#7322bfa5d36ce5cf12f68db819774432"><span class="id" title="notation">)</span></a> <a class="idref" href="Hprop.html#7322bfa5d36ce5cf12f68db819774432"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#7322bfa5d36ce5cf12f68db819774432"><span class="id" title="notation">Fmap.single</span></a> <a class="idref" href="Hprop.html#7322bfa5d36ce5cf12f68db819774432"><span class="id" title="notation">p</span></a> <a class="idref" href="Hprop.html#7322bfa5d36ce5cf12f68db819774432"><span class="id" title="notation">v</span></a><a class="idref" href="Hprop.html#7322bfa5d36ce5cf12f68db819774432"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">hnf</span>. <span class="id" title="tactic">auto</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="hstar_intro" class="idref" href="#hstar_intro"><span class="id" title="lemma">hstar_intro</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:62" class="idref" href="#H<sub>1</sub>:62"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:63" class="idref" href="#H<sub>2</sub>:63"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="h<sub>1</sub>:64" class="idref" href="#h<sub>1</sub>:64"><span class="id" title="binder">h<sub>1</sub></span></a> <a id="h<sub>2</sub>:65" class="idref" href="#h<sub>2</sub>:65"><span class="id" title="binder">h<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#H<sub>1</sub>:62"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#h<sub>1</sub>:64"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#H<sub>2</sub>:63"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="Hprop.html#h<sub>2</sub>:65"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.disjoint"><span class="id" title="definition">Fmap.disjoint</span></a> <a class="idref" href="Hprop.html#h<sub>1</sub>:64"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="Hprop.html#h<sub>2</sub>:65"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#H<sub>1</sub>:62"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:63"><span class="id" title="variable">H<sub>2</sub></span></a><a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">)</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">h<sub>1</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">\</span></a><a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">u</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">h<sub>2</sub></span></a><a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">∃</span>* <span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>2</sub></span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="hexists_intro" class="idref" href="#hexists_intro"><span class="id" title="lemma">hexists_intro</span></a> : <span class="id" title="keyword">∀</span> <a id="A:66" class="idref" href="#A:66"><span class="id" title="binder">A</span></a> (<a id="x:67" class="idref" href="#x:67"><span class="id" title="binder">x</span></a>:<a class="idref" href="Hprop.html#A:66"><span class="id" title="variable">A</span></a>) (<a id="J:68" class="idref" href="#J:68"><span class="id" title="binder">J</span></a>:<a class="idref" href="Hprop.html#A:66"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a>) <a id="h:69" class="idref" href="#h:69"><span class="id" title="binder">h</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#J:68"><span class="id" title="variable">J</span></a> <a class="idref" href="Hprop.html#x:67"><span class="id" title="variable">x</span></a> <a class="idref" href="Hprop.html#h:69"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">(\</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">∃</span></a> <a id="x:70" class="idref" href="#x:70"><span class="id" title="binder">x</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">,</span></a> <a class="idref" href="Hprop.html#J:68"><span class="id" title="variable">J</span></a> <a class="idref" href="Hprop.html#x:70"><span class="id" title="variable">x</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">)</span></a> <a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">h</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">hnf</span>. <span class="id" title="tactic">eauto</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The inversion lemmas show how to extract information from hypotheses of the
    form <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span>, for various forms of the heap predicate <span class="inlinecode"><span class="id" title="var">H</span></span>.
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="hempty_inv" class="idref" href="#hempty_inv"><span class="id" title="lemma">hempty_inv</span></a> : <span class="id" title="keyword">∀</span> <a id="h:71" class="idref" href="#h:71"><span class="id" title="binder">h</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#cb6b4bc70cb30142f9711e4deb4cb93a"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a> <a class="idref" href="Hprop.html#cb6b4bc70cb30142f9711e4deb4cb93a"><span class="id" title="notation">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#h:71"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#Fmap.empty"><span class="id" title="definition">Fmap.empty</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">hnf</span> <span class="id" title="keyword">in</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">auto</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="hpure_inv" class="idref" href="#hpure_inv"><span class="id" title="lemma">hpure_inv</span></a> : <span class="id" title="keyword">∀</span> <a id="P:72" class="idref" href="#P:72"><span class="id" title="binder">P</span></a> <a id="h:73" class="idref" href="#h:73"><span class="id" title="binder">h</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#53316c5a9a53e765aefbae8243c4b1dc"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Hprop.html#P:72"><span class="id" title="variable">P</span></a><a class="idref" href="Hprop.html#53316c5a9a53e765aefbae8243c4b1dc"><span class="id" title="notation">]</span></a> <a class="idref" href="Hprop.html#53316c5a9a53e765aefbae8243c4b1dc"><span class="id" title="notation">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#P:72"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="Hprop.html#h:73"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#Fmap.empty"><span class="id" title="definition">Fmap.empty</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">hnf</span> <span class="id" title="keyword">in</span> <span class="id" title="var">M</span>. <span class="id" title="var">autos</span>*. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="hsingle_inv" class="idref" href="#hsingle_inv"><span class="id" title="lemma">hsingle_inv</span></a>: <span class="id" title="keyword">∀</span> <a id="p:74" class="idref" href="#p:74"><span class="id" title="binder">p</span></a> <a id="v:75" class="idref" href="#v:75"><span class="id" title="binder">v</span></a> <a id="h:76" class="idref" href="#h:76"><span class="id" title="binder">h</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#7322bfa5d36ce5cf12f68db819774432"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#p:74"><span class="id" title="variable">p</span></a> <a class="idref" href="Hprop.html#7322bfa5d36ce5cf12f68db819774432"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Hprop.html#v:75"><span class="id" title="variable">v</span></a><a class="idref" href="Hprop.html#7322bfa5d36ce5cf12f68db819774432"><span class="id" title="notation">)</span></a> <a class="idref" href="Hprop.html#7322bfa5d36ce5cf12f68db819774432"><span class="id" title="notation">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#h:76"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#Fmap.single"><span class="id" title="definition">Fmap.single</span></a> <a class="idref" href="Hprop.html#p:74"><span class="id" title="variable">p</span></a> <a class="idref" href="Hprop.html#v:75"><span class="id" title="variable">v</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">hnf</span> <span class="id" title="keyword">in</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">auto</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="hstar_inv" class="idref" href="#hstar_inv"><span class="id" title="lemma">hstar_inv</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:77" class="idref" href="#H<sub>1</sub>:77"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:78" class="idref" href="#H<sub>2</sub>:78"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="h:79" class="idref" href="#h:79"><span class="id" title="binder">h</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#H<sub>1</sub>:77"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:78"><span class="id" title="variable">H<sub>2</sub></span></a><a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">)</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">∃</span></a> <a id="h<sub>1</sub>:80" class="idref" href="#h<sub>1</sub>:80"><span class="id" title="binder">h<sub>1</sub></span></a> <a id="h<sub>2</sub>:81" class="idref" href="#h<sub>2</sub>:81"><span class="id" title="binder">h<sub>2</sub></span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Hprop.html#H<sub>1</sub>:77"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#h<sub>1</sub>:80"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:78"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="Hprop.html#h<sub>2</sub>:81"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="LibSepReference.html#Fmap.disjoint"><span class="id" title="definition">Fmap.disjoint</span></a> <a class="idref" href="Hprop.html#h<sub>1</sub>:80"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="Hprop.html#h<sub>2</sub>:81"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="Hprop.html#h:79"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#h<sub>1</sub>:80"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="Hprop.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">\</span></a><a class="idref" href="Hprop.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">u</span></a> <a class="idref" href="Hprop.html#h<sub>2</sub>:81"><span class="id" title="variable">h<sub>2</sub></span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">hnf</span> <span class="id" title="keyword">in</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">eauto</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="hexists_inv" class="idref" href="#hexists_inv"><span class="id" title="lemma">hexists_inv</span></a> : <span class="id" title="keyword">∀</span> <a id="A:82" class="idref" href="#A:82"><span class="id" title="binder">A</span></a> (<a id="J:83" class="idref" href="#J:83"><span class="id" title="binder">J</span></a>:<a class="idref" href="Hprop.html#A:82"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a>) <a id="h:84" class="idref" href="#h:84"><span class="id" title="binder">h</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">(\</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">∃</span></a> <a id="x:85" class="idref" href="#x:85"><span class="id" title="binder">x</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">,</span></a> <a class="idref" href="Hprop.html#J:83"><span class="id" title="variable">J</span></a> <a class="idref" href="Hprop.html#x:85"><span class="id" title="variable">x</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">)</span></a> <a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">∃</span></a> <a id="x:86" class="idref" href="#x:86"><span class="id" title="binder">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Hprop.html#J:83"><span class="id" title="variable">J</span></a> <a class="idref" href="Hprop.html#x:86"><span class="id" title="variable">x</span></a> <a class="idref" href="Hprop.html#h:84"><span class="id" title="variable">h</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">hnf</span> <span class="id" title="keyword">in</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">eauto</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab103"></a><h2 class="section">Proofs of Fundamental Properties</h2>

<div class="paragraph"> </div>

 The fundamental properties of Separation Logic operators were stated earlier
    in this chapter. This section presents their proofs. To avoid name
    conflicts, we wrap the new statements in a module. 
</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="HpropProofs" class="idref" href="#HpropProofs"><span class="id" title="module">HpropProofs</span></a>.<br/>
</div>

<div class="doc">
<a id="lab104"></a><h3 class="section">Extraction of Existential Quantifiers</h3>

<div class="paragraph"> </div>

 Let us prove that <span class="inlinecode">(<span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">J</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H</span></span> is equivalent to
    <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode">(<span class="id" title="var">J</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H</span>)</span>.

<div class="paragraph"> </div>

    Note that, somewhat confusingly, Coq displays none of the parentheses. You
    may want to use <span class="inlinecode"><span class="id" title="keyword">Set</span></span> <span class="inlinecode"><span class="id" title="keyword">Printing</span></span> <span class="inlinecode"><span class="id" title="var">Parentheses</span></span> to more easily follow through the
    proof. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="HpropProofs.hstar_hexists" class="idref" href="#HpropProofs.hstar_hexists"><span class="id" title="lemma">hstar_hexists</span></a> : <span class="id" title="keyword">∀</span> <a id="A:87" class="idref" href="#A:87"><span class="id" title="binder">A</span></a> (<a id="J:88" class="idref" href="#J:88"><span class="id" title="binder">J</span></a>:<a class="idref" href="Hprop.html#A:87"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a>) <a id="H:89" class="idref" href="#H:89"><span class="id" title="binder">H</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">\</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">∃</span></a> <a id="x:90" class="idref" href="#x:90"><span class="id" title="binder">x</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">,</span></a> <a class="idref" href="Hprop.html#J:88"><span class="id" title="variable">J</span></a> <a class="idref" href="Hprop.html#x:90"><span class="id" title="variable">x</span></a><a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">)</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H:89"><span class="id" title="variable">H</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">\</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">∃</span></a> <a id="x:91" class="idref" href="#x:91"><span class="id" title="binder">x</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">,</span></a> <a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#J:88"><span class="id" title="variable">J</span></a> <a class="idref" href="Hprop.html#x:91"><span class="id" title="variable">x</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H:89"><span class="id" title="variable">H</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
</div>

<div class="doc">
First, we exploit extensionality, using <span class="inlinecode"><span class="id" title="var">hprop_eq</span></span> or <span class="inlinecode"><span class="id" title="var">himpl_antisym</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="Hprop.html#hprop_eq"><span class="id" title="lemma">hprop_eq</span></a>. <span class="id" title="tactic">split</span>.<br/>
</div>

<div class="doc">
Then we reveal the definitions of <span class="inlinecode">==&gt;</span>, <span class="inlinecode"><span class="id" title="var">hexists</span></span> and <span class="inlinecode"><span class="id" title="var">hstar</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> (<span class="id" title="var">h<sub>1</sub></span>&amp;<span class="id" title="var">h<sub>2</sub></span>&amp;<span class="id" title="var">M<sub>1</sub></span>&amp;<span class="id" title="var">M<sub>2</sub></span>&amp;<span class="id" title="var">D</span>&amp;<span class="id" title="var">U</span>). <span class="id" title="tactic">destruct</span> <span class="id" title="var">M<sub>1</sub></span> <span class="id" title="keyword">as</span> (<span class="id" title="var">x</span>&amp;<span class="id" title="var">M<sub>1</sub></span>). <span class="id" title="tactic">∃</span>* <span class="id" title="var">x</span> <span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>2</sub></span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> (<span class="id" title="var">x</span>&amp;<span class="id" title="var">M</span>). <span class="id" title="tactic">destruct</span> <span class="id" title="var">M</span> <span class="id" title="keyword">as</span> (<span class="id" title="var">h<sub>1</sub></span>&amp;<span class="id" title="var">h<sub>2</sub></span>&amp;<span class="id" title="var">M<sub>1</sub></span>&amp;<span class="id" title="var">M<sub>2</sub></span>&amp;<span class="id" title="var">D</span>&amp;<span class="id" title="var">U</span>). <span class="id" title="tactic">∃</span> <span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>2</sub></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">splits</span>¬. <span class="id" title="tactic">∃</span>* <span class="id" title="var">x</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab105"></a><h3 class="section">Neutral of Separating Conjunction</h3>

<div class="paragraph"> </div>

<a id="lab106"></a><h4 class="section">Exercise: 3 stars, standard, especially useful (hstar_hempty_l)</h4>
 Prove that the empty heap predicate is a neutral element for the star. You
    will need to exploit the fact that the union with an empty map is the
    identity, as captured by lemma <span class="inlinecode"><span class="id" title="var">Fmap.union_empty_l</span></span>.
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <span class="id" title="var">Fmap.union_empty_l</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">h</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Fmap.empty</span> \<span class="id" title="var">u</span> <span class="id" title="var">h</span> = <span class="id" title="var">h</span>.
</span>
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="HpropProofs.hstar_hempty_l" class="idref" href="#HpropProofs.hstar_hempty_l"><span class="id" title="lemma">hstar_hempty_l</span></a> : <span class="id" title="keyword">∀</span> <a id="H:92" class="idref" href="#H:92"><span class="id" title="binder">H</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#cb6b4bc70cb30142f9711e4deb4cb93a"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H:92"><span class="id" title="variable">H</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#H:92"><span class="id" title="variable">H</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab107"></a><h3 class="section">Commutativity of Separating Conjunction</h3>

<div class="paragraph"> </div>

 We next aim to prove the commutativity of the star operator, i.e., that
    <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> is equivalent to <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span>. By symmetry, it suffices to prove
    the entailment in one direction, e.g., <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span>. The
    symmetry argument for any binary operator on heap predicates is captured by
    the lemma <span class="inlinecode"><span class="id" title="var">hprop_op_comm</span></span> shown below. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="HpropProofs.hprop_op_comm" class="idref" href="#HpropProofs.hprop_op_comm"><span class="id" title="lemma">hprop_op_comm</span></a> : <span class="id" title="keyword">∀</span> (<a id="op:93" class="idref" href="#op:93"><span class="id" title="binder">op</span></a>:<a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:94" class="idref" href="#H<sub>1</sub>:94"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:95" class="idref" href="#H<sub>2</sub>:95"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="h:96" class="idref" href="#h:96"><span class="id" title="binder">h</span></a>, <a class="idref" href="Hprop.html#op:93"><span class="id" title="variable">op</span></a> <a class="idref" href="Hprop.html#H<sub>1</sub>:94"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:95"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="Hprop.html#h:96"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Hprop.html#op:93"><span class="id" title="variable">op</span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:95"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="Hprop.html#H<sub>1</sub>:94"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#h:96"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:97" class="idref" href="#H<sub>1</sub>:97"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:98" class="idref" href="#H<sub>2</sub>:98"><span class="id" title="binder">H<sub>2</sub></span></a>, <a class="idref" href="Hprop.html#op:93"><span class="id" title="variable">op</span></a> <a class="idref" href="Hprop.html#H<sub>1</sub>:97"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:98"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#op:93"><span class="id" title="variable">op</span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:98"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="Hprop.html#H<sub>1</sub>:97"><span class="id" title="variable">H<sub>1</sub></span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="Hprop.html#hprop_eq"><span class="id" title="lemma">hprop_eq</span></a>. <span class="id" title="tactic">split</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">M</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
To prove commutativity of star, we need to exploit the fact that the union
    of two finite maps with disjoint domains commutes. This fact is captured by
    a lemma coming from the finite map library.
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <span class="id" title="var">Fmap.union_comm_of_disjoint</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>2</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Fmap.disjoint</span> <span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>2</sub></span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">h<sub>1</sub></span> \<span class="id" title="var">u</span> <span class="id" title="var">h<sub>2</sub></span> = <span class="id" title="var">h<sub>2</sub></span> \<span class="id" title="var">u</span> <span class="id" title="var">h<sub>1</sub></span>.
</span>    The commutativity result is then proved as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="HpropProofs.hstar_comm" class="idref" href="#HpropProofs.hstar_comm"><span class="id" title="lemma">hstar_comm</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:99" class="idref" href="#H<sub>1</sub>:99"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:100" class="idref" href="#H<sub>2</sub>:100"><span class="id" title="binder">H<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Hprop.html#H<sub>1</sub>:99"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:100"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:100"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>1</sub>:99"><span class="id" title="variable">H<sub>1</sub></span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Exploit&nbsp;symmetry.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Hprop.html#HpropProofs.hprop_op_comm"><span class="id" title="lemma">hprop_op_comm</span></a>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Unfold&nbsp;the&nbsp;definition&nbsp;of&nbsp;<span class="inlinecode"><span class="id" title="var">star</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> (<span class="id" title="var">h<sub>1</sub></span>&amp;<span class="id" title="var">h<sub>2</sub></span>&amp;<span class="id" title="var">M<sub>1</sub></span>&amp;<span class="id" title="var">M<sub>2</sub></span>&amp;<span class="id" title="var">D</span>&amp;<span class="id" title="var">U</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">h<sub>2</sub></span> <span class="id" title="var">h<sub>1</sub></span>. <span class="id" title="tactic">subst</span>. <span class="id" title="var">splits</span>¬.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Exploit&nbsp;commutativity&nbsp;of&nbsp;disjoint&nbsp;union&nbsp;*)</span><br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">rewrite</span> <a class="idref" href="LibSepReference.html#Fmap.union_comm_of_disjoint"><span class="id" title="lemma">Fmap.union_comm_of_disjoint</span></a>; <span class="id" title="tactic">auto</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab108"></a><h3 class="section">Associativity of Separating Conjunction</h3>

<div class="paragraph"> </div>

 Associativity of star is slightly more tedious to derive. We need to exploit
    the associativity of union on finite maps, as well as lemmas about the
    disjointness of a map with the result of the union of two maps.
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <span class="id" title="var">Fmap.union_assoc</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>2</sub></span> <span class="id" title="var">h<sub>3</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">h<sub>1</sub></span> \<span class="id" title="var">u</span> <span class="id" title="var">h<sub>2</sub></span>) \<span class="id" title="var">u</span> <span class="id" title="var">h<sub>3</sub></span> = <span class="id" title="var">h<sub>1</sub></span> \<span class="id" title="var">u</span> (<span class="id" title="var">h<sub>2</sub></span> \<span class="id" title="var">u</span> <span class="id" title="var">h<sub>3</sub></span>).<br/>
<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <span class="id" title="var">Fmap.disjoint_union_eq_l</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>2</sub></span> <span class="id" title="var">h<sub>3</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Fmap.disjoint</span> (<span class="id" title="var">h<sub>2</sub></span> \<span class="id" title="var">u</span> <span class="id" title="var">h<sub>3</sub></span>) <span class="id" title="var">h<sub>1</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;= (<span class="id" title="var">Fmap.disjoint</span> <span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>2</sub></span> ∧ <span class="id" title="var">Fmap.disjoint</span> <span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>3</sub></span>).<br/>
<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <span class="id" title="var">Fmap.disjoint_union_eq_r</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>2</sub></span> <span class="id" title="var">h<sub>3</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Fmap.disjoint</span> <span class="id" title="var">h<sub>1</sub></span> (<span class="id" title="var">h<sub>2</sub></span> \<span class="id" title="var">u</span> <span class="id" title="var">h<sub>3</sub></span>)<br/>
&nbsp;&nbsp;&nbsp;= (<span class="id" title="var">Fmap.disjoint</span> <span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>2</sub></span> ∧ <span class="id" title="var">Fmap.disjoint</span> <span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>3</sub></span>).
</span>
<div class="paragraph"> </div>

<a id="lab109"></a><h4 class="section">Exercise: 1 star, standard, optional (hstar_assoc)</h4>
 Complete the right-to-left part of the proof of associativity of the star
    operator. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="HpropProofs.hstar_assoc" class="idref" href="#HpropProofs.hstar_assoc"><span class="id" title="lemma">hstar_assoc</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:101" class="idref" href="#H<sub>1</sub>:101"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:102" class="idref" href="#H<sub>2</sub>:102"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="H<sub>3</sub>:103" class="idref" href="#H<sub>3</sub>:103"><span class="id" title="binder">H<sub>3</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#H<sub>1</sub>:101"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:102"><span class="id" title="variable">H<sub>2</sub></span></a><a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">)</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>3</sub>:103"><span class="id" title="variable">H<sub>3</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#H<sub>1</sub>:101"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#H<sub>2</sub>:102"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>3</sub>:103"><span class="id" title="variable">H<sub>3</sub></span></a><a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="Hprop.html#hprop_eq"><span class="id" title="lemma">hprop_eq</span></a>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> (<span class="id" title="var">h'</span>&amp;<span class="id" title="var">h<sub>3</sub></span>&amp;<span class="id" title="var">M<sub>1</sub></span>&amp;<span class="id" title="var">M<sub>2</sub></span>&amp;<span class="id" title="var">D</span>&amp;<span class="id" title="var">U</span>). <span class="id" title="tactic">destruct</span> <span class="id" title="var">M<sub>1</sub></span> <span class="id" title="keyword">as</span> (<span class="id" title="var">h<sub>1</sub></span>&amp;<span class="id" title="var">h<sub>2</sub></span>&amp;<span class="id" title="var">M<sub>3</sub></span>&amp;<span class="id" title="var">M<sub>4</sub></span>&amp;<span class="id" title="var">D'</span>&amp;<span class="id" title="var">U'</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">subst</span> <span class="id" title="var">h'</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="LibSepReference.html#Fmap.disjoint_union_eq_l"><span class="id" title="lemma">Fmap.disjoint_union_eq_l</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">D</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">h<sub>1</sub></span> (<span class="id" title="var">h<sub>2</sub></span> <a class="idref" href="Hprop.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">\</span></a><a class="idref" href="Hprop.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">u</span></a> <span class="id" title="var">h<sub>3</sub></span>). <span class="id" title="var">splits</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">apply</span> <span class="id" title="var">M<sub>3</sub></span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">∃</span>* <span class="id" title="var">h<sub>2</sub></span> <span class="id" title="var">h<sub>3</sub></span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">rewrite</span>* @<a class="idref" href="LibSepReference.html#Fmap.disjoint_union_eq_r"><span class="id" title="lemma">Fmap.disjoint_union_eq_r</span></a>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">rewrite</span>* @<a class="idref" href="LibSepReference.html#Fmap.union_assoc"><span class="id" title="lemma">Fmap.union_assoc</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">U</span>. } }<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 The lemma showing that <span class="inlinecode"><span class="id" title="var">hempty</span></span> is a right neutral can be derived from the
    fact that <span class="inlinecode"><span class="id" title="var">hempty</span></span> is a left neutral, plus commutativity. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="HpropProofs.hstar_hempty_r" class="idref" href="#HpropProofs.hstar_hempty_r"><span class="id" title="lemma">hstar_hempty_r</span></a> : <span class="id" title="keyword">∀</span> <a id="H:104" class="idref" href="#H:104"><span class="id" title="binder">H</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#H:104"><span class="id" title="variable">H</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#cb6b4bc70cb30142f9711e4deb4cb93a"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#H:104"><span class="id" title="variable">H</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="Hprop.html#HpropProofs.hstar_comm"><span class="id" title="lemma">hstar_comm</span></a>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="Hprop.html#HpropProofs.hstar_hempty_l"><span class="id" title="axiom">hstar_hempty_l</span></a>. <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab110"></a><h4 class="section">Exercise: 1 star, standard, especially useful (hstar_comm_assoc)</h4>
 The commutativity and associativity results combine into one result that is
    sometimes convenient to exploit in proofs. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="HpropProofs.hstar_comm_assoc" class="idref" href="#HpropProofs.hstar_comm_assoc"><span class="id" title="lemma">hstar_comm_assoc</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:105" class="idref" href="#H<sub>1</sub>:105"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:106" class="idref" href="#H<sub>2</sub>:106"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="H<sub>3</sub>:107" class="idref" href="#H<sub>3</sub>:107"><span class="id" title="binder">H<sub>3</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#H<sub>1</sub>:105"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:106"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>3</sub>:107"><span class="id" title="variable">H<sub>3</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#H<sub>2</sub>:106"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>1</sub>:105"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H<sub>3</sub>:107"><span class="id" title="variable">H<sub>3</sub></span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab111"></a><h3 class="section">Extracting Pure Facts from Separating Conjunctions</h3>

<div class="paragraph"> </div>

 The lemma <span class="inlinecode"><span class="id" title="var">hstar_hpure_l</span></span> stated below explains how to extract a pure fact
    from an assertion. It asserts that the proposition <span class="inlinecode">(<span class='gray-font'>\</span>[<span class="id" title="var">P</span>]</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H</span>)</span> <span class="inlinecode"><span class="id" title="var">h</span></span> is
    equivalent to <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span>. This lemma will also be used pervasively in proofs
    in subsequent chapters. 
<div class="paragraph"> </div>

<a id="lab112"></a><h4 class="section">Exercise: 4 stars, standard, especially useful (hstar_hpure_l)</h4>

<div class="paragraph"> </div>

 Prove that a heap <span class="inlinecode"><span class="id" title="var">h</span></span> satisfies <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">P</span>]</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H</span></span> if and only if <span class="inlinecode"><span class="id" title="var">P</span></span> is true and
    <span class="inlinecode"><span class="id" title="var">h</span></span> satisfies <span class="inlinecode"><span class="id" title="var">H</span></span>. The proof requires two lemmas on finite maps from
    <span class="inlinecode"><span class="id" title="var">LibSepFmap.v</span></span>:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <span class="id" title="var">Fmap.union_empty_l</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">h</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Fmap.empty</span> \<span class="id" title="var">u</span> <span class="id" title="var">h</span> = <span class="id" title="var">h</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <span class="id" title="var">Fmap.disjoint_empty_l</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">h</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Fmap.disjoint</span> <span class="id" title="var">Fmap.empty</span> <span class="id" title="var">h</span>.
</span>    Note that <span class="inlinecode"><span class="id" title="tactic">auto</span></span> can apply <span class="inlinecode"><span class="id" title="var">Fmap.disjoint_empty_l</span></span> automatically.

<div class="paragraph"> </div>

    Hint: begin the proof by appyling <span class="inlinecode"><span class="id" title="var">propositional_extensionality</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="HpropProofs.hstar_hpure_l" class="idref" href="#HpropProofs.hstar_hpure_l"><span class="id" title="lemma">hstar_hpure_l</span></a> : <span class="id" title="keyword">∀</span> <a id="P:108" class="idref" href="#P:108"><span class="id" title="binder">P</span></a> <a id="H:109" class="idref" href="#H:109"><span class="id" title="binder">H</span></a> <a id="h:110" class="idref" href="#h:110"><span class="id" title="binder">h</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#53316c5a9a53e765aefbae8243c4b1dc"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Hprop.html#P:108"><span class="id" title="variable">P</span></a><a class="idref" href="Hprop.html#53316c5a9a53e765aefbae8243c4b1dc"><span class="id" title="notation">]</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Hprop.html#H:109"><span class="id" title="variable">H</span></a><a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">)</span></a> <a class="idref" href="Hprop.html#1c2e0971edf6e9b6c6dd4a5951d04f<sub>36</sub>"><span class="id" title="notation">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#P:108"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="Hprop.html#H:109"><span class="id" title="variable">H</span></a> <a class="idref" href="Hprop.html#h:110"><span class="id" title="variable">h</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="code">

<span class="id" title="keyword">End</span> <a class="idref" href="Hprop.html#HpropProofs"><span class="id" title="module">HpropProofs</span></a>.<br/>
</div>

<div class="doc">
<a id="lab113"></a><h1 class="section">More Details</h1>

</div>

<div class="doc">
<a id="lab114"></a><h2 class="section">Alternative Definitions for Heap Predicates</h2>

<div class="paragraph"> </div>

 We pause here to discuss some alternative, equivalent definitions for the
    fundamental heap predicates. We write these equivalences using equalities of
    the form <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span>. Recall that the lemma <span class="inlinecode"><span class="id" title="var">hprop_eq</span></span> enables deriving such
    equalities by invoking predicate extensionality. 
<div class="paragraph"> </div>

 The empty heap predicate <span class="inlinecode"><span class='gray-font'>\</span>[]</span> is equivalent to the pure fact predicate
    <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">True</span>]</span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="hempty_eq_hpure_true" class="idref" href="#hempty_eq_hpure_true"><span class="id" title="lemma">hempty_eq_hpure_true</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#cb6b4bc70cb30142f9711e4deb4cb93a"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#53316c5a9a53e765aefbae8243c4b1dc"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a><a class="idref" href="Hprop.html#53316c5a9a53e765aefbae8243c4b1dc"><span class="id" title="notation">]</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Hprop.html#hempty"><span class="id" title="definition">hempty</span></a>, <a class="idref" href="Hprop.html#hpure"><span class="id" title="definition">hpure</span></a>. <span class="id" title="tactic">apply</span> <a class="idref" href="Hprop.html#hprop_eq"><span class="id" title="lemma">hprop_eq</span></a>. <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span>. <span class="id" title="var">iff</span> <span class="id" title="var">Hh</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">auto</span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">destruct</span> <span class="id" title="var">Hh</span>. <span class="id" title="tactic">auto</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Thus, <span class="inlinecode"><span class="id" title="var">hempty</span></span> could be defined in terms of <span class="inlinecode"><span class="id" title="var">hpure</span></span>, as <span class="inlinecode"><span class="id" title="var">hpure</span></span> <span class="inlinecode"><span class="id" title="var">True</span></span>,
    written <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">True</span>]</span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="hempty'" class="idref" href="#hempty'"><span class="id" title="definition">hempty'</span></a> : <a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#53316c5a9a53e765aefbae8243c4b1dc"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a><a class="idref" href="Hprop.html#53316c5a9a53e765aefbae8243c4b1dc"><span class="id" title="notation">]</span></a>.<br/>
</div>

<div class="doc">
The pure fact predicate <span class="inlinecode">[\<span class="id" title="var">P</span>]</span> is equivalent to the existential
    quantification over a proof of <span class="inlinecode"><span class="id" title="var">P</span></span> in the empty heap, that is, to the heap
    predicate <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode">(<span class="id" title="var">p</span>:<span class="id" title="var">P</span>),</span> <span class="inlinecode"><span class='gray-font'>\</span>[]</span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="hpure_eq_hexists_proof" class="idref" href="#hpure_eq_hexists_proof"><span class="id" title="lemma">hpure_eq_hexists_proof</span></a> : <span class="id" title="keyword">∀</span> <a id="P:111" class="idref" href="#P:111"><span class="id" title="binder">P</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#53316c5a9a53e765aefbae8243c4b1dc"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Hprop.html#P:111"><span class="id" title="variable">P</span></a><a class="idref" href="Hprop.html#53316c5a9a53e765aefbae8243c4b1dc"><span class="id" title="notation">]</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">\</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">∃</span></a> <a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">(</span></a><a id="p:112" class="idref" href="#p:112"><span class="id" title="binder">p</span></a>:<a class="idref" href="Hprop.html#P:111"><span class="id" title="variable">P</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">),</span></a> <a class="idref" href="Hprop.html#cb6b4bc70cb30142f9711e4deb4cb93a"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Hprop.html#hempty"><span class="id" title="definition">hempty</span></a>, <a class="idref" href="Hprop.html#hpure"><span class="id" title="definition">hpure</span></a>, <a class="idref" href="Hprop.html#hexists"><span class="id" title="definition">hexists</span></a>. <span class="id" title="tactic">intros</span> <span class="id" title="var">P</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Hprop.html#hprop_eq"><span class="id" title="lemma">hprop_eq</span></a>. <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span>. <span class="id" title="var">iff</span> <span class="id" title="var">Hh</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">destruct</span> <span class="id" title="var">Hh</span> <span class="id" title="keyword">as</span> (<span class="id" title="var">E</span>&amp;<span class="id" title="var">p</span>). <span class="id" title="tactic">∃</span> <span class="id" title="var">p</span>. <span class="id" title="tactic">auto</span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">destruct</span> <span class="id" title="var">Hh</span> <span class="id" title="keyword">as</span> (<span class="id" title="var">p</span>&amp;<span class="id" title="var">E</span>). <span class="id" title="tactic">auto</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Thus, <span class="inlinecode"><span class="id" title="var">hpure</span></span> could be defined in terms of <span class="inlinecode"><span class="id" title="var">hexists</span></span> and <span class="inlinecode"><span class="id" title="var">hempty</span></span>, as
    <span class="inlinecode"><span class="id" title="var">hexists</span></span> <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode">(<span class="id" title="var">p</span>:<span class="id" title="var">P</span>)</span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">hempty</span>)</span>, also written <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode">(<span class="id" title="var">p</span>:<span class="id" title="var">P</span>),</span> <span class="inlinecode"><span class='gray-font'>\</span>[]</span>. In fact,
    this is how <span class="inlinecode"><span class="id" title="var">hpure</span></span> is defined in the rest of the course. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="hpure'" class="idref" href="#hpure'"><span class="id" title="definition">hpure'</span></a> (<a id="P:113" class="idref" href="#P:113"><span class="id" title="binder">P</span></a>:<span class="id" title="keyword">Prop</span>) : <a class="idref" href="Hprop.html#hprop"><span class="id" title="definition">hprop</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">\</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">∃</span></a> <a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">(</span></a><a id="p:114" class="idref" href="#p:114"><span class="id" title="binder">p</span></a>:<a class="idref" href="Hprop.html#P:113"><span class="id" title="variable">P</span></a><a class="idref" href="Hprop.html#427157b8047cdf158af6c4e7232eb7ce"><span class="id" title="notation">),</span></a> <a class="idref" href="Hprop.html#cb6b4bc70cb30142f9711e4deb4cb93a"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a>.<br/>
</div>

<div class="doc">
It is useful to minimize the number of combinators, both for elegance and to
    reduce proof effort. We cannot do without <span class="inlinecode"><span class="id" title="var">hexists</span></span>, thus there remains a
    choice between considering either <span class="inlinecode"><span class="id" title="var">hpure</span></span> or <span class="inlinecode"><span class="id" title="var">hempty</span></span> as primitive, and the
    other one as derived. The predicate <span class="inlinecode"><span class="id" title="var">hempty</span></span> is simpler and appears as more
    fundamental. Hence, in the subsequent chapters, we define <span class="inlinecode"><span class="id" title="var">hpure</span></span> in terms
    of <span class="inlinecode"><span class="id" title="var">hexists</span></span> and <span class="inlinecode"><span class="id" title="var">hempty</span></span>, as in the definition of <span class="inlinecode"><span class="id" title="var">hpure'</span></span> shown above. In
    other words, we assume the definition:
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">hpure</span> (<span class="id" title="var">P</span>:<span class="id" title="keyword">Prop</span>) : <span class="id" title="var">hprop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class='gray-font'>\</span><span class="id" title="tactic">∃</span> (<span class="id" title="var">p</span>:<span class="id" title="var">P</span>), <span class='gray-font'>\</span>[].
</span>
</div>

<div class="doc">
<a id="lab115"></a><h1 class="section">Optional Material</h1>

</div>

<div class="doc">
<a id="lab116"></a><h2 class="section">More on the Definition of the Existential Quantifier</h2>

<div class="paragraph"> </div>

 The heap predicate <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode">(<span class="id" title="var">n</span>:<span class="id" title="var">int</span>),</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">val_int</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> characterizes a
    state that contains a single memory cell, at address <span class="inlinecode"><span class="id" title="var">p</span></span>, storing the
    integer value <span class="inlinecode"><span class="id" title="var">n</span></span>, for "some" (unspecified) integer <span class="inlinecode"><span class="id" title="var">n</span></span>.
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Parameter</span> (<span class="id" title="var">p</span>:<span class="id" title="var">loc</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Check</span> (<span class='gray-font'>\</span><span class="id" title="tactic">∃</span> (<span class="id" title="var">n</span>:<span class="id" title="var">int</span>), <span class="id" title="var">p</span> ~~&gt; (<span class="id" title="var">val_int</span> <span class="id" title="var">n</span>)) : <span class="id" title="var">hprop</span>.
</span>    The type of <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span>, which operates on <span class="inlinecode"><span class="id" title="var">hprop</span></span>,is very similar to that of
    <span class="inlinecode"><span class="id" title="tactic">∃</span></span>, which operates on <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. The key difference is that a witness for
    a <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> can depend on the current heap, whereas a witness for a <span class="inlinecode"><span class="id" title="tactic">∃</span></span>
    cannot.

<div class="paragraph"> </div>

    The notation <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> stands for <span class="inlinecode"><span class="id" title="var">ex</span></span> <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">P</span>)</span>, where <span class="inlinecode"><span class="id" title="var">ex</span></span> has the
    following type:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <span class="id" title="var">ex</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, (<span class="id" title="var">A</span> → <span class="id" title="keyword">Prop</span>) → <span class="id" title="keyword">Prop</span>.
</span>    Likewise, <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">H</span></span> stands for <span class="inlinecode"><span class="id" title="var">hexists</span></span> <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">H</span>)</span>, where <span class="inlinecode"><span class="id" title="var">hexists</span></span>
    has the following type:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <span class="id" title="var">hexists</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, (<span class="id" title="var">A</span> → <span class="id" title="var">hprop</span>) → <span class="id" title="var">hprop</span>.
</span>
<div class="paragraph"> </div>

 The notation for <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> is directly adapted from that of <span class="inlinecode"><span class="id" title="tactic">∃</span></span>, which
    supports the quantification an arbitrary number of variables, and is defined
    in <span class="inlinecode"><span class="id" title="var">Coq.Init.Logic</span></span> as follows.
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Notation</span> "'exists' x<sub>1</sub> .. xn , p" := (<span class="id" title="var">ex</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x<sub>1</sub></span> ⇒ .. (<span class="id" title="var">ex</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">xn</span> ⇒ <span class="id" title="var">p</span>)) ..))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 200, <span class="id" title="var">x<sub>1</sub></span> <span class="id" title="var">binder</span>, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "'[' 'exists' '/ ' x<sub>1</sub> .. xn , '/ ' p ']'").<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Notation</span> "'\exists' x<sub>1</sub> .. xn , H" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">hexists</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x<sub>1</sub></span> ⇒ .. (<span class="id" title="var">hexists</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">xn</span> ⇒ <span class="id" title="var">H</span>)) ..))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 39, <span class="id" title="var">x<sub>1</sub></span> <span class="id" title="var">binder</span>, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="var">H</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "'[' '\exists' '/ '  x<sub>1</sub>  ..  xn , '/ '  H ']'").
</span>
</div>

<div class="doc">
<a id="lab117"></a><h2 class="section">Formulation of the Extensionality Axioms</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="Extensionality" class="idref" href="#Extensionality"><span class="id" title="module">Extensionality</span></a>.<br/>
</div>

<div class="doc">
To establish extensionality of entailment, we have used the predicate
    extensionality axiom. In fact, this axiom can be derived by combining the
    axiom of "functional extensionality" with another one called "propositional
    extensionality". The axiom of "propositional extensionality" asserts that
    two propositions that are logically equivalent, in the sense that they imply
    each other, can be considered equal. 
</div>
<div class="code">

<span class="id" title="keyword">Axiom</span> <a id="Extensionality.propositional_extensionality" class="idref" href="#Extensionality.propositional_extensionality"><span class="id" title="axiom">propositional_extensionality</span></a> : <span class="id" title="keyword">∀</span> (<a id="P:115" class="idref" href="#P:115"><span class="id" title="binder">P</span></a> <a id="Q:116" class="idref" href="#Q:116"><span class="id" title="binder">Q</span></a>:<span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Hprop.html#P:115"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="Hprop.html#Q:116"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#P:115"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#Q:116"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
The axiom of "functional extensionality", as we saw above, asserts that two
    functions are equal if they provide equal result for every argument. 
</div>
<div class="code">

<span class="id" title="keyword">Axiom</span> <a id="Extensionality.functional_extensionality" class="idref" href="#Extensionality.functional_extensionality"><span class="id" title="axiom">functional_extensionality</span></a> : <span class="id" title="keyword">∀</span> <a id="A:118" class="idref" href="#A:118"><span class="id" title="binder">A</span></a> <a id="B:119" class="idref" href="#B:119"><span class="id" title="binder">B</span></a> (<a id="f:120" class="idref" href="#f:120"><span class="id" title="binder">f</span></a> <a id="g:121" class="idref" href="#g:121"><span class="id" title="binder">g</span></a>:<a class="idref" href="Hprop.html#A:118"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="Hprop.html#B:119"><span class="id" title="variable">B</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="x:122" class="idref" href="#x:122"><span class="id" title="binder">x</span></a>, <a class="idref" href="Hprop.html#f:120"><span class="id" title="variable">f</span></a> <a class="idref" href="Hprop.html#x:122"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#g:121"><span class="id" title="variable">g</span></a> <a class="idref" href="Hprop.html#x:122"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#f:120"><span class="id" title="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#g:121"><span class="id" title="variable">g</span></a>.<br/>
</div>

<div class="doc">
<a id="lab118"></a><h4 class="section">Exercise: 1 star, standard, especially useful (predicate_extensionality_derived)</h4>
 Use <span class="inlinecode"><span class="id" title="var">propositional_extensionality</span></span> and <span class="inlinecode"><span class="id" title="var">functional_extensionality</span></span> to derive
    <span class="inlinecode"><span class="id" title="var">predicate_extensionality</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="Extensionality.predicate_extensionality_derived" class="idref" href="#Extensionality.predicate_extensionality_derived"><span class="id" title="lemma">predicate_extensionality_derived</span></a> : <span class="id" title="keyword">∀</span> <a id="A:124" class="idref" href="#A:124"><span class="id" title="binder">A</span></a> (<a id="P:125" class="idref" href="#P:125"><span class="id" title="binder">P</span></a> <a id="Q:126" class="idref" href="#Q:126"><span class="id" title="binder">Q</span></a>:<a class="idref" href="Hprop.html#A:124"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="x:127" class="idref" href="#x:127"><span class="id" title="binder">x</span></a>, <a class="idref" href="Hprop.html#P:125"><span class="id" title="variable">P</span></a> <a class="idref" href="Hprop.html#x:127"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="Hprop.html#Q:126"><span class="id" title="variable">Q</span></a> <a class="idref" href="Hprop.html#x:127"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hprop.html#P:125"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Hprop.html#Q:126"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="code">

<span class="id" title="keyword">End</span> <a class="idref" href="Hprop.html#Extensionality"><span class="id" title="module">Extensionality</span></a>.<br/>
</div>

<div class="doc">
<a id="lab119"></a><h2 class="section">Historical Notes</h2>

<div class="paragraph"> </div>

 In this chapter, we have defined the Separation Logic operators, in
    particular the "separating conjunction" operator, as a Coq predicate. This
    formalization style is called "shallow embedding". It has been employed in
    the first mechanized formalizations of Separation Logic, in Coq by
    <a href="Bib.html#Yu,-Hamid, and Shao 2003"><span class="inlineref">[Yu, Hamid, and Shao 2003]</span></a>, and in Isabelle/HOL by <a href="Bib.html#Weber-2004"><span class="inlineref">[Weber 2004]</span></a>.
    These two formalizations were carried out soon after the invention of
    Separation Logic, by researchers who were used to mechanizing Hoare logic and
    had spotted the potential benefit of working with the separating
    conjunction. 
</div>
<div class="code">

<span class="comment">(*&nbsp;2024-08-30&nbsp;14:21&nbsp;*)</span><br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>