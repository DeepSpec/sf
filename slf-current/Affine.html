<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>Affine: Affine Separation Logic</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/slf.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<div id="page">

<div id="header">
<div id='logoinheader'><a href='https://softwarefoundations.cis.upenn.edu'>
<img src='common/media/image/sf_logo_sm.png' alt='Software Foundations Logo'></a></div>
<div class='booktitleinheader'><a href='index.html'>Volume 6: Separation Logic Foundations</a></div>
<ul id='menu'>
   <li class='section_name'><a href='toc.html'>Table of Contents</a></li>
   <li class='section_name'><a href='coqindex.html'>Index</a></li>
   <li class='section_name'><a href='deps.html'>Roadmap</a></li>
</ul>
</div>

<div id="main">

<h1 class="libtitle">Affine<span class="subtitle">Affine Separation Logic</span></h1>


<div class="code">

<span class="id" title="keyword">Set Implicit Arguments</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">SLF</span> <span class="id" title="keyword">Require</span> <a class="idref" href="Rules.html#"><span class="id" title="library">Rules</span></a>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">SLF</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="LibSepReference.html#"><span class="id" title="library">LibSepReference</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">f</span> : <a class="idref" href="LibSepVar.html#var"><span class="id" title="definition">var</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">b</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">v</span> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">h</span> : <a class="idref" href="LibSepReference.html#heap"><span class="id" title="definition">heap</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">H</span> : <a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">Q</span> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>.<br/>
</div>

<div class="doc">
<a id="lab385"></a><h1 class="section">First Pass</h1>

<div class="paragraph"> </div>

 The Separation Logic framework that we have constructed is well suited for a
    language with explicit deallocation, but cannot be used as-is for a language
    equipped with a garbage collector. As pointed out in chapter <a href="Basic.html"><span class="inlineref">Basic</span></a>,
    there is no rule in our basic Separation Logic that allows discarding a heap
    predicate from the precondition or the postcondition. From a theoretical
    perspective, discarding predicates from the postcondition is sufficient.
    From a practical perspective, however, the user may wish to clarify the
    proof obligations by discarding predicates appearing in the precondition as
    soon as they are no longer useful.

<div class="paragraph"> </div>

    In this chapter, we explain how to generalize the Separation Logic framework
    to support a "discard rule", which one may invoke to discard heap predicates
    from the precondition or postcondition.

<div class="paragraph"> </div>

    The framework extended with the discard rule corresponds to an "affine"
    logic, where heap predicates may be freely discarded, as opposed to a
    "linear" logic, where heap predicates cannot be thrown away. As we argue, it
    may be interesting for a program logic to accomodate both "affine"
    predicates and "linear" predicates. We will explain how to fine tune which
    heap predicates may be freely discarded.

<div class="paragraph"> </div>

    For example, even in a programming language featuring a garbage collector,
    it may be useful to ensure that every file handle opened eventually gets
    closed, or that every lock acquired is eventually released. File handles and
    locks are example of resources that may be described in Separation Logic,
    yet that one should not be allowed to discard freely.

<div class="paragraph"> </div>

    Regarding garbage-collected data, another possible approach is to require
    the programmer to integrate "free" operations defined as no-ops, to
    materialize the places where memory cells can and should be discarded. This
    approach, however, is cumbersome for freeing recursive data structures. For
    example, to free a mutable list, the programmer would need to iterate over
    the list to free its cells one by one. In contrast, with a "discard rule" in
    the program logic, the user can discard at once the representation predicate
    for the full list, without involving any form of iteration. 
<div class="paragraph"> </div>

 The chapter is organized as follows:

<div class="paragraph"> </div>

<ul class="doclist">
<li> first, we recall the example illustrating the limitation of a logic
      without a discard rule for a garbage-collected language;

</li>
<li> second, we present several versions of the "discard rule";

</li>
<li> third, we show how to refine the definition of Separation Logic
      triples in such a way that the discard rules are satisfied
      for certain classes of heap predicates. 

</li>
</ul>
</div>

<div class="doc">
<a id="lab386"></a><h2 class="section">Motivation for the Discard Rule</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="MotivatingExample" class="idref" href="#MotivatingExample"><span class="id" title="module">MotivatingExample</span></a>.<br/>
<span class="id" title="keyword">Export</span> <a class="idref" href="LibSepReference.html#DemoPrograms"><span class="id" title="module">DemoPrograms</span></a>.<br/>
</div>

<div class="doc">
Recall the example of the function <span class="inlinecode"><span class="id" title="var">succ_using_incr_attempt</span></span> from chapter
    <a href="Basic.html"><span class="inlineref">Basic</span></a>. This function allocates a reference with contents <span class="inlinecode"><span class="id" title="var">n</span></span>, then
    increments that reference, and finally returning its contents, that is,
    <span class="inlinecode"><span class="id" title="var">n</span>+1</span>. Let us revisit this example, this time with the intention of
    establishing for it a postcondition that does not leak the existence of a
    left-over reference cell. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="MotivatingExample.succ_using_incr" class="idref" href="#MotivatingExample.succ_using_incr"><span class="id" title="definition">succ_using_incr</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:'ref'"><span class="id" title="notation">ref</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#DemoPrograms.incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
In the framework developed so far, the heap predicate describing the
    reference cell allocated by the function cannot be discarded, because the
    code does not include a deallocation operation. Thus, we are forced to
    include in the postcondition the description of a left-over reference with a
    heap predicate, e.g., <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">p</span>,</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>, or <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">m</span>,</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">m</span></span>.
    
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="MotivatingExample.triple_succ_using_incr" class="idref" href="#MotivatingExample.triple_succ_using_incr"><span class="id" title="lemma">triple_succ_using_incr</span></a> : <span class="id" title="keyword">∀</span> (<a id="n:1" class="idref" href="#n:1"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Affine.html#MotivatingExample.succ_using_incr"><span class="id" title="definition">succ_using_incr</span></a> <a class="idref" href="Affine.html#n:1"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:2" class="idref" href="#r:2"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Affine.html#r:2"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Affine.html#n:1"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="p:3" class="idref" href="#p:3"><span class="id" title="binder">p</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#p:3"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#n:1"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>. <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
If we try to prove a specification that does not mention the left-over
    reference, then we get stuck with a proof obligation of the form
    <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class='gray-font'>\</span>[]</span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="MotivatingExample.triple_succ_using_incr'" class="idref" href="#MotivatingExample.triple_succ_using_incr'"><span class="id" title="lemma">triple_succ_using_incr'</span></a> : <span class="id" title="keyword">∀</span> (<a id="n:4" class="idref" href="#n:4"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Affine.html#MotivatingExample.succ_using_incr"><span class="id" title="definition">succ_using_incr</span></a> <a class="idref" href="Affine.html#n:4"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:5" class="idref" href="#r:5"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Affine.html#r:5"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Affine.html#n:4"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>. { <span class="id" title="tactic">auto</span>. } <span class="comment">(*&nbsp;stuck&nbsp;here&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
In what follows, we extend our Separation Logic with a "discard rule" that
    allows proving the above specification for <span class="inlinecode"><span class="id" title="var">succ_using_incr</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#MotivatingExample"><span class="id" title="module">MotivatingExample</span></a>.<br/>
</div>

<div class="doc">
<a id="lab387"></a><h2 class="section">Statement of The Discard Rule</h2>

<div class="paragraph"> </div>

 There are several ways to state the "discard rule". Let us begin with two
    variants: one that discards a heap predicate <span class="inlinecode"><span class="id" title="var">H'</span></span> from the postcondition,
    and one that discards a heap predicate <span class="inlinecode"><span class="id" title="var">H'</span></span> from the precondition.

<div class="paragraph"> </div>

    The first rule, named <span class="inlinecode"><span class="id" title="var">triple_hany_post</span></span>, asserts that an arbitrary heap
    predicate <span class="inlinecode"><span class="id" title="var">H'</span></span> can be dropped from the postcondition, simplifying it from
    <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*+</span> <span class="inlinecode"><span class="id" title="var">H'</span></span> to <span class="inlinecode"><span class="id" title="var">Q</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_hany_post" class="idref" href="#triple_hany_post"><span class="id" title="axiom">triple_hany_post</span></a> : <span class="id" title="keyword">∀</span> <a id="t:6" class="idref" href="#t:6"><span class="id" title="binder">t</span></a> <a id="H:7" class="idref" href="#H:7"><span class="id" title="binder">H</span></a> <a id="H':8" class="idref" href="#H':8"><span class="id" title="binder">H'</span></a> <a id="Q:9" class="idref" href="#Q:9"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:6"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:7"><span class="id" title="variable">H</span></a> (<a class="idref" href="Affine.html#Q:9"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H':8"><span class="id" title="variable">H'</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:6"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:7"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:9"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
Let us show that, using the rule <span class="inlinecode"><span class="id" title="var">triple_hany_post</span></span>, we can derive the
    desired specification for the motivating example from the specification that
    mentions the left-over postcondition. 
</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="MotivatingExampleSolved" class="idref" href="#MotivatingExampleSolved"><span class="id" title="module">MotivatingExampleSolved</span></a>.<br/>
<span class="id" title="keyword">Export</span> <a class="idref" href="Affine.html#MotivatingExample"><span class="id" title="module">MotivatingExample</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="MotivatingExampleSolved.triple_succ_using_incr'" class="idref" href="#MotivatingExampleSolved.triple_succ_using_incr'"><span class="id" title="lemma">triple_succ_using_incr'</span></a> : <span class="id" title="keyword">∀</span> (<a id="n:11" class="idref" href="#n:11"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Affine.html#MotivatingExample.succ_using_incr"><span class="id" title="definition">succ_using_incr</span></a> <a class="idref" href="Affine.html#n:11"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:12" class="idref" href="#r:12"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Affine.html#r:12"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Affine.html#n:11"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#triple_hany_post"><span class="id" title="axiom">triple_hany_post</span></a>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#MotivatingExample.triple_succ_using_incr"><span class="id" title="lemma">triple_succ_using_incr</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#MotivatingExampleSolved"><span class="id" title="module">MotivatingExampleSolved</span></a>.<br/>
</div>

<div class="doc">
A symmetric rule, named <span class="inlinecode"><span class="id" title="var">triple_hany_pre</span></span>, asserts that an arbitrary heap
    predicate <span class="inlinecode"><span class="id" title="var">H'</span></span> can be dropped from the precondition, simplifying it from
    <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H'</span></span> to <span class="inlinecode"><span class="id" title="var">H</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_hany_pre" class="idref" href="#triple_hany_pre"><span class="id" title="axiom">triple_hany_pre</span></a> : <span class="id" title="keyword">∀</span> <a id="t:13" class="idref" href="#t:13"><span class="id" title="binder">t</span></a> <a id="H:14" class="idref" href="#H:14"><span class="id" title="binder">H</span></a> <a id="H':15" class="idref" href="#H':15"><span class="id" title="binder">H'</span></a> <a id="Q:16" class="idref" href="#Q:16"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:13"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:14"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:16"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:13"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#H:14"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H':15"><span class="id" title="variable">H'</span></a>) <a class="idref" href="Affine.html#Q:16"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
Observe the difference between the two rules. In <span class="inlinecode"><span class="id" title="var">triple_hany_post</span></span>, the
    discarded predicate <span class="inlinecode"><span class="id" title="var">H'</span></span> appears in the premise, reflecting the fact that we
    discard it after the evaluation of the term <span class="inlinecode"><span class="id" title="var">t</span></span>.

<div class="paragraph"> </div>

    Conversely, in <span class="inlinecode"><span class="id" title="var">triple_hany_pre</span></span>, the discarded predicate <span class="inlinecode"><span class="id" title="var">H'</span></span> appears in
    the conclusion, reflecting the fact that we discard it before the evaluation
    of <span class="inlinecode"><span class="id" title="var">t</span></span>. 
<div class="paragraph"> </div>

 The rules <span class="inlinecode"><span class="id" title="var">triple_hany_pre</span></span> and <span class="inlinecode"><span class="id" title="var">triple_hany_post</span></span> can be derived from each
    other. As we will establish further on, <span class="inlinecode"><span class="id" title="var">triple_hany_pre</span></span> is derivable from
    <span class="inlinecode"><span class="id" title="var">triple_hany_post</span></span> by a simple application of the frame rule. Reciprocally,
    <span class="inlinecode"><span class="id" title="var">triple_hany_post</span></span> is derivable from <span class="inlinecode"><span class="id" title="var">triple_hany_pre</span></span>, though the proof is
    slightly more involved. This proof appears in lemma
    <span class="inlinecode"><span class="id" title="var">triple_hgc_post_from_hgc_pre</span></span> in the "optional material" section. 
</div>

<div class="doc">
<a id="lab388"></a><h2 class="section">Fine-grained Control of Collectable Predicates</h2>

</div>

<div class="doc">
<a id="lab389"></a><h3 class="section">Axiomatization of <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> and <span class="inlinecode"><span class="id" title="var">haffine</span></span></h3>

<div class="paragraph"> </div>

 As suggested in the introduction, it may be useful to constrain the discard
    rule in such a way that it can be used to discard only certain types of heap
    predicates, not arbitrary ones.

<div class="paragraph"> </div>

    The idea is to restrict the discard rules so that only predicates satisfying
    a predicate called <span class="inlinecode"><span class="id" title="var">haffine</span></span> may be discarded.

<div class="paragraph"> </div>

    The two discard rules should thus feature an extra premise: to discard a
    heap predicate <span class="inlinecode"><span class="id" title="var">H'</span></span>, the proposition <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H'</span></span> must hold. 
</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="Preview" class="idref" href="#Preview"><span class="id" title="module">Preview</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Parameter</span> <a id="Preview.haffine" class="idref" href="#Preview.haffine"><span class="id" title="axiom">haffine</span></a> : <a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Parameter</span> <a id="Preview.triple_haffine_post" class="idref" href="#Preview.triple_haffine_post"><span class="id" title="axiom">triple_haffine_post</span></a> : <span class="id" title="keyword">∀</span> <a id="t:19" class="idref" href="#t:19"><span class="id" title="binder">t</span></a> <a id="H:20" class="idref" href="#H:20"><span class="id" title="binder">H</span></a> <a id="H':21" class="idref" href="#H':21"><span class="id" title="binder">H'</span></a> <a id="Q:22" class="idref" href="#Q:22"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#Preview.haffine"><span class="id" title="axiom">haffine</span></a> <a class="idref" href="Affine.html#H':21"><span class="id" title="variable">H'</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:19"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:20"><span class="id" title="variable">H</span></a> (<a class="idref" href="Affine.html#Q:22"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H':21"><span class="id" title="variable">H'</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:19"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:20"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:22"><span class="id" title="variable">Q</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Parameter</span> <a id="Preview.triple_haffine_pre" class="idref" href="#Preview.triple_haffine_pre"><span class="id" title="axiom">triple_haffine_pre</span></a> : <span class="id" title="keyword">∀</span> <a id="t:24" class="idref" href="#t:24"><span class="id" title="binder">t</span></a> <a id="H:25" class="idref" href="#H:25"><span class="id" title="binder">H</span></a> <a id="H':26" class="idref" href="#H':26"><span class="id" title="binder">H'</span></a> <a id="Q:27" class="idref" href="#Q:27"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#Preview.haffine"><span class="id" title="axiom">haffine</span></a> <a class="idref" href="Affine.html#H':26"><span class="id" title="variable">H'</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:24"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:25"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:27"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:24"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#H:25"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H':26"><span class="id" title="variable">H'</span></a>) <a class="idref" href="Affine.html#Q:27"><span class="id" title="variable">Q</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#Preview"><span class="id" title="module">Preview</span></a>.<br/>
</div>

<div class="doc">
The predicate <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> is defined in terms of a lower-level predicate
    <span class="inlinecode"><span class="id" title="var">heap_affine</span></span>. The proposition <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> asserts that the piece of
    heap <span class="inlinecode"><span class="id" title="var">h</span></span> may be freely discarded, in the sense that it does not have to be
    accounted for in the program logic. The question of whether a heap or a heap
    predicate should be affine or not is to be decided on a case-by-case basis.
    It depends on the intention of the designer of the program logic. For the
    moment, we leave the predicate <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> abstract, and allow it to be
    customized later on. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="heap_affine" class="idref" href="#heap_affine"><span class="id" title="axiom">heap_affine</span></a> : <a class="idref" href="LibSepReference.html#heap"><span class="id" title="definition">heap</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span>.<br/>
</div>

<div class="doc">
The only assumptions we need to make about <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> is that it holds of
    the empty heap and that it is preserved by a disjoint union operation. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="heap_affine_empty" class="idref" href="#heap_affine_empty"><span class="id" title="axiom">heap_affine_empty</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="LibSepReference.html#Fmap.empty"><span class="id" title="definition">Fmap.empty</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Parameter</span> <a id="heap_affine_union" class="idref" href="#heap_affine_union"><span class="id" title="axiom">heap_affine_union</span></a> : <span class="id" title="keyword">∀</span> <a id="h<sub>1</sub>:31" class="idref" href="#h<sub>1</sub>:31"><span class="id" title="binder">h<sub>1</sub></span></a> <a id="h<sub>2</sub>:32" class="idref" href="#h<sub>2</sub>:32"><span class="id" title="binder">h<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:31"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:32"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.disjoint"><span class="id" title="definition">Fmap.disjoint</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:31"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:32"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> (<a class="idref" href="LibSepReference.html#Fmap.union"><span class="id" title="definition">Fmap.union</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:31"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:32"><span class="id" title="variable">h<sub>2</sub></span></a>).<br/>
</div>

<div class="doc">
We will later show two extreme instantiations: one that leads to a logic
    where all predicates are affine (i.e. can be freely discarded), and one that
    leads to a logic where all predicates are linear (i.e. none can be freely
    discarded, like in our previous set up). 
</div>

<div class="doc">
<a id="lab390"></a><h3 class="section">Definition and Properties of <span class="inlinecode"><span class="id" title="var">heap_affine</span></span></h3>

<div class="paragraph"> </div>

 The predicate <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> captures the notion of "affine heap predicate".

<div class="paragraph"> </div>

    A heap predicate is affine iff it holds only of affine heaps. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="haffine" class="idref" href="#haffine"><span class="id" title="definition">haffine</span></a> (<a id="H:34" class="idref" href="#H:34"><span class="id" title="binder">H</span></a>:<a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a id="h:35" class="idref" href="#h:35"><span class="id" title="binder">h</span></a>, <a class="idref" href="Affine.html#H:34"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#h:35"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h:35"><span class="id" title="variable">h</span></a>.<br/>
</div>

<div class="doc">
The predicate <span class="inlinecode"><span class="id" title="var">haffine</span></span> distributes in a natural way over each of the
    operators of Separation Logic -- i.e., the combination of affine heap
    predicates yields affine heap predicates. In particular:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class='gray-font'>\</span>[]</span> and <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">P</span>]</span>, which describe empty heaps, can always be discarded;

</li>
<li> <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> can be discarded if both <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> can be discarded;

</li>
<li> <span class="inlinecode">\<span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">H</span></span> can be discarded if <span class="inlinecode"><span class="id" title="var">H</span></span> can be discarded for at least one
      <span class="inlinecode"><span class="id" title="var">x</span></span>;

</li>
<li> <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">H</span></span> can be discarded if <span class="inlinecode"><span class="id" title="var">H</span></span> can be discarded for every <span class="inlinecode"><span class="id" title="var">x</span></span>.

</li>
</ul>

<div class="paragraph"> </div>

    The treatment of universal quantifiers can be explained as follows. Consider
    a heap <span class="inlinecode"><span class="id" title="var">h</span></span> that satisfies <span class="inlinecode">\<span class="id" title="keyword">∀</span></span> <span class="inlinecode">(<span class="id" title="var">x</span>:<span class="id" title="var">A</span>),</span> <span class="inlinecode"><span class="id" title="var">H</span></span>, and consider a particular
    value <span class="inlinecode"><span class="id" title="var">v</span></span> of type <span class="inlinecode"><span class="id" title="var">A</span></span>. The heap <span class="inlinecode"><span class="id" title="var">h</span></span> also satisfies <span class="inlinecode">[<span class="id" title="var">x</span>:=<span class="id" title="var">v</span>]<span class="id" title="var">H</span></span>. Thus, if the
    heap predicate <span class="inlinecode">[<span class="id" title="var">x</span>:=<span class="id" title="var">v</span>]<span class="id" title="var">H</span></span> can be discarded, the stronger predicate
    <span class="inlinecode">\<span class="id" title="keyword">∀</span></span> <span class="inlinecode">(<span class="id" title="var">x</span>:<span class="id" title="var">A</span>),</span> <span class="inlinecode"><span class="id" title="var">H</span></span> can also be discarded.

<div class="paragraph"> </div>

    Existential quantifiers can be explained as follows. Consider a heap <span class="inlinecode"><span class="id" title="var">h</span></span>
    that satisfies <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode">(<span class="id" title="var">x</span>:<span class="id" title="var">A</span>),</span> <span class="inlinecode"><span class="id" title="var">H</span></span>. We know that there exists a value <span class="inlinecode"><span class="id" title="var">v</span></span> of
    type <span class="inlinecode"><span class="id" title="var">A</span></span> such that <span class="inlinecode"><span class="id" title="var">h</span></span> satisfies <span class="inlinecode">[<span class="id" title="var">x</span>:=<span class="id" title="var">v</span>]<span class="id" title="var">H</span></span>. However, we know nothing about
    this value <span class="inlinecode"><span class="id" title="var">v</span></span>. Therefore, to discard <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode">(<span class="id" title="var">x</span>:<span class="id" title="var">A</span>),</span> <span class="inlinecode"><span class="id" title="var">H</span></span>, we need to know
    that <span class="inlinecode">[<span class="id" title="var">x</span>:=<span class="id" title="var">v</span>]<span class="id" title="var">H</span></span> can be discarded for every possible <span class="inlinecode"><span class="id" title="var">v</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="haffine_hempty" class="idref" href="#haffine_hempty"><span class="id" title="lemma">haffine_hempty</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">K</span>. <span class="id" title="var">lets</span> <span class="id" title="var">E</span>: <a class="idref" href="LibSepReference.html#SepSimplArgs.hempty_inv"><span class="id" title="lemma">hempty_inv</span></a> <span class="id" title="var">K</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#heap_affine_empty"><span class="id" title="axiom">heap_affine_empty</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="haffine_hpure" class="idref" href="#haffine_hpure"><span class="id" title="lemma">haffine_hpure</span></a> : <span class="id" title="keyword">∀</span> <a id="P:36" class="idref" href="#P:36"><span class="id" title="binder">P</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Affine.html#P:36"><span class="id" title="variable">P</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span> <span class="id" title="var">K</span>. <span class="id" title="var">lets</span> (<span class="id" title="var">HP</span>&amp;<span class="id" title="var">M</span>): <a class="idref" href="LibSepReference.html#SepSimplArgs.hpure_inv"><span class="id" title="lemma">hpure_inv</span></a> <span class="id" title="var">K</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">subst</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#heap_affine_empty"><span class="id" title="axiom">heap_affine_empty</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="haffine_hstar" class="idref" href="#haffine_hstar"><span class="id" title="lemma">haffine_hstar</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:37" class="idref" href="#H<sub>1</sub>:37"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:38" class="idref" href="#H<sub>2</sub>:38"><span class="id" title="binder">H<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:37"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:38"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="Affine.html#H<sub>1</sub>:37"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:38"><span class="id" title="variable">H<sub>2</sub></span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">M<sub>1</sub></span> <span class="id" title="var">M<sub>2</sub></span> <span class="id" title="var">K</span>. <span class="id" title="var">lets</span> (<span class="id" title="var">h<sub>1</sub></span>&amp;<span class="id" title="var">h<sub>2</sub></span>&amp;<span class="id" title="var">K<sub>1</sub></span>&amp;<span class="id" title="var">K<sub>2</sub></span>&amp;<span class="id" title="var">D</span>&amp;<span class="id" title="var">U</span>): <a class="idref" href="LibSepReference.html#SepSimplArgs.hstar_inv"><span class="id" title="lemma">hstar_inv</span></a> <span class="id" title="var">K</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">subst</span>. <span class="id" title="var">applys</span>* <a class="idref" href="Affine.html#heap_affine_union"><span class="id" title="axiom">heap_affine_union</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="haffine_hexists" class="idref" href="#haffine_hexists"><span class="id" title="lemma">haffine_hexists</span></a> : <span class="id" title="keyword">∀</span> <a id="A:39" class="idref" href="#A:39"><span class="id" title="binder">A</span></a> (<a id="J:40" class="idref" href="#J:40"><span class="id" title="binder">J</span></a>:<a class="idref" href="Affine.html#A:39"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="x:41" class="idref" href="#x:41"><span class="id" title="binder">x</span></a>, <a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="Affine.html#J:40"><span class="id" title="variable">J</span></a> <a class="idref" href="Affine.html#x:41"><span class="id" title="variable">x</span></a>)<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="x:42" class="idref" href="#x:42"><span class="id" title="binder">x</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#J:40"><span class="id" title="variable">J</span></a> <a class="idref" href="Affine.html#x:42"><span class="id" title="variable">x</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">F<sub>1</sub></span> (<span class="id" title="var">x</span>&amp;<span class="id" title="var">Hx</span>). <span class="id" title="var">applys</span>* <span class="id" title="var">F<sub>1</sub></span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="haffine_hforall'" class="idref" href="#haffine_hforall'"><span class="id" title="lemma">haffine_hforall'</span></a> : <span class="id" title="keyword">∀</span> <a id="A:43" class="idref" href="#A:43"><span class="id" title="binder">A</span></a> (<a id="J:44" class="idref" href="#J:44"><span class="id" title="binder">J</span></a>:<a class="idref" href="Affine.html#A:43"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">∃</span></a> <a id="x:45" class="idref" href="#x:45"><span class="id" title="binder">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="Affine.html#J:44"><span class="id" title="variable">J</span></a> <a class="idref" href="Affine.html#x:45"><span class="id" title="variable">x</span></a>)<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">∀</span></a> <a id="x:46" class="idref" href="#x:46"><span class="id" title="binder">x</span></a><a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#J:44"><span class="id" title="variable">J</span></a> <a class="idref" href="Affine.html#x:46"><span class="id" title="variable">x</span></a><a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> (<span class="id" title="var">x</span>&amp;<span class="id" title="var">Hx</span>) <span class="id" title="var">M</span>. <span class="id" title="var">lets</span> <span class="id" title="var">N</span>: <a class="idref" href="LibSepReference.html#SepSimplArgs.hforall_inv"><span class="id" title="lemma">hforall_inv</span></a> <span class="id" title="var">M</span>. <span class="id" title="var">applys</span>* <span class="id" title="var">Hx</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The rule <span class="inlinecode"><span class="id" title="var">haffine_hforall'</span></span> requires the user to provide evidence that there
    exists at least one value <span class="inlinecode"><span class="id" title="var">x</span></span> of type <span class="inlinecode"><span class="id" title="var">A</span></span> for which <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode">(<span class="id" title="var">J</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span> is true.
    In practice, the user is generally not interested in proving properties of a
    specific value <span class="inlinecode"><span class="id" title="var">x</span></span>, but is happy to justify that <span class="inlinecode"><span class="id" title="var">J</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> is affine for any
    <span class="inlinecode"><span class="id" title="var">x</span></span>. The corresponding statement appears below, with an assumption <span class="inlinecode"><span class="id" title="var">Inhab</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>
    asserting that the type <span class="inlinecode"><span class="id" title="var">A</span></span> is inhabited. In practice, the <span class="inlinecode">\<span class="id" title="keyword">∀</span></span>
    quantifier is always invoked on inhabited types, so this is a benign
    restriction. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="haffine_hforall" class="idref" href="#haffine_hforall"><span class="id" title="lemma">haffine_hforall</span></a> : <span class="id" title="keyword">∀</span> <a id="A:47" class="idref" href="#A:47"><span class="id" title="binder">A</span></a> `{<a id="H:48" class="idref" href="#H:48"><span class="id" title="binder">Inhab</span></a> <a id="H:48" class="idref" href="#H:48"><span class="id" title="binder">A</span></a>} (<a id="J:49" class="idref" href="#J:49"><span class="id" title="binder">J</span></a>:<a class="idref" href="Affine.html#A:47"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="x:50" class="idref" href="#x:50"><span class="id" title="binder">x</span></a>, <a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="Affine.html#J:49"><span class="id" title="variable">J</span></a> <a class="idref" href="Affine.html#x:50"><span class="id" title="variable">x</span></a>)<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">∀</span></a> <a id="x:51" class="idref" href="#x:51"><span class="id" title="binder">x</span></a><a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#J:49"><span class="id" title="variable">J</span></a> <a class="idref" href="Affine.html#x:51"><span class="id" title="variable">x</span></a><a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">IA</span> <span class="id" title="var">M</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#haffine_hforall'"><span class="id" title="lemma">haffine_hforall'</span></a>. <span class="id" title="tactic">∃</span> (<span class="id" title="definition">arbitrary</span> (<span class="id" title="var">A</span>:=<span class="id" title="var">A</span>)). <span class="id" title="var">applys</span> <span class="id" title="var">M</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Another useful fact about <span class="inlinecode"><span class="id" title="var">haffine</span></span> is that to prove <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode">(<span class='gray-font'>\</span>[<span class="id" title="var">P</span>]</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H</span>)</span>
    it is sufficient to prove <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> under the hypothesis that <span class="inlinecode"><span class="id" title="var">P</span></span> is true.
    Formally: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="haffine_hstar_hpure_l" class="idref" href="#haffine_hstar_hpure_l"><span class="id" title="lemma">haffine_hstar_hpure_l</span></a> : <span class="id" title="keyword">∀</span> <a id="P:52" class="idref" href="#P:52"><span class="id" title="binder">P</span></a> <a id="H:53" class="idref" href="#H:53"><span class="id" title="binder">H</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#P:52"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:53"><span class="id" title="variable">H</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Affine.html#P:52"><span class="id" title="variable">P</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H:53"><span class="id" title="variable">H</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span> <span class="id" title="var">K</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.hstar_hpure_l"><span class="id" title="lemma">hstar_hpure_l</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">K</span>. <span class="id" title="var">applys</span>* <span class="id" title="var">M</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab391"></a><h2 class="section">The Affine-Top Heap Predicate: <span class="inlinecode">\<span class="id" title="var">GC</span></span></h2>

</div>

<div class="doc">
<a id="lab392"></a><h3 class="section">Definition of The Affine-Top Predicate</h3>

<div class="paragraph"> </div>

 We next introduce a new heap predicate, called "affine top", that is very
    handy for describing "the possibility to discard a heap predicate". We use
    this predicate to reformulate the discard rules in a more concise and usable
    manner. This predicate is written <span class="inlinecode">\<span class="id" title="var">GC</span></span> and named <span class="inlinecode"><span class="id" title="var">hgc</span></span> in the
    formalization. The predicate <span class="inlinecode">\<span class="id" title="var">GC</span></span> holds of any affine heap.

<div class="paragraph"> </div>

    The reason <span class="inlinecode">\<span class="id" title="var">GC</span></span> is named "affine top" is because it refines a
    representation predicate called "top", and written <span class="inlinecode">\<span class="id" title="var">Top</span></span>. The predicate
    <span class="inlinecode">\<span class="id" title="var">Top</span></span> is the heap predicate that holds of any heap. It can be defined as
    <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode">(<span class="id" title="var">h</span>:<span class="id" title="var">heap</span>)</span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">True</span></span>, or, equivalently, as <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode">(<span class="id" title="var">H</span>:<span class="id" title="var">hprop</span>),</span> <span class="inlinecode"><span class="id" title="var">H</span></span>. The
    characteristic property of <span class="inlinecode">\<span class="id" title="var">Top</span></span> is the entailment
    <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">H</span>,</span> <span class="inlinecode">(<span class="id" title="var">H</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode">\<span class="id" title="var">Top</span>)</span>.

<div class="paragraph"> </div>

    The affine top predicate <span class="inlinecode">\<span class="id" title="var">GC</span></span> can be defined as
    <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">H</span>,</span> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H</span>]</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H</span></span>. As we prove further on, it could be
    equivalently defined as <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span>. We prefer the former
    definition as it is easier to manipulate using the <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> tactic. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="hgc" class="idref" href="#hgc"><span class="id" title="definition">hgc</span></a> : <a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="H:54" class="idref" href="#H:54"><span class="id" title="binder">H</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:54"><span class="id" title="variable">H</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H:54"><span class="id" title="variable">H</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Declare Scope</span> <span class="id" title="var">hgc_scope</span>.<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">hgc_scope</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> <a id="60de723b3758066ad921153335e0c677" class="idref" href="#60de723b3758066ad921153335e0c677"><span class="id" title="notation">&quot;</span></a>\GC" := (<a class="idref" href="Affine.html#hgc"><span class="id" title="definition">hgc</span></a>) : <span class="id" title="var">hgc_scope</span>.<br/>
</div>

<div class="doc">
The following introduction lemma asserts that <span class="inlinecode">\<span class="id" title="var">GC</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> holds when <span class="inlinecode"><span class="id" title="var">h</span></span>
    satisfies <span class="inlinecode"><span class="id" title="var">heap_affine</span></span>. 
<div class="paragraph"> </div>

<a id="lab393"></a><h4 class="section">Exercise: 2 stars, standard, especially useful (triple_frame)</h4>
 Prove that the affine heap predicate holds of any affine heap. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="hgc_intro" class="idref" href="#hgc_intro"><span class="id" title="lemma">hgc_intro</span></a> : <span class="id" title="keyword">∀</span> <a id="h:55" class="idref" href="#h:55"><span class="id" title="binder">h</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h:55"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">h</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 The elimination lemma asserts the converse. 
<div class="paragraph"> </div>

<a id="lab394"></a><h4 class="section">Exercise: 2 stars, standard, optional (hgc_inv)</h4>
 Prove the elimination lemma for <span class="inlinecode">\<span class="id" title="var">GC</span></span> expressed using <span class="inlinecode"><span class="id" title="var">heap_affine</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="hgc_inv" class="idref" href="#hgc_inv"><span class="id" title="lemma">hgc_inv</span></a> : <span class="id" title="keyword">∀</span> <a id="h:56" class="idref" href="#h:56"><span class="id" title="binder">h</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h:56"><span class="id" title="variable">h</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 Together, the introduction and the elimination rule justify the fact that
    <span class="inlinecode"><span class="id" title="var">hgc</span></span> could equivalently have been defined as <span class="inlinecode"><span class="id" title="var">heap_affine</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="hgc_eq_heap_affine" class="idref" href="#hgc_eq_heap_affine"><span class="id" title="lemma">hgc_eq_heap_affine</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#hgc"><span class="id" title="definition">hgc</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.himpl_antisym"><span class="id" title="lemma">himpl_antisym</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span> <span class="id" title="var">M</span>. <span class="id" title="var">applys</span>* <a class="idref" href="Affine.html#hgc_inv"><span class="id" title="axiom">hgc_inv</span></a>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span> <span class="id" title="var">M</span>. <span class="id" title="var">applys</span>* <a class="idref" href="Affine.html#hgc_intro"><span class="id" title="axiom">hgc_intro</span></a>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab395"></a><h3 class="section">Properties of the Affine-Top Predicate</h3>

<div class="paragraph"> </div>

 One fundamental property of <span class="inlinecode">\<span class="id" title="var">GC</span></span> that is useful in the soundness proofs is
    that the conjunction of two occurences of <span class="inlinecode">\<span class="id" title="var">GC</span></span> may be merged into a single
    <span class="inlinecode">\<span class="id" title="var">GC</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="hstar_hgc_hgc" class="idref" href="#hstar_hgc_hgc"><span class="id" title="lemma">hstar_hgc_hgc</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#hgc"><span class="id" title="definition">hgc</span></a>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.himpl_antisym"><span class="id" title="lemma">himpl_antisym</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xpull</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H<sub>1</sub></span> <span class="id" title="var">K<sub>1</sub></span> <span class="id" title="var">H<sub>2</sub></span> <span class="id" title="var">K<sub>2</sub></span>. <span class="id" title="var">xsimpl</span> (<span class="id" title="var">H<sub>1</sub></span> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <span class="id" title="var">H<sub>2</sub></span>). <span class="id" title="var">applys</span>* <a class="idref" href="Affine.html#haffine_hstar"><span class="id" title="lemma">haffine_hstar</span></a>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xpull</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span> <span class="id" title="var">K</span>. <span class="id" title="var">xsimpl</span> <span class="id" title="var">H</span> <a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a>. <span class="id" title="tactic">auto</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#haffine_hempty"><span class="id" title="lemma">haffine_hempty</span></a>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Another useful property is that the heap predicate <span class="inlinecode">\<span class="id" title="var">GC</span></span> itself satisifes
    <span class="inlinecode"><span class="id" title="var">haffine</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="haffine_hgc" class="idref" href="#haffine_hgc"><span class="id" title="lemma">haffine_hgc</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="Affine.html#haffine_hexists"><span class="id" title="lemma">haffine_hexists</span></a>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#haffine_hstar_hpure_l"><span class="id" title="lemma">haffine_hstar_hpure_l</span></a>. <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The process of exploiting <span class="inlinecode">\<span class="id" title="var">GC</span></span> to "absorb" affine heap predicates is
    captured by the following lemma, which asserts that a heap predicate <span class="inlinecode"><span class="id" title="var">H</span></span>
    entails <span class="inlinecode">\<span class="id" title="var">GC</span></span> whenever <span class="inlinecode"><span class="id" title="var">H</span></span> is affine. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="himpl_hgc_r" class="idref" href="#himpl_hgc_r"><span class="id" title="lemma">himpl_hgc_r</span></a> : <span class="id" title="keyword">∀</span> <a id="H:57" class="idref" href="#H:57"><span class="id" title="binder">H</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:57"><span class="id" title="variable">H</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:57"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span> <span class="id" title="var">K</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#hgc_intro"><span class="id" title="axiom">hgc_intro</span></a>. <span class="id" title="var">applys</span> <span class="id" title="var">M</span> <span class="id" title="var">K</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
In particular, the empty heap predicate <span class="inlinecode"><span class='gray-font'>\</span>[]</span> entails <span class="inlinecode">\<span class="id" title="var">GC</span></span>, because the
    empty heap predicate is affine (lemma <span class="inlinecode"><span class="id" title="var">haffine_hempty</span></span>). 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="hempty_himpl_hgc" class="idref" href="#hempty_himpl_hgc"><span class="id" title="lemma">hempty_himpl_hgc</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#himpl_hgc_r"><span class="id" title="lemma">himpl_hgc_r</span></a>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#haffine_hempty"><span class="id" title="lemma">haffine_hempty</span></a>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab396"></a><h4 class="section">Exercise: 3 stars, standard, especially useful (himpl_hgc_absorb)</h4>
 Show that <span class="inlinecode">\<span class="id" title="var">GC</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">H</span></span> entails <span class="inlinecode">\<span class="id" title="var">GC</span></span> for any <span class="inlinecode"><span class="id" title="var">H</span></span> satisfying <span class="inlinecode"><span class="id" title="var">haffine</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="himpl_hgc_absorb_r" class="idref" href="#himpl_hgc_absorb_r"><span class="id" title="lemma">himpl_hgc_absorb_r</span></a> : <span class="id" title="keyword">∀</span> <a id="H:58" class="idref" href="#H:58"><span class="id" title="binder">H</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:58"><span class="id" title="variable">H</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H:58"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 Using the predicate <span class="inlinecode">\<span class="id" title="var">GC</span></span>, we can reformulate the constrained discard rule
    <span class="inlinecode"><span class="id" title="var">triple_haffine_post</span></span> as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_hgc_post" class="idref" href="#triple_hgc_post"><span class="id" title="axiom">triple_hgc_post</span></a> : <span class="id" title="keyword">∀</span> <a id="t:59" class="idref" href="#t:59"><span class="id" title="binder">t</span></a> <a id="H:60" class="idref" href="#H:60"><span class="id" title="binder">H</span></a> <a id="Q:61" class="idref" href="#Q:61"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:59"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:60"><span class="id" title="variable">H</span></a> (<a class="idref" href="Affine.html#Q:61"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:59"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:60"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:61"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
This rule is more concise than <span class="inlinecode"><span class="id" title="var">triple_haffine_post</span></span>. Moreover, the piece of
    heap being discarded, previously described by <span class="inlinecode"><span class="id" title="var">H'</span></span>, no longer needs to be
    provided up front, at the moment of applying the rule. Instead, it can be
    provided further on in the reasoning, by exploiting <span class="inlinecode"><span class="id" title="var">himpl_hgc_r</span></span> to prove
    an entailment of the form <span class="inlinecode"><span class="id" title="var">H'</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode">\<span class="id" title="var">GC</span></span>. 
</div>

<div class="doc">
<a id="lab397"></a><h2 class="section">Example Instantiations of <span class="inlinecode"><span class="id" title="var">heap_affine</span></span></h2>

</div>

<div class="doc">
<a id="lab398"></a><h3 class="section">Instantiation of <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> for a Fully Affine Logic</h3>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="FullyAffineLogic" class="idref" href="#FullyAffineLogic"><span class="id" title="module">FullyAffineLogic</span></a>.<br/>
</div>

<div class="doc">
To set up a fully affine logic, we consider a definition of <span class="inlinecode"><span class="id" title="var">heap_affine</span></span>
    that holds of any heap. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="FullyAffineLogic.heap_affine_def" class="idref" href="#FullyAffineLogic.heap_affine_def"><span class="id" title="axiom">heap_affine_def</span></a> : <span class="id" title="keyword">∀</span> <a id="h:63" class="idref" href="#h:63"><span class="id" title="binder">h</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h:63"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>
</div>

<div class="doc">
It is trivial to check that <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> satisfies the required
    distribution properties on the empty heap and the union of heaps. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="FullyAffineLogic.heap_affine_empty" class="idref" href="#FullyAffineLogic.heap_affine_empty"><span class="id" title="lemma">heap_affine_empty</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="LibSepReference.html#Fmap.empty"><span class="id" title="definition">Fmap.empty</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="tactic">rewrite</span>* <a class="idref" href="Affine.html#FullyAffineLogic.heap_affine_def"><span class="id" title="axiom">heap_affine_def</span></a>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="FullyAffineLogic.heap_affine_union" class="idref" href="#FullyAffineLogic.heap_affine_union"><span class="id" title="lemma">heap_affine_union</span></a> : <span class="id" title="keyword">∀</span> <a id="h<sub>1</sub>:65" class="idref" href="#h<sub>1</sub>:65"><span class="id" title="binder">h<sub>1</sub></span></a> <a id="h<sub>2</sub>:66" class="idref" href="#h<sub>2</sub>:66"><span class="id" title="binder">h<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:65"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:66"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.disjoint"><span class="id" title="definition">Fmap.disjoint</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:65"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:66"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> (<a class="idref" href="LibSepReference.html#Fmap.union"><span class="id" title="definition">Fmap.union</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:65"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:66"><span class="id" title="variable">h<sub>2</sub></span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">rewrite</span>* <a class="idref" href="Affine.html#FullyAffineLogic.heap_affine_def"><span class="id" title="axiom">heap_affine_def</span></a>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
With that instantiation, <span class="inlinecode"><span class="id" title="var">haffine</span></span> holds of any heap predicate. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="FullyAffineLogic.haffine_equiv" class="idref" href="#FullyAffineLogic.haffine_equiv"><span class="id" title="lemma">haffine_equiv</span></a> : <span class="id" title="keyword">∀</span> <a id="H:67" class="idref" href="#H:67"><span class="id" title="binder">H</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:67"><span class="id" title="variable">H</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">iff</span> <span class="id" title="var">M</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">auto</span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">rewrite</span>* <a class="idref" href="Affine.html#FullyAffineLogic.heap_affine_def"><span class="id" title="axiom">heap_affine_def</span></a>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Moreover, the affine top predicate <span class="inlinecode">\<span class="id" title="var">GC</span></span> is equivalent to the top predicate
    <span class="inlinecode"><span class="id" title="var">htop</span></span>, defined as <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">True</span></span> or equivalently as <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">H</span>,</span> <span class="inlinecode"><span class="id" title="var">H</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="FullyAffineLogic.htop" class="idref" href="#FullyAffineLogic.htop"><span class="id" title="definition">htop</span></a> : <a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="H:68" class="idref" href="#H:68"><span class="id" title="binder">H</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="Affine.html#H:68"><span class="id" title="variable">H</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="FullyAffineLogic.hgc_eq_htop" class="idref" href="#FullyAffineLogic.hgc_eq_htop"><span class="id" title="lemma">hgc_eq_htop</span></a> : <a class="idref" href="Affine.html#hgc"><span class="id" title="definition">hgc</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Affine.html#FullyAffineLogic.htop"><span class="id" title="definition">htop</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#hgc"><span class="id" title="definition">hgc</span></a>, <a class="idref" href="Affine.html#FullyAffineLogic.htop"><span class="id" title="definition">htop</span></a>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.himpl_antisym"><span class="id" title="lemma">himpl_antisym</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xsimpl</span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xsimpl</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">rewrite</span>* <a class="idref" href="Affine.html#FullyAffineLogic.haffine_equiv"><span class="id" title="lemma">haffine_equiv</span></a>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#FullyAffineLogic"><span class="id" title="module">FullyAffineLogic</span></a>.<br/>
</div>

<div class="doc">
<a id="lab399"></a><h3 class="section">Instantiation of <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> for a Fully Linear Logic</h3>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="FullyLinearLogic" class="idref" href="#FullyLinearLogic"><span class="id" title="module">FullyLinearLogic</span></a>.<br/>
</div>

<div class="doc">
To set up a fully affine logic, we consider a definition of <span class="inlinecode"><span class="id" title="var">heap_affine</span></span>
    that holds only of empty heaps. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="FullyLinearLogic.heap_affine_def" class="idref" href="#FullyLinearLogic.heap_affine_def"><span class="id" title="axiom">heap_affine_def</span></a> : <span class="id" title="keyword">∀</span> <a id="h:69" class="idref" href="#h:69"><span class="id" title="binder">h</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h:69"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#h:69"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#Fmap.empty"><span class="id" title="definition">Fmap.empty</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
Again, it is not hard to check that <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> satisfies the required
    distributivity properties. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="FullyLinearLogic.heap_affine_empty" class="idref" href="#FullyLinearLogic.heap_affine_empty"><span class="id" title="lemma">heap_affine_empty</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="LibSepReference.html#Fmap.empty"><span class="id" title="definition">Fmap.empty</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="tactic">rewrite</span>* <a class="idref" href="Affine.html#FullyLinearLogic.heap_affine_def"><span class="id" title="axiom">heap_affine_def</span></a>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="FullyLinearLogic.heap_affine_union" class="idref" href="#FullyLinearLogic.heap_affine_union"><span class="id" title="lemma">heap_affine_union</span></a> : <span class="id" title="keyword">∀</span> <a id="h<sub>1</sub>:71" class="idref" href="#h<sub>1</sub>:71"><span class="id" title="binder">h<sub>1</sub></span></a> <a id="h<sub>2</sub>:72" class="idref" href="#h<sub>2</sub>:72"><span class="id" title="binder">h<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:71"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:72"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.disjoint"><span class="id" title="definition">Fmap.disjoint</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:71"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:72"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> (<a class="idref" href="LibSepReference.html#Fmap.union"><span class="id" title="definition">Fmap.union</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:71"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:72"><span class="id" title="variable">h<sub>2</sub></span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">K<sub>1</sub></span> <span class="id" title="var">K<sub>2</sub></span> <span class="id" title="var">D</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="Affine.html#FullyLinearLogic.heap_affine_def"><span class="id" title="axiom">heap_affine_def</span></a> <span class="id" title="keyword">in</span> *.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">subst</span>. <span class="id" title="tactic">rewrite</span>* <a class="idref" href="LibSepReference.html#Fmap.union_empty_r"><span class="id" title="lemma">Fmap.union_empty_r</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
With that instantiation, the predicate <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> is equivalent to
    <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class='gray-font'>\</span>[]</span>, that is, it characterizes heap predicates that hold of the
    empty heap. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="FullyLinearLogic.haffine_equiv" class="idref" href="#FullyLinearLogic.haffine_equiv"><span class="id" title="lemma">haffine_equiv</span></a> : <span class="id" title="keyword">∀</span> <a id="H:73" class="idref" href="#H:73"><span class="id" title="binder">H</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:73"><span class="id" title="variable">H</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#H:73"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a>. <span class="id" title="var">iff</span> <span class="id" title="var">M</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span> <span class="id" title="var">K</span>. <span class="id" title="var">specializes</span> <span class="id" title="var">M</span> <span class="id" title="var">K</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="Affine.html#FullyLinearLogic.heap_affine_def"><span class="id" title="axiom">heap_affine_def</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">M</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">subst</span>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.hempty_intro"><span class="id" title="lemma">hempty_intro</span></a>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span> <span class="id" title="var">K</span>. <span class="id" title="var">specializes</span> <span class="id" title="var">M</span> <span class="id" title="var">K</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="Affine.html#FullyLinearLogic.heap_affine_def"><span class="id" title="axiom">heap_affine_def</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.hempty_inv"><span class="id" title="lemma">hempty_inv</span></a> <span class="id" title="var">M</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Moreover, the affine top predicate <span class="inlinecode">\<span class="id" title="var">GC</span></span> is equivalent to the empty heap
    predicate <span class="inlinecode"><span class="id" title="var">hempty</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="FullyLinearLogic.hgc_eq_hempty" class="idref" href="#FullyLinearLogic.hgc_eq_hempty"><span class="id" title="lemma">hgc_eq_hempty</span></a> : <a class="idref" href="Affine.html#hgc"><span class="id" title="definition">hgc</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#SepSimplArgs.hempty"><span class="id" title="definition">hempty</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#hgc"><span class="id" title="definition">hgc</span></a>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.himpl_antisym"><span class="id" title="lemma">himpl_antisym</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xpull</span>. <span class="id" title="var">introv</span> <span class="id" title="var">N</span>. <span class="id" title="tactic">rewrite</span>* <a class="idref" href="Affine.html#FullyLinearLogic.haffine_equiv"><span class="id" title="lemma">haffine_equiv</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">N</span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xsimpl</span> <a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#haffine_hempty"><span class="id" title="lemma">haffine_hempty</span></a>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#FullyLinearLogic"><span class="id" title="module">FullyLinearLogic</span></a>.<br/>
</div>

<div class="doc">
<a id="lab400"></a><h2 class="section">Definition of a Partially Affine Separation Logic</h2>

</div>

<div class="doc">
<a id="lab401"></a><h3 class="section">Refined Definition of Triples</h3>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="NewTriples" class="idref" href="#NewTriples"><span class="id" title="module">NewTriples</span></a>.<br/>
</div>

<div class="doc">
We now explain how to refine the notion of Separation Logic triple so as to
    accomodate the discard rule. Recall the previous definition of triples,
    capturing a linear logic.
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">triple</span> (<span class="id" title="var">t</span>:<span class="id" title="var">trm</span>) (<span class="id" title="var">H</span>:<span class="id" title="var">hprop</span>) (<span class="id" title="var">Q</span>:<span class="id" title="var">val</span>→<span class="id" title="var">hprop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">s</span>, <span class="id" title="var">H</span> <span class="id" title="var">s</span> → <span class="id" title="tactic">eval</span> <span class="id" title="var">s</span> <span class="id" title="var">t</span> <span class="id" title="var">Q</span>.
</span>    The new discard rule <span class="inlinecode"><span class="id" title="var">triple_htop_post</span></span> asserts that postconditions may be
    freely extended with the <span class="inlinecode">\<span class="id" title="var">GC</span></span> predicate. To support this rule, it suffices
    to modify the definition of <span class="inlinecode"><span class="id" title="var">triple</span></span> to include the predicate <span class="inlinecode">\<span class="id" title="var">GC</span></span> in the
    postcondition of the underlying Hoare triple, as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="NewTriples.triple" class="idref" href="#NewTriples.triple"><span class="id" title="definition">triple</span></a> (<a id="t:74" class="idref" href="#t:74"><span class="id" title="binder">t</span></a>:<a class="idref" href="LibSepReference.html#trm"><span class="id" title="inductive">trm</span></a>) (<a id="H:75" class="idref" href="#H:75"><span class="id" title="binder">H</span></a>:<a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>) (<a id="Q:76" class="idref" href="#Q:76"><span class="id" title="binder">Q</span></a>:<a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a id="s:77" class="idref" href="#s:77"><span class="id" title="binder">s</span></a>, <a class="idref" href="Affine.html#H:75"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#s:77"><span class="id" title="variable">s</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Affine.html#s:77"><span class="id" title="variable">s</span></a> <a class="idref" href="Affine.html#t:74"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#Q:76"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>).<br/>
</div>

<div class="doc">
Next, for the updated definition of <span class="inlinecode"><span class="id" title="var">triple</span></span> using <span class="inlinecode">\<span class="id" title="var">GC</span></span>, we establish:

<div class="paragraph"> </div>

<ul class="doclist">
<li> that all the existing reasoning rules of Separation Logic remain sound,
      and

</li>
<li> that the new discard rules <span class="inlinecode"><span class="id" title="var">triple_htop_post</span></span>, <span class="inlinecode"><span class="id" title="var">triple_haffine_hpost</span></span>, and
      <span class="inlinecode"><span class="id" title="var">triple_haffine_hpre</span></span> are provable. 

</li>
</ul>
</div>

<div class="doc">
<a id="lab402"></a><h3 class="section">Soundness of the Existing Rules</h3>

<div class="paragraph"> </div>

 Let us update the soundness proof of the rules of Separation Logic to
    account for the addition of <span class="inlinecode">\<span class="id" title="var">GC</span></span> in the definition of <span class="inlinecode"><span class="id" title="var">triples</span></span>. All the
    rules are proved using exactly the same proof scripts as before, with
    <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> possibly performing extra work for cancelling out occurrences of
    <span class="inlinecode">\<span class="id" title="var">GC</span></span> on both sides of an entailment. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.triple_conseq" class="idref" href="#NewTriples.triple_conseq"><span class="id" title="lemma">triple_conseq</span></a> : <span class="id" title="keyword">∀</span> <a id="t:78" class="idref" href="#t:78"><span class="id" title="binder">t</span></a> <a id="H':79" class="idref" href="#H':79"><span class="id" title="binder">H'</span></a> <a id="Q':80" class="idref" href="#Q':80"><span class="id" title="binder">Q'</span></a> <a id="H:81" class="idref" href="#H:81"><span class="id" title="binder">H</span></a> <a id="Q:82" class="idref" href="#Q:82"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:78"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H':79"><span class="id" title="variable">H'</span></a> <a class="idref" href="Affine.html#Q':80"><span class="id" title="variable">Q'</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:81"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#H':79"><span class="id" title="variable">H'</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#Q':80"><span class="id" title="variable">Q'</span></a> <a class="idref" href="LibSepReference.html#9351a4f098e275023c32e0091e608189"><span class="id" title="notation">===&gt;</span></a> <a class="idref" href="Affine.html#Q:82"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:78"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:81"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:82"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">unfolds</span> <a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span> <span class="id" title="var">MH</span> <span class="id" title="var">MQ</span> <span class="id" title="var">HF</span>. <span class="id" title="var">applys</span>* <a class="idref" href="LibSepReference.html#eval_conseq"><span class="id" title="lemma">eval_conseq</span></a>. <span class="id" title="var">xsimpl</span>*.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="NewTriples.triple_frame" class="idref" href="#NewTriples.triple_frame"><span class="id" title="lemma">triple_frame</span></a> : <span class="id" title="keyword">∀</span> <a id="t:83" class="idref" href="#t:83"><span class="id" title="binder">t</span></a> <a id="H:84" class="idref" href="#H:84"><span class="id" title="binder">H</span></a> <a id="Q:85" class="idref" href="#Q:85"><span class="id" title="binder">Q</span></a> <a id="H':86" class="idref" href="#H':86"><span class="id" title="binder">H'</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:83"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:84"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:85"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:83"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#H:84"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H':86"><span class="id" title="variable">H'</span></a>) (<a class="idref" href="Affine.html#Q:85"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H':86"><span class="id" title="variable">H'</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">M</span> <span class="id" title="var">HF</span>. <span class="id" title="var">lets</span> (<span class="id" title="var">h<sub>1</sub></span>&amp;<span class="id" title="var">h<sub>2</sub></span>&amp;<span class="id" title="var">M<sub>1</sub></span>&amp;<span class="id" title="var">M<sub>2</sub></span>&amp;<span class="id" title="var">MD</span>&amp;<span class="id" title="var">MU</span>): <a class="idref" href="LibSepReference.html#SepSimplArgs.hstar_inv"><span class="id" title="lemma">hstar_inv</span></a> (<span class="id" title="definition">rm</span> <span class="id" title="var">HF</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">subst</span>. <span class="id" title="var">specializes</span> <span class="id" title="var">M</span> <span class="id" title="var">M<sub>1</sub></span>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#eval_conseq"><span class="id" title="lemma">eval_conseq</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#eval_frame"><span class="id" title="lemma">eval_frame</span></a> <span class="id" title="var">M</span> <span class="id" title="var">MD</span>. } { <span class="id" title="var">xsimpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">h'</span> →. <span class="id" title="var">applys</span> <span class="id" title="var">M<sub>2</sub></span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="NewTriples.triple_hpure" class="idref" href="#NewTriples.triple_hpure"><span class="id" title="lemma">triple_hpure</span></a> : <span class="id" title="keyword">∀</span> <a id="t:87" class="idref" href="#t:87"><span class="id" title="binder">t</span></a> (<a id="P:88" class="idref" href="#P:88"><span class="id" title="binder">P</span></a>:<span class="id" title="keyword">Prop</span>) <a id="H:89" class="idref" href="#H:89"><span class="id" title="binder">H</span></a> <a id="Q:90" class="idref" href="#Q:90"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#P:88"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:87"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:89"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:90"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:87"><span class="id" title="variable">t</span></a> (<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Affine.html#P:88"><span class="id" title="variable">P</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H:89"><span class="id" title="variable">H</span></a>) <a class="idref" href="Affine.html#Q:90"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span> (<span class="id" title="var">h<sub>1</sub></span>&amp;<span class="id" title="var">h<sub>2</sub></span>&amp;<span class="id" title="var">M<sub>1</sub></span>&amp;<span class="id" title="var">M<sub>2</sub></span>&amp;<span class="id" title="var">D</span>&amp;<span class="id" title="var">U</span>). <span class="id" title="tactic">destruct</span> <span class="id" title="var">M<sub>1</sub></span> <span class="id" title="keyword">as</span> (<span class="id" title="var">M<sub>1</sub></span>&amp;<span class="id" title="var">HP</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">lets</span> <span class="id" title="var">E</span>: <a class="idref" href="LibSepReference.html#SepSimplArgs.hempty_inv"><span class="id" title="lemma">hempty_inv</span></a> <span class="id" title="var">HP</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="LibSepReference.html#Fmap.union_empty_l"><span class="id" title="lemma">Fmap.union_empty_l</span></a>. <span class="id" title="var">applys</span>¬<span class="id" title="var">M</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="NewTriples.triple_hexists" class="idref" href="#NewTriples.triple_hexists"><span class="id" title="lemma">triple_hexists</span></a> : <span class="id" title="keyword">∀</span> <a id="t:91" class="idref" href="#t:91"><span class="id" title="binder">t</span></a> (<a id="A:92" class="idref" href="#A:92"><span class="id" title="binder">A</span></a>:<span class="id" title="keyword">Type</span>) (<a id="J:93" class="idref" href="#J:93"><span class="id" title="binder">J</span></a>:<a class="idref" href="Affine.html#A:92"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>) <a id="Q:94" class="idref" href="#Q:94"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> (<a id="x:95" class="idref" href="#x:95"><span class="id" title="binder">x</span></a>:<a class="idref" href="Affine.html#A:92"><span class="id" title="variable">A</span></a>), <a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:91"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#J:93"><span class="id" title="variable">J</span></a> <a class="idref" href="Affine.html#x:95"><span class="id" title="variable">x</span></a>) <a class="idref" href="Affine.html#Q:94"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:91"><span class="id" title="variable">t</span></a> (<a class="idref" href="LibSepReference.html#SepSimplArgs.hexists"><span class="id" title="definition">hexists</span></a> <a class="idref" href="Affine.html#J:93"><span class="id" title="variable">J</span></a>) <a class="idref" href="Affine.html#Q:94"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span> (<span class="id" title="var">x</span>&amp;<span class="id" title="var">K</span>). <span class="id" title="var">applys</span> <span class="id" title="var">M</span> <span class="id" title="var">K</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
We also need to update the reasoning rules for terms. We present one
    representative example: the proof rule for sequences. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.triple_seq" class="idref" href="#NewTriples.triple_seq"><span class="id" title="lemma">triple_seq</span></a> : <span class="id" title="keyword">∀</span> <a id="t<sub>1</sub>:96" class="idref" href="#t<sub>1</sub>:96"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:97" class="idref" href="#t<sub>2</sub>:97"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="H:98" class="idref" href="#H:98"><span class="id" title="binder">H</span></a> <a id="Q:99" class="idref" href="#Q:99"><span class="id" title="binder">Q</span></a> <a id="H<sub>1</sub>:100" class="idref" href="#H<sub>1</sub>:100"><span class="id" title="binder">H<sub>1</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t<sub>1</sub>:96"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Affine.html#H:98"><span class="id" title="variable">H</span></a> (<span class="id" title="keyword">fun</span> <a id="v:101" class="idref" href="#v:101"><span class="id" title="binder">v</span></a> ⇒ <a class="idref" href="Affine.html#H<sub>1</sub>:100"><span class="id" title="variable">H<sub>1</sub></span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t<sub>2</sub>:97"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:100"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Affine.html#Q:99"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_seq"><span class="id" title="constructor">trm_seq</span></a> <a class="idref" href="Affine.html#t<sub>1</sub>:96"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Affine.html#t<sub>2</sub>:97"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Affine.html#H:98"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:99"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
</div>

<div class="doc">
The proof is structured like in lemma <span class="inlinecode"><span class="id" title="var">triple_seq</span></span> from chapter
    <a href="Rules.html"><span class="inlineref">Rules</span></a>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a>. <span class="id" title="var">introv</span> <span class="id" title="var">M<sub>1</sub></span> <span class="id" title="var">M<sub>2</sub></span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">s</span> <span class="id" title="var">Hs</span>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#eval_seq"><span class="id" title="constructor">eval_seq</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <span class="id" title="var">M<sub>1</sub></span> <span class="id" title="var">Hs</span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">v<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">Hs<sub>2</sub></span>. <span class="id" title="var">lets</span> (<span class="id" title="var">h<sub>1</sub></span>&amp;<span class="id" title="var">h<sub>2</sub></span>&amp;<span class="id" title="var">N<sub>1</sub></span>&amp;<span class="id" title="var">N<sub>2</sub></span>&amp;<span class="id" title="var">D</span>&amp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>): <a class="idref" href="LibSepReference.html#SepSimplArgs.hstar_inv"><span class="id" title="lemma">hstar_inv</span></a> (<span class="id" title="definition">rm</span> <span class="id" title="var">Hs<sub>2</sub></span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#eval_conseq"><span class="id" title="lemma">eval_conseq</span></a>. { <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#eval_frame"><span class="id" title="lemma">eval_frame</span></a> <span class="id" title="var">D</span>. <span class="id" title="var">applys</span>* <span class="id" title="var">M<sub>2</sub></span>. }<br/>
</div>

<div class="doc">
The main difference is the need to to invoke the lemma <span class="inlinecode"><span class="id" title="var">hstar_hgc_hgc</span></span> for
    merging the left-over that originates from <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> with the <span class="inlinecode">\<span class="id" title="var">GC</span></span> that
    originates from <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> into a single <span class="inlinecode">\<span class="id" title="var">GC</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">asserts</span> <span class="id" title="var">R</span>: (<a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">(</span></a><span class="id" title="notation">=</span> <span class="id" title="var">h<sub>2</sub></span><a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>). { <span class="id" title="tactic">intros</span> ? →. <span class="id" title="tactic">auto</span>. } <span class="id" title="var">xchange</span> (<span class="id" title="definition">rm</span> <span class="id" title="var">R</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">xchange</span> <a class="idref" href="Affine.html#hstar_hgc_hgc"><span class="id" title="lemma">hstar_hgc_hgc</span></a>. <span class="id" title="var">xsimpl</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab403"></a><h3 class="section">Soundness of the Discard Rules</h3>

<div class="paragraph"> </div>

 Let us first establish the soundness of the discard rule <span class="inlinecode"><span class="id" title="var">triple_htop_post</span></span>.
    
<div class="paragraph"> </div>

<a id="lab404"></a><h4 class="section">Exercise: 3 stars, standard, especially useful (triple_hgc_post)</h4>
 Prove <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span> with respect to the refined definition of <span class="inlinecode"><span class="id" title="var">triple</span></span>
    that includes <span class="inlinecode">\<span class="id" title="var">GC</span></span> in the postcondition. Hint: exploit <span class="inlinecode"><span class="id" title="var">hstar_hgc_hgc</span></span>,
    with help from the tactics <span class="inlinecode"><span class="id" title="var">xchange</span></span> and <span class="inlinecode"><span class="id" title="var">xsimpl</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.triple_hgc_post" class="idref" href="#NewTriples.triple_hgc_post"><span class="id" title="lemma">triple_hgc_post</span></a> : <span class="id" title="keyword">∀</span> <a id="t:102" class="idref" href="#t:102"><span class="id" title="binder">t</span></a> <a id="H:103" class="idref" href="#H:103"><span class="id" title="binder">H</span></a> <a id="Q:104" class="idref" href="#Q:104"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:102"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:103"><span class="id" title="variable">H</span></a> (<a class="idref" href="Affine.html#Q:104"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:102"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:103"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:104"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab405"></a><h4 class="section">Exercise: 1 star, standard, especially useful (triple_haffine_post)</h4>
 Prove that <span class="inlinecode"><span class="id" title="var">triple_haffine_post</span></span> is derivable from <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span>. Hint:
    use the property <span class="inlinecode"><span class="id" title="var">himpl_hgc_r</span></span>, which asserts <span class="inlinecode"><span class="id" title="var">H'</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode">\<span class="id" title="var">GC</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.triple_haffine_post" class="idref" href="#NewTriples.triple_haffine_post"><span class="id" title="lemma">triple_haffine_post</span></a> : <span class="id" title="keyword">∀</span> <a id="t:105" class="idref" href="#t:105"><span class="id" title="binder">t</span></a> <a id="H:106" class="idref" href="#H:106"><span class="id" title="binder">H</span></a> <a id="H':107" class="idref" href="#H':107"><span class="id" title="binder">H'</span></a> <a id="Q:108" class="idref" href="#Q:108"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H':107"><span class="id" title="variable">H'</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:105"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:106"><span class="id" title="variable">H</span></a> (<a class="idref" href="Affine.html#Q:108"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H':107"><span class="id" title="variable">H'</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:105"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:106"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:108"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab406"></a><h4 class="section">Exercise: 1 star, standard, optional (triple_hgc_post_from_triple_haffine_post)</h4>
 Conversely, prove that <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span> is derivable from
    <span class="inlinecode"><span class="id" title="var">triple_haffine_post</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.triple_hgc_post_from_triple_haffine_post" class="idref" href="#NewTriples.triple_hgc_post_from_triple_haffine_post"><span class="id" title="lemma">triple_hgc_post_from_triple_haffine_post</span></a> : <span class="id" title="keyword">∀</span> <a id="t:109" class="idref" href="#t:109"><span class="id" title="binder">t</span></a> <a id="H:110" class="idref" href="#H:110"><span class="id" title="binder">H</span></a> <a id="Q:111" class="idref" href="#Q:111"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:109"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:110"><span class="id" title="variable">H</span></a> (<a class="idref" href="Affine.html#Q:111"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:109"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:110"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:111"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab407"></a><h4 class="section">Exercise: 1 star, standard, optional (triple_haffine_pre)</h4>
 Prove that <span class="inlinecode"><span class="id" title="var">triple_haffine_pre</span></span> is derivable from <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span>. Hint:
    exploit the frame rule, and leverage <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span> either directly or by
    invoking its corollary <span class="inlinecode"><span class="id" title="var">triple_haffine_post</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.triple_haffine_pre" class="idref" href="#NewTriples.triple_haffine_pre"><span class="id" title="lemma">triple_haffine_pre</span></a> : <span class="id" title="keyword">∀</span> <a id="t:112" class="idref" href="#t:112"><span class="id" title="binder">t</span></a> <a id="H:113" class="idref" href="#H:113"><span class="id" title="binder">H</span></a> <a id="H':114" class="idref" href="#H':114"><span class="id" title="binder">H'</span></a> <a id="Q:115" class="idref" href="#Q:115"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H':114"><span class="id" title="variable">H'</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:112"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:113"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:115"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:112"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#H:113"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H':114"><span class="id" title="variable">H'</span></a>) <a class="idref" href="Affine.html#Q:115"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab408"></a><h3 class="section">Combined Structural Rules</h3>

<div class="paragraph"> </div>

<a id="lab409"></a><h4 class="section">Exercise: 2 stars, standard, optional (triple_conseq_frame_hgc)</h4>
 Prove the combined structural rule <span class="inlinecode"><span class="id" title="var">triple_conseq_frame_hgc</span></span>, which extends
    <span class="inlinecode"><span class="id" title="var">triple_conseq_frame</span></span> with the discard rule, replacing <span class="inlinecode"><span class="id" title="var">Q<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*+</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> <span class="inlinecode">===&gt;</span> <span class="inlinecode"><span class="id" title="var">Q</span></span>
    with <span class="inlinecode"><span class="id" title="var">Q<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*+</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> <span class="inlinecode">===&gt;</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*+</span> <span class="inlinecode">\<span class="id" title="var">GC</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.triple_conseq_frame_hgc" class="idref" href="#NewTriples.triple_conseq_frame_hgc"><span class="id" title="lemma">triple_conseq_frame_hgc</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>2</sub>:116" class="idref" href="#H<sub>2</sub>:116"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="H<sub>1</sub>:117" class="idref" href="#H<sub>1</sub>:117"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="Q<sub>1</sub>:118" class="idref" href="#Q<sub>1</sub>:118"><span class="id" title="binder">Q<sub>1</sub></span></a> <a id="t:119" class="idref" href="#t:119"><span class="id" title="binder">t</span></a> <a id="H:120" class="idref" href="#H:120"><span class="id" title="binder">H</span></a> <a id="Q:121" class="idref" href="#Q:121"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:119"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:117"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Affine.html#Q<sub>1</sub>:118"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:120"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:117"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:116"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#Q<sub>1</sub>:118"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:116"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#9351a4f098e275023c32e0091e608189"><span class="id" title="notation">===&gt;</span></a> <a class="idref" href="Affine.html#Q:121"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:119"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:120"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:121"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab410"></a><h4 class="section">Exercise: 1 star, standard, optional (triple_ramified_frame_hgc)</h4>
 Prove the following generalization of the ramified frame rule that includes
    the discard rule. Hint: take inspiration from the proof of
    <span class="inlinecode"><span class="id" title="var">triple_ramified_frame</span></span> presented in the chapter <a href="Wand.html"><span class="inlineref">Wand</span></a>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.triple_ramified_frame_hgc" class="idref" href="#NewTriples.triple_ramified_frame_hgc"><span class="id" title="lemma">triple_ramified_frame_hgc</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:122" class="idref" href="#H<sub>1</sub>:122"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="Q<sub>1</sub>:123" class="idref" href="#Q<sub>1</sub>:123"><span class="id" title="binder">Q<sub>1</sub></span></a> <a id="t:124" class="idref" href="#t:124"><span class="id" title="binder">t</span></a> <a id="H:125" class="idref" href="#H:125"><span class="id" title="binder">H</span></a> <a id="Q:126" class="idref" href="#Q:126"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:124"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:122"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Affine.html#Q<sub>1</sub>:123"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:125"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:122"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#Q<sub>1</sub>:123"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation"><span class='gray-font'>\</span><span class="nowrap">&minus;&minus;&lowast;</span></span></a> <a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#Q:126"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a><a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation">)</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:124"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:125"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:126"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab411"></a><h1 class="section">More Details</h1>

</div>

<div class="doc">
<a id="lab412"></a><h2 class="section">Discard Rules in WP Style</h2>

</div>

<div class="doc">
<a id="lab413"></a><h3 class="section">Definition of WP for a Partially Affine Separation Logic</h3>

<div class="paragraph"> </div>

 In chapter <a href="WPsem.html"><span class="inlineref">WPsem</span></a>, we defined <span class="inlinecode"><span class="id" title="var">wp</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">s</span></span> as <span class="inlinecode"><span class="id" title="tactic">eval</span></span> <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span>. To account
    for affine heaps, we refine the definition to <span class="inlinecode"><span class="id" title="tactic">eval</span></span> <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">(<span class="id" title="var">Q</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*+</span> <span class="inlinecode">\<span class="id" title="var">GC</span>)</span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="NewTriples.wp" class="idref" href="#NewTriples.wp"><span class="id" title="definition">wp</span></a> (<a id="t:127" class="idref" href="#t:127"><span class="id" title="binder">t</span></a>:<a class="idref" href="LibSepReference.html#trm"><span class="id" title="inductive">trm</span></a>) (<a id="Q:128" class="idref" href="#Q:128"><span class="id" title="binder">Q</span></a>:<a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>) : <a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="s:129" class="idref" href="#s:129"><span class="id" title="binder">s</span></a> ⇒ <a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> <a class="idref" href="Affine.html#s:129"><span class="id" title="variable">s</span></a> <a class="idref" href="Affine.html#t:127"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#Q:128"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>).<br/>
</div>

<div class="doc">
The characteristic equivalence of <span class="inlinecode"><span class="id" title="var">wp</span></span> remains valid, with respect to the
    definition of <span class="inlinecode"><span class="id" title="var">wp</span></span> extended with <span class="inlinecode">\<span class="id" title="var">GC</span></span> and the definition of <span class="inlinecode"><span class="id" title="var">triple</span></span>
    extended with <span class="inlinecode">\<span class="id" title="var">GC</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.wp_equiv" class="idref" href="#NewTriples.wp_equiv"><span class="id" title="lemma">wp_equiv</span></a> : <span class="id" title="keyword">∀</span> <a id="t:130" class="idref" href="#t:130"><span class="id" title="binder">t</span></a> <a id="H:131" class="idref" href="#H:131"><span class="id" title="binder">H</span></a> <a id="Q:132" class="idref" href="#Q:132"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#H:131"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a> <a class="idref" href="Affine.html#t:130"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#Q:132"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:130"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:131"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:132"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">iff</span> <span class="id" title="var">M</span>; <span class="id" title="var">introv</span> <span class="id" title="var">Hs</span>; <span class="id" title="var">applys</span> <span class="id" title="var">M</span> <span class="id" title="var">Hs</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The structural reasoning rules also remain valid. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.wp_conseq" class="idref" href="#NewTriples.wp_conseq"><span class="id" title="lemma">wp_conseq</span></a> : <span class="id" title="keyword">∀</span> <a id="t:133" class="idref" href="#t:133"><span class="id" title="binder">t</span></a> <a id="Q<sub>1</sub>:134" class="idref" href="#Q<sub>1</sub>:134"><span class="id" title="binder">Q<sub>1</sub></span></a> <a id="Q<sub>2</sub>:135" class="idref" href="#Q<sub>2</sub>:135"><span class="id" title="binder">Q<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#Q<sub>1</sub>:134"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#9351a4f098e275023c32e0091e608189"><span class="id" title="notation">===&gt;</span></a> <a class="idref" href="Affine.html#Q<sub>2</sub>:135"><span class="id" title="variable">Q<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a> <a class="idref" href="Affine.html#t:133"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#Q<sub>1</sub>:134"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a> <a class="idref" href="Affine.html#t:133"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#Q<sub>2</sub>:135"><span class="id" title="variable">Q<sub>2</sub></span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">s</span> <span class="id" title="var">Hs</span>. <span class="id" title="var">applys</span>* <a class="idref" href="LibSepReference.html#eval_conseq"><span class="id" title="lemma">eval_conseq</span></a>. <span class="id" title="var">xsimpl</span>*.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="NewTriples.wp_frame" class="idref" href="#NewTriples.wp_frame"><span class="id" title="lemma">wp_frame</span></a> : <span class="id" title="keyword">∀</span> <a id="t:136" class="idref" href="#t:136"><span class="id" title="binder">t</span></a> <a id="H:137" class="idref" href="#H:137"><span class="id" title="binder">H</span></a> <a id="Q:138" class="idref" href="#Q:138"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a> <a class="idref" href="Affine.html#t:136"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#Q:138"><span class="id" title="variable">Q</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H:137"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a> <a class="idref" href="Affine.html#t:136"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#Q:138"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H:137"><span class="id" title="variable">H</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a>. <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span> <span class="id" title="var">HF</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">lets</span> (<span class="id" title="var">h<sub>1</sub></span>&amp;<span class="id" title="var">h<sub>2</sub></span>&amp;<span class="id" title="var">M<sub>1</sub></span>&amp;<span class="id" title="var">M<sub>2</sub></span>&amp;<span class="id" title="var">MD</span>&amp;<span class="id" title="var">MU</span>): <a class="idref" href="LibSepReference.html#SepSimplArgs.hstar_inv"><span class="id" title="lemma">hstar_inv</span></a> (<span class="id" title="definition">rm</span> <span class="id" title="var">HF</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">subst</span>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#eval_conseq"><span class="id" title="lemma">eval_conseq</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#eval_frame"><span class="id" title="lemma">eval_frame</span></a> <span class="id" title="var">M<sub>1</sub></span> <span class="id" title="var">MD</span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xsimpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">h'</span> →. <span class="id" title="var">applys</span> <span class="id" title="var">M<sub>2</sub></span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
In weakest precondition style, the discard rule <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span> translates
    into the entailment <span class="inlinecode"><span class="id" title="var">wp</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">(<span class="id" title="var">Q</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*+</span> <span class="inlinecode">\<span class="id" title="var">GC</span>)</span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class="id" title="var">wp</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span>. 
<div class="paragraph"> </div>

<a id="lab414"></a><h4 class="section">Exercise: 1 star, standard, optional (wp_hgc_post)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a id="NewTriples.wp_hgc_post" class="idref" href="#NewTriples.wp_hgc_post"><span class="id" title="lemma">wp_hgc_post</span></a> : <span class="id" title="keyword">∀</span> <a id="t:139" class="idref" href="#t:139"><span class="id" title="binder">t</span></a> <a id="Q:140" class="idref" href="#Q:140"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a> <a class="idref" href="Affine.html#t:139"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#Q:140"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>) <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a> <a class="idref" href="Affine.html#t:139"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#Q:140"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 The wp-style presentation of the rule <span class="inlinecode"><span class="id" title="var">triple_hgc_pre</span></span> is captured by the
    lemma <span class="inlinecode"><span class="id" title="var">wp_haffine_pre</span></span> shown below. 
<div class="paragraph"> </div>

<a id="lab415"></a><h4 class="section">Exercise: 3 stars, standard, optional (wp_haffine_pre)</h4>
 Prove <span class="inlinecode"><span class="id" title="var">wp_haffine_pre</span></span>. Hint: one possibility is to use <span class="inlinecode"><span class="id" title="var">eval_conseq</span></span> and
    <span class="inlinecode"><span class="id" title="var">wp_frame</span></span>, as well as <span class="inlinecode"><span class="id" title="var">himpl_hgc_r</span></span> and <span class="inlinecode"><span class="id" title="var">hstar_hgc_hgc</span></span>. Another
    possibility is to refine the proof of <span class="inlinecode"><span class="id" title="var">wp_frame</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.wp_haffine_pre" class="idref" href="#NewTriples.wp_haffine_pre"><span class="id" title="lemma">wp_haffine_pre</span></a> : <span class="id" title="keyword">∀</span> <a id="t:141" class="idref" href="#t:141"><span class="id" title="binder">t</span></a> <a id="H:142" class="idref" href="#H:142"><span class="id" title="binder">H</span></a> <a id="Q:143" class="idref" href="#Q:143"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:142"><span class="id" title="variable">H</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a> <a class="idref" href="Affine.html#t:141"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#Q:143"><span class="id" title="variable">Q</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H:142"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a> <a class="idref" href="Affine.html#t:141"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#Q:143"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 The revised presentation of the wp-style ramified frame rule includes an
    extra <span class="inlinecode">\<span class="id" title="var">GC</span></span> predicate. This rule captures at once all the structural
    properties of Separation Logic, including the discard rule. 
<div class="paragraph"> </div>

<a id="lab416"></a><h4 class="section">Exercise: 3 stars, standard, optional (wp_haffine_pre)</h4>
 Prove <span class="inlinecode"><span class="id" title="var">wp_ramified</span></span> with support for <span class="inlinecode">\<span class="id" title="var">GC</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.wp_ramified" class="idref" href="#NewTriples.wp_ramified"><span class="id" title="lemma">wp_ramified</span></a> : <span class="id" title="keyword">∀</span> <a id="Q<sub>1</sub>:144" class="idref" href="#Q<sub>1</sub>:144"><span class="id" title="binder">Q<sub>1</sub></span></a> <a id="Q<sub>2</sub>:145" class="idref" href="#Q<sub>2</sub>:145"><span class="id" title="binder">Q<sub>2</sub></span></a> <a id="t:146" class="idref" href="#t:146"><span class="id" title="binder">t</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a> <a class="idref" href="Affine.html#t:146"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#Q<sub>1</sub>:144"><span class="id" title="variable">Q<sub>1</sub></span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#Q<sub>1</sub>:144"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation"><span class='gray-font'>\</span><span class="nowrap">&minus;&minus;&lowast;</span></span></a> <a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#Q<sub>2</sub>:145"><span class="id" title="variable">Q<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a><a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation">)</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a> <a class="idref" href="Affine.html#t:146"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#Q<sub>2</sub>:145"><span class="id" title="variable">Q<sub>2</sub></span></a><a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab417"></a><h3 class="section">Exploiting the Discard Rule in Proofs</h3>

<div class="paragraph"> </div>

 In a practical verification proof, there are two useful ways to discard heap
    predicates that are no longer needed:

<div class="paragraph"> </div>

<ul class="doclist">
<li> by invoking <span class="inlinecode"><span class="id" title="var">triple_haffine_pre</span></span> to remove a specific
      predicate from the current state, i.e., the precondition; or

</li>
<li> by invoking <span class="inlinecode"><span class="id" title="var">triple_htop_post</span></span> to add a <span class="inlinecode">\<span class="id" title="var">GC</span></span> into the
      current postcondition and allow subsequent removal of any
      predicate that may be left-over in the final entailment
      justifying that the final state satisfies the postcondition.

</li>
</ul>

<div class="paragraph"> </div>

    Eager removal of predicates from the current state is never necessary: one
    can always be lazy and postpone the application of the discard rule until
    the last step of reasoning.

<div class="paragraph"> </div>

    It is cumbersome for the user to anticipate, right from the beginning of the
    proof of a function, the need to discard heap predicates at the last line of
    the function body. To ease the work of the user, it suffices to
    systematically apply the rule <span class="inlinecode"><span class="id" title="var">triple_htop_post</span></span> as very first step of the
    proof of every function. The effect is to extend the postcondition of the
    function with a <span class="inlinecode">\<span class="id" title="var">GC</span></span> predicate. This predicate may be used to absorb any
    garbage left-over at the end of the proof of the function body. If there is
    no such garbage, the tactic <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> automatically discards the <span class="inlinecode">\<span class="id" title="var">GC</span></span>
    predicate.

<div class="paragraph"> </div>

    We implement this strategy by integrating the rule <span class="inlinecode"><span class="id" title="var">triple_htop_post</span></span> into
    the tactic <span class="inlinecode"><span class="id" title="var">xwp</span></span>, which sets up the verification proof by computing the
    characteristic formula. To that end, we generalize the lemma <span class="inlinecode"><span class="id" title="var">xwp_lemma</span></span>,
    which the tactic <span class="inlinecode"><span class="id" title="var">xwp</span></span> applies. Its original statement is as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="NewTriples.xwp_lemma" class="idref" href="#NewTriples.xwp_lemma"><span class="id" title="axiom">xwp_lemma</span></a> : <span class="id" title="keyword">∀</span> <a id="v<sub>1</sub>:147" class="idref" href="#v<sub>1</sub>:147"><span class="id" title="binder">v<sub>1</sub></span></a> <a id="v<sub>2</sub>:148" class="idref" href="#v<sub>2</sub>:148"><span class="id" title="binder">v<sub>2</sub></span></a> <a id="x:149" class="idref" href="#x:149"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:150" class="idref" href="#t<sub>1</sub>:150"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="H:151" class="idref" href="#H:151"><span class="id" title="binder">H</span></a> <a id="Q:152" class="idref" href="#Q:152"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#v<sub>1</sub>:147"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_fun"><span class="id" title="constructor">val_fun</span></a> <a class="idref" href="Affine.html#x:149"><span class="id" title="variable">x</span></a> <a class="idref" href="Affine.html#t<sub>1</sub>:150"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:151"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#wpgen"><span class="id" title="definition">wpgen</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#x:149"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><a class="idref" href="Affine.html#v<sub>2</sub>:148"><span class="id" title="variable">v<sub>2</sub></span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><span class="id" title="notation">::</span><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a>) <a class="idref" href="Affine.html#t<sub>1</sub>:150"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Affine.html#Q:152"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_app"><span class="id" title="constructor">trm_app</span></a> <a class="idref" href="Affine.html#v<sub>1</sub>:147"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Affine.html#v<sub>2</sub>:148"><span class="id" title="variable">v<sub>2</sub></span></a>) <a class="idref" href="Affine.html#H:151"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:152"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
Its generalized form extends the postcondition from <span class="inlinecode"><span class="id" title="var">Q</span></span> to <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*+</span> <span class="inlinecode">\<span class="id" title="var">GC</span></span>, as
    shown below. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.xwp_lemma'" class="idref" href="#NewTriples.xwp_lemma'"><span class="id" title="lemma">xwp_lemma'</span></a> : <span class="id" title="keyword">∀</span> <a id="v<sub>1</sub>:154" class="idref" href="#v<sub>1</sub>:154"><span class="id" title="binder">v<sub>1</sub></span></a> <a id="v<sub>2</sub>:155" class="idref" href="#v<sub>2</sub>:155"><span class="id" title="binder">v<sub>2</sub></span></a> <a id="x:156" class="idref" href="#x:156"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:157" class="idref" href="#t<sub>1</sub>:157"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="H:158" class="idref" href="#H:158"><span class="id" title="binder">H</span></a> <a id="Q:159" class="idref" href="#Q:159"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#v<sub>1</sub>:154"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_fun"><span class="id" title="constructor">val_fun</span></a> <a class="idref" href="Affine.html#x:156"><span class="id" title="variable">x</span></a> <a class="idref" href="Affine.html#t<sub>1</sub>:157"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:158"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#wpgen"><span class="id" title="definition">wpgen</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#x:156"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><a class="idref" href="Affine.html#v<sub>2</sub>:155"><span class="id" title="variable">v<sub>2</sub></span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><span class="id" title="notation">::</span><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a>) <a class="idref" href="Affine.html#t<sub>1</sub>:157"><span class="id" title="variable">t<sub>1</sub></span></a> (<a class="idref" href="Affine.html#Q:159"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_app"><span class="id" title="constructor">trm_app</span></a> <a class="idref" href="Affine.html#v<sub>1</sub>:154"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Affine.html#v<sub>2</sub>:155"><span class="id" title="variable">v<sub>2</sub></span></a>) <a class="idref" href="Affine.html#H:158"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:159"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">E</span> <span class="id" title="var">M</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#NewTriples.triple_hgc_post"><span class="id" title="axiom">triple_hgc_post</span></a>. <span class="id" title="var">applys</span>* <a class="idref" href="Affine.html#NewTriples.xwp_lemma"><span class="id" title="axiom">xwp_lemma</span></a>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
We update the tactic <span class="inlinecode"><span class="id" title="var">xwp</span></span> to exploit the lemma <span class="inlinecode"><span class="id" title="var">xwp_lemma'</span></span> instead of
    <span class="inlinecode"><span class="id" title="var">xwp_lemma</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Tactic Notation</span> "xwp" :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#NewTriples.xwp_lemma'"><span class="id" title="lemma">xwp_lemma'</span></a>;<br/>
&nbsp;&nbsp;[ <span class="id" title="tactic">reflexivity</span> | <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">unfold</span> <a class="idref" href="LibSepReference.html#wpgen_var"><span class="id" title="definition">wpgen_var</span></a>; <span class="id" title="tactic">simpl</span> ].<br/>
</div>

<div class="doc">
<a id="lab418"></a><h3 class="section">Example Proof in an Affine Separation Logic</h3>

<div class="paragraph"> </div>

 Using the updated version of <span class="inlinecode"><span class="id" title="var">xwp</span></span>, let us revisite the proof of our
    motivating example <span class="inlinecode"><span class="id" title="var">succ_using_incr</span></span> in a fully affine logic where any
    predicate can be discarded. 
</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="NewTriples.MotivatingExampleWithUpdatedXwp" class="idref" href="#NewTriples.MotivatingExampleWithUpdatedXwp"><span class="id" title="module">MotivatingExampleWithUpdatedXwp</span></a>.<br/>
<span class="id" title="keyword">Export</span> <a class="idref" href="Affine.html#MotivatingExample"><span class="id" title="module">MotivatingExample</span></a>.<br/>
</div>

<div class="doc">
Assume a fully affine logic. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="NewTriples.MotivatingExampleWithUpdatedXwp.haffine_hany" class="idref" href="#NewTriples.MotivatingExampleWithUpdatedXwp.haffine_hany"><span class="id" title="axiom">haffine_hany</span></a> : <span class="id" title="keyword">∀</span> (<a id="H:160" class="idref" href="#H:160"><span class="id" title="binder">H</span></a>:<a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:160"><span class="id" title="variable">H</span></a>.<br/>
</div>

<div class="doc">
Observe, in the proof below, the <span class="inlinecode">\<span class="id" title="var">GC</span></span> introduced in the postcondition by
    the call to <span class="inlinecode"><span class="id" title="var">xwp</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.MotivatingExampleWithUpdatedXwp.triple_succ_using_incr" class="idref" href="#NewTriples.MotivatingExampleWithUpdatedXwp.triple_succ_using_incr"><span class="id" title="lemma">triple_succ_using_incr</span></a> : <span class="id" title="keyword">∀</span> (<a id="n:162" class="idref" href="#n:162"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Affine.html#MotivatingExample.succ_using_incr"><span class="id" title="definition">succ_using_incr</span></a> <a class="idref" href="Affine.html#n:162"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:163" class="idref" href="#r:163"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Affine.html#r:163"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Affine.html#n:162"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">r</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>. { <span class="id" title="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;It&nbsp;remains&nbsp;to&nbsp;absorb&nbsp;the&nbsp;left-over&nbsp;reference&nbsp;into&nbsp;the&nbsp;<span class="inlinecode">\<span class="id" title="var">GC</span></span>&nbsp;predicate&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="Affine.html#himpl_hgc_r"><span class="id" title="lemma">himpl_hgc_r</span></a>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#NewTriples.MotivatingExampleWithUpdatedXwp.haffine_hany"><span class="id" title="axiom">haffine_hany</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
We will show further on how to automate the work from the last line of the
    proof above, by setting up <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> to automatically resolve goals of the
    form <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode">\<span class="id" title="var">GC</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#NewTriples.MotivatingExampleWithUpdatedXwp"><span class="id" title="module">MotivatingExampleWithUpdatedXwp</span></a>.<br/>
</div>

<div class="doc">
<a id="lab419"></a><h2 class="section">Revised Definition of <span class="inlinecode"><span class="id" title="var">mkstruct</span></span></h2>

<div class="paragraph"> </div>

 Recall the definition <span class="inlinecode"><span class="id" title="var">mkstruct</span></span>, which is key to implementing <span class="inlinecode"><span class="id" title="var">wpgen</span></span> and
    the x-tactics.
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">mkstruct</span> (<span class="id" title="var">F</span>:<span class="id" title="var">formula</span>) : <span class="id" title="var">formula</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">Q</span> ⇒ <span class='gray-font'>\</span><span class="id" title="tactic">∃</span> <span class="id" title="var">Q'</span>, (<span class="id" title="var">F</span> <span class="id" title="var">Q'</span>) <span class='gray-font'>\</span>* (<span class="id" title="var">Q'</span> <span class='gray-font'>\</span><span class="nowrap">&minus;&minus;&lowast;</span> <span class="id" title="var">Q</span>).
</span>    This definition can be generalized to handle not just the consequence and
    frame rules, but also the discard rule. To that end, <span class="inlinecode"><span class="id" title="var">mkstruct</span></span> is extended
    with an additional <span class="inlinecode">\<span class="id" title="var">GC</span></span>, as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="NewTriples.mkstruct" class="idref" href="#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> (<a id="F:164" class="idref" href="#F:164"><span class="id" title="binder">F</span></a>:<a class="idref" href="LibSepReference.html#formula"><span class="id" title="definition">formula</span></a>) : <a class="idref" href="LibSepReference.html#formula"><span class="id" title="definition">formula</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="Q:165" class="idref" href="#Q:165"><span class="id" title="binder">Q</span></a> ⇒ <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="Q':166" class="idref" href="#Q':166"><span class="id" title="binder">Q'</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="Affine.html#F:164"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q':166"><span class="id" title="variable">Q'</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#Q':166"><span class="id" title="variable">Q'</span></a> <a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation"><span class='gray-font'>\</span><span class="nowrap">&minus;&minus;&lowast;</span></span></a> <a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#Q:165"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a><a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation">)</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
Let us prove that this revised definition of <span class="inlinecode"><span class="id" title="var">mkstruct</span></span> does indeed satisfy
    the <span class="inlinecode"><span class="id" title="var">wp</span></span>-style statement of the discard rule, which is stated in a way
    similar to <span class="inlinecode"><span class="id" title="var">wp_hgc_post</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.mkstruct_hgc" class="idref" href="#NewTriples.mkstruct_hgc"><span class="id" title="lemma">mkstruct_hgc</span></a> : <span class="id" title="keyword">∀</span> <a id="Q:167" class="idref" href="#Q:167"><span class="id" title="binder">Q</span></a> <a id="F:168" class="idref" href="#F:168"><span class="id" title="binder">F</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:168"><span class="id" title="variable">F</span></a> (<a class="idref" href="Affine.html#Q:167"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>) <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:168"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:167"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a>. <span class="id" title="tactic">set</span> (<span class="id" title="var">X</span> := <a class="idref" href="Affine.html#hgc"><span class="id" title="definition">hgc</span></a>) <span class="id" title="tactic">at</span> 3. <span class="id" title="tactic">replace</span> <span class="id" title="var">X</span> <span class="id" title="keyword">with</span> (<a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>).<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xsimpl</span>. } { <span class="id" title="tactic">subst</span> <span class="id" title="var">X</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#hstar_hgc_hgc"><span class="id" title="lemma">hstar_hgc_hgc</span></a>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Further, let us prove that the revised definition of <span class="inlinecode"><span class="id" title="var">mkstruct</span></span> still
    satisfies the four originally required properties: erasure, consequence,
    frame, and monoticity. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.mkstruct_erase" class="idref" href="#NewTriples.mkstruct_erase"><span class="id" title="lemma">mkstruct_erase</span></a> : <span class="id" title="keyword">∀</span> <a id="F:169" class="idref" href="#F:169"><span class="id" title="binder">F</span></a> <a id="Q:170" class="idref" href="#Q:170"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#F:169"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:170"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:169"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:170"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a>. <span class="id" title="var">xsimpl</span> <span class="id" title="var">Q</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#himpl_hgc_r"><span class="id" title="lemma">himpl_hgc_r</span></a>. <span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#haffine_hempty"><span class="id" title="lemma">haffine_hempty</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="NewTriples.mkstruct_conseq" class="idref" href="#NewTriples.mkstruct_conseq"><span class="id" title="lemma">mkstruct_conseq</span></a> : <span class="id" title="keyword">∀</span> <a id="F:171" class="idref" href="#F:171"><span class="id" title="binder">F</span></a> <a id="Q<sub>1</sub>:172" class="idref" href="#Q<sub>1</sub>:172"><span class="id" title="binder">Q<sub>1</sub></span></a> <a id="Q<sub>2</sub>:173" class="idref" href="#Q<sub>2</sub>:173"><span class="id" title="binder">Q<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#Q<sub>1</sub>:172"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#9351a4f098e275023c32e0091e608189"><span class="id" title="notation">===&gt;</span></a> <a class="idref" href="Affine.html#Q<sub>2</sub>:173"><span class="id" title="variable">Q<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:171"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q<sub>1</sub>:172"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:171"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q<sub>2</sub>:173"><span class="id" title="variable">Q<sub>2</sub></span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">WQ</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a>. <span class="id" title="var">xpull</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">Q'</span>. <span class="id" title="var">xsimpl</span> <span class="id" title="var">Q'</span>. <span class="id" title="var">xchange</span> <span class="id" title="var">WQ</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="NewTriples.mkstruct_frame" class="idref" href="#NewTriples.mkstruct_frame"><span class="id" title="lemma">mkstruct_frame</span></a> : <span class="id" title="keyword">∀</span> <a id="F:174" class="idref" href="#F:174"><span class="id" title="binder">F</span></a> <a id="H:175" class="idref" href="#H:175"><span class="id" title="binder">H</span></a> <a id="Q:176" class="idref" href="#Q:176"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:174"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:176"><span class="id" title="variable">Q</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H:175"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:174"><span class="id" title="variable">F</span></a> (<a class="idref" href="Affine.html#Q:176"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H:175"><span class="id" title="variable">H</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a>. <span class="id" title="var">xpull</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">Q'</span>. <span class="id" title="var">xsimpl</span> <span class="id" title="var">Q'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="NewTriples.mkstruct_monotone" class="idref" href="#NewTriples.mkstruct_monotone"><span class="id" title="lemma">mkstruct_monotone</span></a> : <span class="id" title="keyword">∀</span> <a id="F<sub>1</sub>:177" class="idref" href="#F<sub>1</sub>:177"><span class="id" title="binder">F<sub>1</sub></span></a> <a id="F<sub>2</sub>:178" class="idref" href="#F<sub>2</sub>:178"><span class="id" title="binder">F<sub>2</sub></span></a> <a id="Q:179" class="idref" href="#Q:179"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="Q:180" class="idref" href="#Q:180"><span class="id" title="binder">Q</span></a>, <a class="idref" href="Affine.html#F<sub>1</sub>:177"><span class="id" title="variable">F<sub>1</sub></span></a> <a class="idref" href="Affine.html#Q:180"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#F<sub>2</sub>:178"><span class="id" title="variable">F<sub>2</sub></span></a> <a class="idref" href="Affine.html#Q:180"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F<sub>1</sub>:177"><span class="id" title="variable">F<sub>1</sub></span></a> <a class="idref" href="Affine.html#Q:179"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F<sub>2</sub>:178"><span class="id" title="variable">F<sub>2</sub></span></a> <a class="idref" href="Affine.html#Q:179"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">WF</span>. <span class="id" title="var">unfolds</span> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a>. <span class="id" title="var">xpull</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">Q'</span>. <span class="id" title="var">xchange</span> <span class="id" title="var">WF</span>. <span class="id" title="var">xsimpl</span> <span class="id" title="var">Q'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab420"></a><h4 class="section">Exercise: 2 stars, standard, optional (mkstruct_haffine_post)</h4>
 Prove the reformulation of <span class="inlinecode"><span class="id" title="var">triple_haffine_post</span></span> adapted to <span class="inlinecode"><span class="id" title="var">mkstruct</span></span>, for
    discarding an affine piece of postcondition. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.mkstruct_haffine_post" class="idref" href="#NewTriples.mkstruct_haffine_post"><span class="id" title="lemma">mkstruct_haffine_post</span></a> : <span class="id" title="keyword">∀</span> <a id="H:181" class="idref" href="#H:181"><span class="id" title="binder">H</span></a> <a id="Q:182" class="idref" href="#Q:182"><span class="id" title="binder">Q</span></a> <a id="F:183" class="idref" href="#F:183"><span class="id" title="binder">F</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:181"><span class="id" title="variable">H</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:183"><span class="id" title="variable">F</span></a> (<a class="idref" href="Affine.html#Q:182"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H:181"><span class="id" title="variable">H</span></a>) <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:183"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:182"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab421"></a><h4 class="section">Exercise: 2 stars, standard, optional (mkstruct_haffine_pre)</h4>
 Prove the reformulation of <span class="inlinecode"><span class="id" title="var">triple_haffine_pre</span></span> adapted to <span class="inlinecode"><span class="id" title="var">mkstruct</span></span>, for
    discarding an affine piece of postcondition. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.mkstruct_haffine_pre" class="idref" href="#NewTriples.mkstruct_haffine_pre"><span class="id" title="lemma">mkstruct_haffine_pre</span></a> : <span class="id" title="keyword">∀</span> <a id="H:184" class="idref" href="#H:184"><span class="id" title="binder">H</span></a> <a id="Q:185" class="idref" href="#Q:185"><span class="id" title="binder">Q</span></a> <a id="F:186" class="idref" href="#F:186"><span class="id" title="binder">F</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:184"><span class="id" title="variable">H</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:186"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:185"><span class="id" title="variable">Q</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H:184"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:186"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:185"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="code">

<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#NewTriples"><span class="id" title="module">NewTriples</span></a>.<br/>
</div>

<div class="doc">
<a id="lab422"></a><h2 class="section">The Tactic <span class="inlinecode"><span class="id" title="var">xaffine</span></span> and the Behavior of <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> on <span class="inlinecode">\<span class="id" title="var">GC</span></span></h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="Xaffine" class="idref" href="#Xaffine"><span class="id" title="module">Xaffine</span></a>.<br/>
</div>

<div class="doc">
The tactic <span class="inlinecode"><span class="id" title="var">xaffine</span></span> applies to a goal of the form <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>. It
    simplifies the goal using all the distributivity rules associated with
    <span class="inlinecode"><span class="id" title="var">haffine</span></span>. Ultimately, it invokes <span class="inlinecode"><span class="id" title="tactic">eauto</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><span class="id" title="var">haffine</span></span>, which can leverage
    knowledge specific to the definition of <span class="inlinecode"><span class="id" title="var">haffine</span></span> from the Separation Logic
    setup at hand. 
</div>
<div class="code">

<span class="id" title="keyword">Create HintDb</span> <span class="id" title="var">haffine</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Tactic Notation</span> "xaffine" :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span> &#x22A2; <a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> ?<span class="id" title="var">H</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">H</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="LibSepReference.html#SepSimplArgs.hempty"><span class="id" title="definition">hempty</span></a>) ⇒ <span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#haffine_hempty"><span class="id" title="lemma">haffine_hempty</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="LibSepReference.html#SepSimplArgs.hpure"><span class="id" title="definition">hpure</span></a> <span class="id" title="var">_</span>) ⇒ <span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#haffine_hpure"><span class="id" title="lemma">haffine_hpure</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="LibSepReference.html#SepSimplArgs.hstar"><span class="id" title="definition">hstar</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) ⇒ <span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#haffine_hstar"><span class="id" title="lemma">haffine_hstar</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="LibSepReference.html#SepSimplArgs.hexists"><span class="id" title="definition">hexists</span></a> <span class="id" title="var">_</span>) ⇒ <span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#haffine_hexists"><span class="id" title="lemma">haffine_hexists</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="LibSepReference.html#SepSimplArgs.hforall"><span class="id" title="definition">hforall</span></a> <span class="id" title="var">_</span>) ⇒ <span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#haffine_hforall"><span class="id" title="lemma">haffine_hforall</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="Affine.html#hgc"><span class="id" title="definition">hgc</span></a>) ⇒ <span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#haffine_hgc"><span class="id" title="lemma">haffine_hgc</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">eauto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">haffine</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="Xaffine.xaffine_demo" class="idref" href="#Xaffine.xaffine_demo"><span class="id" title="lemma">xaffine_demo</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:187" class="idref" href="#H<sub>1</sub>:187"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:188" class="idref" href="#H<sub>2</sub>:188"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="H<sub>3</sub>:189" class="idref" href="#H<sub>3</sub>:189"><span class="id" title="binder">H<sub>3</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:187"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>3</sub>:189"><span class="id" title="variable">H<sub>3</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="Affine.html#H<sub>1</sub>:187"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:188"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>3</sub>:189"><span class="id" title="variable">H<sub>3</sub></span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">K<sub>1</sub></span> <span class="id" title="var">KJ</span>. <span class="id" title="var">xaffine</span>. <span class="comment">(*&nbsp;remains&nbsp;<span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span>&nbsp;*)</span> <span class="id" title="keyword">Abort</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#Xaffine"><span class="id" title="module">Xaffine</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Module</span> <a id="XsimplExtended" class="idref" href="#XsimplExtended"><span class="id" title="module">XsimplExtended</span></a>.<br/>
<span class="id" title="keyword">Import</span> <a class="idref" href="LibSepReference.html#"><span class="id" title="module">LibSepReference</span></a>.<br/>
</div>

<div class="doc">
The tactic <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> is extended with support for simplifying goals of the
    form <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode">\<span class="id" title="var">GC</span></span> into <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>, using lemma <span class="inlinecode"><span class="id" title="var">himpl_hgc_r</span></span>. For example,
    <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> can simplify the goal <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode">\<span class="id" title="var">GC</span></span> into just
    <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="XsimplExtended.xsimpl_xgc_demo" class="idref" href="#XsimplExtended.xsimpl_xgc_demo"><span class="id" title="lemma">xsimpl_xgc_demo</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:190" class="idref" href="#H<sub>1</sub>:190"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:191" class="idref" href="#H<sub>2</sub>:191"><span class="id" title="binder">H<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H<sub>1</sub>:190"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:191"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:191"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">GC</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="var">xsimpl</span>. <span class="comment">(*&nbsp;remains&nbsp;<span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span>&nbsp;*)</span> <span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
In addition, <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> invokes the tactic <span class="inlinecode"><span class="id" title="var">xaffine</span></span> to simplify
    side-conditions of the form <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>. For example, <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> can prove the
    following lemma. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="XsimplExtended.xsimpl_xaffine_demo" class="idref" href="#XsimplExtended.xsimpl_xaffine_demo"><span class="id" title="lemma">xsimpl_xaffine_demo</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:192" class="idref" href="#H<sub>1</sub>:192"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:193" class="idref" href="#H<sub>2</sub>:193"><span class="id" title="binder">H<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#SepSimplArgs.haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:192"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H<sub>1</sub>:192"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:193"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:193"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">GC</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">K<sub>1</sub></span>. <span class="id" title="var">xsimpl</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#XsimplExtended"><span class="id" title="module">XsimplExtended</span></a>.<br/>
</div>

<div class="doc">
<a id="lab423"></a><h2 class="section">Tactics for Applying the Discard Rules</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="XGC" class="idref" href="#XGC"><span class="id" title="module">XGC</span></a>.<br/>
<span class="id" title="keyword">Import</span> <a class="idref" href="LibSepReference.html#"><span class="id" title="module">LibSepReference</span></a>.<br/>
</div>

<div class="doc">
This section presents the discard tactics <span class="inlinecode"><span class="id" title="var">xgc</span></span>, <span class="inlinecode"><span class="id" title="var">xc_keep</span></span>, and <span class="inlinecode"><span class="id" title="var">xgc_post</span></span>.
    Their implementation leverages the discard property of <span class="inlinecode"><span class="id" title="var">mkstruct</span></span>,
    reproduced below. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="XGC.mkstruct_hgc" class="idref" href="#XGC.mkstruct_hgc"><span class="id" title="axiom">mkstruct_hgc</span></a> : <span class="id" title="keyword">∀</span> <a id="Q:194" class="idref" href="#Q:194"><span class="id" title="binder">Q</span></a> <a id="F:195" class="idref" href="#F:195"><span class="id" title="binder">F</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:195"><span class="id" title="variable">F</span></a> (<a class="idref" href="Affine.html#Q:194"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">GC</span></a>) <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:195"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:194"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
The tactic <span class="inlinecode"><span class="id" title="var">xgc</span></span> <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> removes <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> from the precondition (i.e., from the
    current state), in the course of a proof exploiting a formula produced by
    <span class="inlinecode"><span class="id" title="var">wpgen</span></span>. More precisely, the tactic <span class="inlinecode"><span class="id" title="var">xgc</span></span> <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> removes <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> from the current
    precondition <span class="inlinecode"><span class="id" title="var">H</span></span>. It leverages <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> to simplify the entailment
    <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> and infer <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span>, which describes what remains after removing
    <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> from <span class="inlinecode"><span class="id" title="var">H</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="XGC.xgc_lemma" class="idref" href="#XGC.xgc_lemma"><span class="id" title="lemma">xgc_lemma</span></a>: <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:197" class="idref" href="#H<sub>1</sub>:197"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:198" class="idref" href="#H<sub>2</sub>:198"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="H:199" class="idref" href="#H:199"><span class="id" title="binder">H</span></a> <a id="F:200" class="idref" href="#F:200"><span class="id" title="binder">F</span></a> <a id="Q:201" class="idref" href="#Q:201"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:199"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:197"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:198"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#SepSimplArgs.haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:197"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H<sub>2</sub>:198"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:200"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:201"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:199"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:200"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:201"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">WH</span> <span class="id" title="var">K</span> <span class="id" title="var">M</span>. <span class="id" title="var">xchange</span> <span class="id" title="var">WH</span>. <span class="id" title="var">xchange</span> <span class="id" title="var">M</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.himpl_trans"><span class="id" title="lemma">himpl_trans</span></a> <a class="idref" href="LibSepReference.html#mkstruct_frame"><span class="id" title="lemma">mkstruct_frame</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.himpl_trans"><span class="id" title="lemma">himpl_trans</span></a> <a class="idref" href="Affine.html#XGC.mkstruct_hgc"><span class="id" title="axiom">mkstruct_hgc</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#mkstruct_conseq"><span class="id" title="lemma">mkstruct_conseq</span></a>. <span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Tactic Notation</span> "xgc" <span class="id" title="keyword">constr</span>(<span class="id" title="var">H</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> (@<a class="idref" href="Affine.html#XGC.xgc_lemma"><span class="id" title="lemma">xgc_lemma</span></a> <span class="id" title="var">H</span>); [ <span class="id" title="var">xsimpl</span> | <span class="id" title="var">xaffine</span> | ].<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="XGC.xgc_demo" class="idref" href="#XGC.xgc_demo"><span class="id" title="lemma">xgc_demo</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:202" class="idref" href="#H<sub>1</sub>:202"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:203" class="idref" href="#H<sub>2</sub>:203"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="H<sub>3</sub>:204" class="idref" href="#H<sub>3</sub>:204"><span class="id" title="binder">H<sub>3</sub></span></a> <a id="F:205" class="idref" href="#F:205"><span class="id" title="binder">F</span></a> <a id="Q:206" class="idref" href="#Q:206"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#SepSimplArgs.haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:203"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#H<sub>1</sub>:202"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:203"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>3</sub>:204"><span class="id" title="variable">H<sub>3</sub></span></a><a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:205"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:206"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">K<sub>2</sub></span>. <span class="id" title="var">xgc</span> <span class="id" title="var">H<sub>2</sub></span>. <span class="comment">(*&nbsp;clears&nbsp;<span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span>&nbsp;*)</span> <span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
The tactic <span class="inlinecode"><span class="id" title="var">xgc_keep</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> is a variant of <span class="inlinecode"><span class="id" title="var">xgc</span></span> that enables discarding
    everything but <span class="inlinecode"><span class="id" title="var">H</span></span> from the precondition.

<div class="paragraph"> </div>

    The implementation of the tactic leverages the same lemma <span class="inlinecode"><span class="id" title="var">xgc_lemma</span></span>, but
    providing <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> instead of <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Tactic Notation</span> "xgc_keep" <span class="id" title="keyword">constr</span>(<span class="id" title="var">H</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> (@<a class="idref" href="Affine.html#XGC.xgc_lemma"><span class="id" title="lemma">xgc_lemma</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H</span>); [ <span class="id" title="var">xsimpl</span> | <span class="id" title="var">xaffine</span> | ].<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="XGC.xgc_keep_demo" class="idref" href="#XGC.xgc_keep_demo"><span class="id" title="lemma">xgc_keep_demo</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:207" class="idref" href="#H<sub>1</sub>:207"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:208" class="idref" href="#H<sub>2</sub>:208"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="H<sub>3</sub>:209" class="idref" href="#H<sub>3</sub>:209"><span class="id" title="binder">H<sub>3</sub></span></a> <a id="F:210" class="idref" href="#F:210"><span class="id" title="binder">F</span></a> <a id="Q:211" class="idref" href="#Q:211"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#SepSimplArgs.haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:207"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#SepSimplArgs.haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>3</sub>:209"><span class="id" title="variable">H<sub>3</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#H<sub>1</sub>:207"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:208"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>3</sub>:209"><span class="id" title="variable">H<sub>3</sub></span></a><a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:210"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:211"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">K<sub>1</sub></span> <span class="id" title="var">K<sub>3</sub></span>. <span class="id" title="var">xgc_keep</span> <span class="id" title="var">H<sub>2</sub></span>. <span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
The tactic <span class="inlinecode"><span class="id" title="var">xgc_post</span></span> simply extends the postcondition with a <span class="inlinecode">\<span class="id" title="var">GC</span></span>, to
    enable subsequent discarding of heap predicates in the final entailment. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="XGC.xgc_post_lemma" class="idref" href="#XGC.xgc_post_lemma"><span class="id" title="lemma">xgc_post_lemma</span></a> : <span class="id" title="keyword">∀</span> <a id="H:212" class="idref" href="#H:212"><span class="id" title="binder">H</span></a> <a id="Q:213" class="idref" href="#Q:213"><span class="id" title="binder">Q</span></a> <a id="F:214" class="idref" href="#F:214"><span class="id" title="binder">F</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:212"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:214"><span class="id" title="variable">F</span></a> (<a class="idref" href="Affine.html#Q:213"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">GC</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:212"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:214"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:213"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="var">xchange</span> <span class="id" title="var">M</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#XGC.mkstruct_hgc"><span class="id" title="axiom">mkstruct_hgc</span></a>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Tactic Notation</span> "xgc_post" :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#XGC.xgc_post_lemma"><span class="id" title="lemma">xgc_post_lemma</span></a>.<br/>
</div>

<div class="doc">
The example below illustrates a usage of the <span class="inlinecode"><span class="id" title="var">xgc_post</span></span> tactic. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="XGC.xgc_keep_demo" class="idref" href="#XGC.xgc_keep_demo"><span class="id" title="lemma">xgc_keep_demo</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:215" class="idref" href="#H<sub>1</sub>:215"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:216" class="idref" href="#H<sub>2</sub>:216"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="H<sub>3</sub>:217" class="idref" href="#H<sub>3</sub>:217"><span class="id" title="binder">H<sub>3</sub></span></a> <a id="F:218" class="idref" href="#F:218"><span class="id" title="binder">F</span></a> <a id="Q:219" class="idref" href="#Q:219"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#SepSimplArgs.haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:215"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#SepSimplArgs.haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>3</sub>:217"><span class="id" title="variable">H<sub>3</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H<sub>1</sub>:215"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:218"><span class="id" title="variable">F</span></a> (<a class="idref" href="Affine.html#Q:219"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:216"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H<sub>3</sub>:217"><span class="id" title="variable">H<sub>3</sub></span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H<sub>1</sub>:215"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:218"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:219"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">K<sub>1</sub></span> <span class="id" title="var">K<sub>3</sub></span> <span class="id" title="var">M</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xgc_post</span>. <span class="comment">(*&nbsp;add&nbsp;<span class="inlinecode">\<span class="id" title="var">GC</span></span>&nbsp;to&nbsp;the&nbsp;postcondition&nbsp;<span class="inlinecode"><span class="id" title="var">Q</span></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="var">xchange</span> <span class="id" title="var">M</span>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#mkstruct_conseq"><span class="id" title="lemma">mkstruct_conseq</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#XGC"><span class="id" title="module">XGC</span></a>.<br/>
</div>

<div class="doc">
<a id="lab424"></a><h1 class="section">Optional Material</h1>

</div>

<div class="doc">
<a id="lab425"></a><h2 class="section">Alternative Statement for Distribution of <span class="inlinecode"><span class="id" title="var">haffine</span></span> on Quantifiers</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="HaffineQuantifiers" class="idref" href="#HaffineQuantifiers"><span class="id" title="module">HaffineQuantifiers</span></a>.<br/>
</div>

<div class="doc">
Recall the lemmas <span class="inlinecode"><span class="id" title="var">haffine_hexists</span></span> and <span class="inlinecode"><span class="id" title="var">haffine_hforall</span></span>.
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">haffine_hexists</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> (<span class="id" title="var">J</span>:<span class="id" title="var">A</span>→<span class="id" title="var">hprop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">haffine</span> (<span class="id" title="var">J</span> <span class="id" title="var">x</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">haffine</span> (<span class='gray-font'>\</span><span class="id" title="tactic">∃</span> <span class="id" title="var">x</span>, (<span class="id" title="var">J</span> <span class="id" title="var">x</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">haffine_hforall</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> `{<span class="id" title="var">Inhab</span> <span class="id" title="var">A</span>} (<span class="id" title="var">J</span>:<span class="id" title="var">A</span>→<span class="id" title="var">hprop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">haffine</span> (<span class="id" title="var">J</span> <span class="id" title="var">x</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">haffine</span> (\<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, (<span class="id" title="var">J</span> <span class="id" title="var">x</span>)).
</span>    They can be reformulated in a more concise way, as explained next. 
<div class="paragraph"> </div>

 First, to smoothly handle the distribution on the quantifiers, let us extend
    the notion of "affinity" to postconditions. The predicate <span class="inlinecode"><span class="id" title="var">haffine_post</span></span> <span class="inlinecode"><span class="id" title="var">J</span></span>
    asserts that <span class="inlinecode"><span class="id" title="var">haffine</span></span> holds of <span class="inlinecode"><span class="id" title="var">J</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> for any <span class="inlinecode"><span class="id" title="var">x</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="HaffineQuantifiers.haffine_post" class="idref" href="#HaffineQuantifiers.haffine_post"><span class="id" title="definition">haffine_post</span></a> (<a id="A:220" class="idref" href="#A:220"><span class="id" title="binder">A</span></a>:<span class="id" title="keyword">Type</span>) (<a id="J:221" class="idref" href="#J:221"><span class="id" title="binder">J</span></a>:<a class="idref" href="Affine.html#A:220"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a id="x:222" class="idref" href="#x:222"><span class="id" title="binder">x</span></a>, <a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="Affine.html#J:221"><span class="id" title="variable">J</span></a> <a class="idref" href="Affine.html#x:222"><span class="id" title="variable">x</span></a>).<br/>
</div>

<div class="doc">
The rules then reformulate as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="HaffineQuantifiers.haffine_hexists" class="idref" href="#HaffineQuantifiers.haffine_hexists"><span class="id" title="lemma">haffine_hexists</span></a> : <span class="id" title="keyword">∀</span> <a id="A:223" class="idref" href="#A:223"><span class="id" title="binder">A</span></a> (<a id="J:224" class="idref" href="#J:224"><span class="id" title="binder">J</span></a>:<a class="idref" href="Affine.html#A:223"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#HaffineQuantifiers.haffine_post"><span class="id" title="definition">haffine_post</span></a> <a class="idref" href="Affine.html#J:224"><span class="id" title="variable">J</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="LibSepReference.html#SepSimplArgs.hexists"><span class="id" title="definition">hexists</span></a> <a class="idref" href="Affine.html#J:224"><span class="id" title="variable">J</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">F<sub>1</sub></span> (<span class="id" title="var">x</span>&amp;<span class="id" title="var">Hx</span>). <span class="id" title="var">applys</span>* <span class="id" title="var">F<sub>1</sub></span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="HaffineQuantifiers.haffine_hforall" class="idref" href="#HaffineQuantifiers.haffine_hforall"><span class="id" title="lemma">haffine_hforall</span></a> : <span class="id" title="keyword">∀</span> <a id="A:225" class="idref" href="#A:225"><span class="id" title="binder">A</span></a> `{<a id="H:226" class="idref" href="#H:226"><span class="id" title="binder">Inhab</span></a> <a id="H:226" class="idref" href="#H:226"><span class="id" title="binder">A</span></a>} (<a id="J:227" class="idref" href="#J:227"><span class="id" title="binder">J</span></a>:<a class="idref" href="Affine.html#A:225"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#HaffineQuantifiers.haffine_post"><span class="id" title="definition">haffine_post</span></a> <a class="idref" href="Affine.html#J:227"><span class="id" title="variable">J</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="LibSepReference.html#SepSimplArgs.hforall"><span class="id" title="definition">hforall</span></a> <a class="idref" href="Affine.html#J:227"><span class="id" title="variable">J</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">IA</span> <span class="id" title="var">F<sub>1</sub></span> <span class="id" title="var">Hx</span>. <span class="id" title="var">lets</span> <span class="id" title="var">N</span>: <a class="idref" href="LibSepReference.html#SepSimplArgs.hforall_inv"><span class="id" title="lemma">hforall_inv</span></a> <span class="id" title="var">Hx</span>. <span class="id" title="var">applys</span>* <span class="id" title="var">F<sub>1</sub></span> (<span class="id" title="definition">arbitrary</span> (<span class="id" title="var">A</span>:=<span class="id" title="var">A</span>)).<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#HaffineQuantifiers"><span class="id" title="module">HaffineQuantifiers</span></a>.<br/>
</div>

<div class="doc">
<a id="lab426"></a><h2 class="section">Deriving the Rule GC-Post from the Rule GC-Pre</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="FromPreToPostGC" class="idref" href="#FromPreToPostGC"><span class="id" title="module">FromPreToPostGC</span></a>.<br/>
<span class="id" title="keyword">Import</span> <a class="idref" href="Rules.html#"><span class="id" title="module">Rules</span></a> <a class="idref" href="Rules.html#ProofsSameSemantics"><span class="id" title="module">ProofsSameSemantics</span></a>.<br/>
</div>

<div class="doc">
Earlier on, we proved that <span class="inlinecode"><span class="id" title="var">triple_hgc_pre</span></span> is derivable from
    <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span>, through a simple application of the frame rule. We wrote
    that, reciprocally, the rule <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span> is derivable from
    <span class="inlinecode"><span class="id" title="var">triple_hgc_pre</span></span>, yet with a slightly more involved proof. Let us present
    this proof. Concretely, assume <span class="inlinecode"><span class="id" title="var">triple_hgc_pre</span></span> and let us prove the result
    <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="FromPreToPostGC.triple_hgc_pre" class="idref" href="#FromPreToPostGC.triple_hgc_pre"><span class="id" title="axiom">triple_hgc_pre</span></a> : <span class="id" title="keyword">∀</span> <a id="t:228" class="idref" href="#t:228"><span class="id" title="binder">t</span></a> <a id="H:229" class="idref" href="#H:229"><span class="id" title="binder">H</span></a> <a id="Q:230" class="idref" href="#Q:230"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:228"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:229"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:230"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:228"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#H:229"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">GC</span></a>) <a class="idref" href="Affine.html#Q:230"><span class="id" title="variable">Q</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Parameter</span> <a id="FromPreToPostGC.triple_hgc_post" class="idref" href="#FromPreToPostGC.triple_hgc_post"><span class="id" title="axiom">triple_hgc_post</span></a> : <span class="id" title="keyword">∀</span> <a id="t:232" class="idref" href="#t:232"><span class="id" title="binder">t</span></a> <a id="H:233" class="idref" href="#H:233"><span class="id" title="binder">H</span></a> <a id="Q:234" class="idref" href="#Q:234"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:232"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:233"><span class="id" title="variable">H</span></a> (<a class="idref" href="Affine.html#Q:234"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">GC</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:232"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:233"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:234"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
The key idea of the proof is that a term <span class="inlinecode"><span class="id" title="var">t</span></span> admits the same behavior as
    <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>. Recall from chapter <a href="Rules.html"><span class="inlineref">Rules</span></a> the lemma
    <span class="inlinecode"><span class="id" title="var">eta_same_triples</span></span> which asserts the equivalence of <span class="inlinecode"><span class="id" title="var">t</span></span> and
    <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="FromPreToPostGC.eta_same_triples" class="idref" href="#FromPreToPostGC.eta_same_triples"><span class="id" title="axiom">eta_same_triples</span></a> : <span class="id" title="keyword">∀</span> (<a id="t:236" class="idref" href="#t:236"><span class="id" title="binder">t</span></a>:<a class="idref" href="LibSepReference.html#trm"><span class="id" title="inductive">trm</span></a>) (<a id="x:237" class="idref" href="#x:237"><span class="id" title="binder">x</span></a>:<a class="idref" href="LibSepVar.html#var"><span class="id" title="definition">var</span></a>) <a id="H:238" class="idref" href="#H:238"><span class="id" title="binder">H</span></a> <a id="Q:239" class="idref" href="#Q:239"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:236"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:238"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:239"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_let"><span class="id" title="constructor">trm_let</span></a> <a class="idref" href="Affine.html#x:237"><span class="id" title="variable">x</span></a> <a class="idref" href="Affine.html#t:236"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#x:237"><span class="id" title="variable">x</span></a>) <a class="idref" href="Affine.html#H:238"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:239"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
To discard a predicate from the postcondition of <span class="inlinecode"><span class="id" title="var">t</span></span> if we only have at hand
    a rule for discarding predicates from preconditions, we replace <span class="inlinecode"><span class="id" title="var">t</span></span> with
    <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> and apply the discard rule after evaluating <span class="inlinecode"><span class="id" title="var">t</span></span> but before
    returning the variable <span class="inlinecode"><span class="id" title="var">x</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="FromPreToPostGC.triple_hgc_post_from_hgc_pre" class="idref" href="#FromPreToPostGC.triple_hgc_post_from_hgc_pre"><span class="id" title="lemma">triple_hgc_post_from_hgc_pre</span></a> : <span class="id" title="keyword">∀</span> <a id="t:241" class="idref" href="#t:241"><span class="id" title="binder">t</span></a> <a id="H:242" class="idref" href="#H:242"><span class="id" title="binder">H</span></a> <a id="Q:243" class="idref" href="#Q:243"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:241"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:242"><span class="id" title="variable">H</span></a> (<a class="idref" href="Affine.html#Q:243"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">GC</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:241"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:242"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:243"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">rewrite</span> (<a class="idref" href="Affine.html#FromPreToPostGC.eta_same_triples"><span class="id" title="axiom">eta_same_triples</span></a> <span class="id" title="var">t</span> "x"). <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#triple_let"><span class="id" title="lemma">triple_let</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <span class="id" title="var">M</span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">v</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#FromPreToPostGC.triple_hgc_pre"><span class="id" title="axiom">triple_hgc_pre</span></a>. <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#triple_val"><span class="id" title="lemma">triple_val</span></a>. <span class="id" title="tactic">auto</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#FromPreToPostGC"><span class="id" title="module">FromPreToPostGC</span></a>.<br/>
</div>

<div class="doc">
<a id="lab427"></a><h2 class="section">Historical Notes</h2>

<div class="paragraph"> </div>

 The seminal presentation of Separation Logic concerned a linear logic for a
    programming language with explicit deallocation. More recent works on
    Separation Logic for ML-style languages equipped with a garbage collector
    consider affine logics. For example, the original presentation of the Iris
    framework provides an affine entailment, for which <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class='gray-font'>\</span>[]</span> is always
    true. Follow-up work on Iris provides encodings for supporting linear
    resources, i.e., resources that cannot be dropped on the floor.

<div class="paragraph"> </div>

    The present chapter gives a presentation of Separation Logic featuring a
    customizable predicate <span class="inlinecode"><span class="id" title="var">haffine</span></span> for controlling which resources should be
    treated as affine, and which ones should be treated as linear. This direct
    approach to controlling linearity was introduced in the context of CFML, in
    work by <a href="Bib.html#Guéneau,-Jourdan, Charguéraud, and Pottier 2019"><span class="inlineref">[Guéneau, Jourdan, Charguéraud, and Pottier 2019]</span></a>. 
</div>
<div class="code">

<span class="comment">(*&nbsp;2024-10-24&nbsp;21:44&nbsp;*)</span><br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>