<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>Affine: Affine Separation Logic</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/slf.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<div id="page">

<div id="header">
<div id='logoinheader'><a href='https://softwarefoundations.cis.upenn.edu'>
<img src='common/media/image/sf_logo_sm.png' alt='Software Foundations Logo'></a></div>
<div class='booktitleinheader'><a href='index.html'>Volume 6: Separation Logic Foundations</a></div>
<ul id='menu'>
   <li class='section_name'><a href='toc.html'>Table of Contents</a></li>
   <li class='section_name'><a href='coqindex.html'>Index</a></li>
   <li class='section_name'><a href='deps.html'>Roadmap</a></li>
</ul>
</div>

<div id="main">

<h1 class="libtitle">Affine<span class="subtitle">Affine Separation Logic</span></h1>


<div class="code">

<span class="id" title="keyword">Set Implicit Arguments</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">SLF</span> <span class="id" title="keyword">Require</span> <a class="idref" href="Rules.html#"><span class="id" title="library">Rules</span></a>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">SLF</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="LibSepReference.html#"><span class="id" title="library">LibSepReference</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">f</span> : <a class="idref" href="LibSepVar.html#var"><span class="id" title="definition">var</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">b</span> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">v</span> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">h</span> : <a class="idref" href="LibSepReference.html#heap"><span class="id" title="definition">heap</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">H</span> : <a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">Q</span> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>.<br/>
</div>

<div class="doc">
<a id="lab359"></a><h1 class="section">First Pass</h1>

<div class="paragraph"> </div>

 The Separation Logic framework that we have constructed is
    well-suited for a language with explicit deallocation, but cannot
    be used as such for a language equipped with a garbage collector.

<div class="paragraph"> </div>

    As we pointed out in the chapter <a href="Basic.html"><span class="inlineref">Basic</span></a>, there is no rule in
    our basic Separation Logic that allows discarding a heap predicate
    from the precondition or the postcondition.

<div class="paragraph"> </div>

    In this chapter, we explain how to generalize the Separation Logic
    framework to support a "discard rule", which one may invoke to discard
    heap predicates from the precondition or from the postcondition.

<div class="paragraph"> </div>

    The framework extended with the discard rule corresponds to an "affine"
    logic, where heap predicates may be freely discarded, as opposed to a
    "linear" logic, where heap predicates cannot be thrown away.

<div class="paragraph"> </div>

    This chapter is organized as follows:

<div class="paragraph"> </div>

<ul class="doclist">
<li> first, we recall the example illustrating the limitation of a logic
      without a discard rule, for a garbage-collected language;

</li>
<li> second, we present several versions of the "discard rule";

</li>
<li> third, we show how to refine the definition of Separation Logic
      triples in such a way that the discard rules are satisfied.

</li>
</ul>

<div class="paragraph"> </div>

    Although in the present course we consider a language for which it is
    desirable that any heap predicate can be discarded, we will present
    general definitions allowing to fine-tune which heap predicates can
    be discarded and which cannot be discarded by the user. We argue further
    on why such a fine-tuning may be interesting. 
</div>

<div class="doc">
<a id="lab360"></a><h2 class="section">Motivation for the Discard Rule</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="MotivatingExample" class="idref" href="#MotivatingExample"><span class="id" title="module">MotivatingExample</span></a>.<br/>
<span class="id" title="keyword">Export</span> <span class="id" title="var">DemoPrograms</span>.<br/>
</div>

<div class="doc">
Let us recall the example of the function <span class="inlinecode"><span class="id" title="var">succ_using_incr_attempt</span></span>
    from chapter <a href="Basic.html"><span class="inlineref">Basic</span></a>. This function allocates a reference with
    contents <span class="inlinecode"><span class="id" title="var">n</span></span>, then increments that reference, and finally returning
    its contents, that is, <span class="inlinecode"><span class="id" title="var">n</span>+1</span>. Let us revisit this example, with
    this time the intention of establishing for it a postcondition that
    does not leak the existence of a left-over reference cell. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="MotivatingExample.succ_using_incr" class="idref" href="#MotivatingExample.succ_using_incr"><span class="id" title="definition">succ_using_incr</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:'ref'"><span class="id" title="notation">ref</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#DemoPrograms.incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
In the framework developed so far, the heap predicate describing the
    reference cell allocated by the function cannot be discarded, because
    the code considered does not include a deallocation operation. Thus,
    we are forced to include in the postcondition the description of a
    left-over reference with a heap predicate, e.g., <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">p</span>,</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>,
    or <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">m</span>,</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">m</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="MotivatingExample.triple_succ_using_incr" class="idref" href="#MotivatingExample.triple_succ_using_incr"><span class="id" title="lemma">triple_succ_using_incr</span></a> : <span class="id" title="keyword">∀</span> (<a id="n:1" class="idref" href="#n:1"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Affine.html#MotivatingExample.succ_using_incr"><span class="id" title="definition">succ_using_incr</span></a> <a class="idref" href="Affine.html#n:1"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:2" class="idref" href="#r:2"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Affine.html#r:2"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Affine.html#n:1"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="p:3" class="idref" href="#p:3"><span class="id" title="binder">p</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#p:3"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#n:1"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>. <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
If we try to prove a specification that does not mention the left-over
    reference, then we get stuck with a proof obligation of the form
    <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class='gray-font'>\</span>[]</span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="MotivatingExample.triple_succ_using_incr'" class="idref" href="#MotivatingExample.triple_succ_using_incr'"><span class="id" title="lemma">triple_succ_using_incr'</span></a> : <span class="id" title="keyword">∀</span> (<a id="n:4" class="idref" href="#n:4"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Affine.html#MotivatingExample.succ_using_incr"><span class="id" title="definition">succ_using_incr</span></a> <a class="idref" href="Affine.html#n:4"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:5" class="idref" href="#r:5"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Affine.html#r:5"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Affine.html#n:4"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>. { <span class="id" title="tactic">auto</span>. } <span class="comment">(*&nbsp;stuck&nbsp;here&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
This situation is desirable in a programming language with explicit
    deallocation, because it ensures that the code written by the
    programmer is not missing any deallocation operation. However, it is
    ill-suited for a programming language equipped with a garbage collector
    that deallocates data automatically.

<div class="paragraph"> </div>

    In this chapter, we present an "affine" version of Separation Logic,
    where the above function <span class="inlinecode"><span class="id" title="var">succ_using_incr</span></span> does admits the simple
    postcondition <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span>+1]</span>, i.e., that needs not mention the
    left-over reference in the postcondition. 
</div>
<div class="code">

<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#MotivatingExample"><span class="id" title="module">MotivatingExample</span></a>.<br/>
</div>

<div class="doc">
<a id="lab361"></a><h2 class="section">Statement of the Discard Rule</h2>

<div class="paragraph"> </div>

 There are several ways to state the "discard rule".
    Let us begin with two rules: one that discards a heap predicate <span class="inlinecode"><span class="id" title="var">H'</span></span>
    from the postcondition, and one that discards a heap predicate <span class="inlinecode"><span class="id" title="var">H'</span></span>
    from the precondition. 
<div class="paragraph"> </div>

 The first rule, named <span class="inlinecode"><span class="id" title="var">triple_hany_post</span></span>, asserts that an arbitrary heap
    predicate <span class="inlinecode"><span class="id" title="var">H'</span></span> can be dropped from the postcondition, simplifying it from
    <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*+</span> <span class="inlinecode"><span class="id" title="var">H'</span></span> to <span class="inlinecode"><span class="id" title="var">Q</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_hany_post" class="idref" href="#triple_hany_post"><span class="id" title="axiom">triple_hany_post</span></a> : <span class="id" title="keyword">∀</span> <a id="t:6" class="idref" href="#t:6"><span class="id" title="binder">t</span></a> <a id="H:7" class="idref" href="#H:7"><span class="id" title="binder">H</span></a> <a id="H':8" class="idref" href="#H':8"><span class="id" title="binder">H'</span></a> <a id="Q:9" class="idref" href="#Q:9"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:6"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:7"><span class="id" title="variable">H</span></a> (<a class="idref" href="Affine.html#Q:9"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H':8"><span class="id" title="variable">H'</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:6"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:7"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:9"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
Let us show that, using the rule <span class="inlinecode"><span class="id" title="var">triple_hany_post</span></span>, we can derive
    the desired specification for the motivating example from the
    specification that mentions the left-over postcondition. 
</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="MotivatingExampleSolved" class="idref" href="#MotivatingExampleSolved"><span class="id" title="module">MotivatingExampleSolved</span></a>.<br/>
<span class="id" title="keyword">Export</span> <span class="id" title="var">MotivatingExample</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="MotivatingExampleSolved.triple_succ_using_incr'" class="idref" href="#MotivatingExampleSolved.triple_succ_using_incr'"><span class="id" title="lemma">triple_succ_using_incr'</span></a> : <span class="id" title="keyword">∀</span> (<a id="n:11" class="idref" href="#n:11"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Affine.html#MotivatingExample.succ_using_incr"><span class="id" title="definition">succ_using_incr</span></a> <a class="idref" href="Affine.html#n:11"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:12" class="idref" href="#r:12"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Affine.html#r:12"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Affine.html#n:11"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#triple_hany_post"><span class="id" title="axiom">triple_hany_post</span></a>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#MotivatingExample.triple_succ_using_incr"><span class="id" title="lemma">triple_succ_using_incr</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#MotivatingExampleSolved"><span class="id" title="module">MotivatingExampleSolved</span></a>.<br/>
</div>

<div class="doc">
A symmetric rule, named <span class="inlinecode"><span class="id" title="var">triple_hany_pre</span></span>, asserts that an arbitrary
    heap predicate <span class="inlinecode"><span class="id" title="var">H'</span></span> can be dropped from the precondition, simplifying
    it from <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H'</span></span> to <span class="inlinecode"><span class="id" title="var">H</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_hany_pre" class="idref" href="#triple_hany_pre"><span class="id" title="axiom">triple_hany_pre</span></a> : <span class="id" title="keyword">∀</span> <a id="t:13" class="idref" href="#t:13"><span class="id" title="binder">t</span></a> <a id="H:14" class="idref" href="#H:14"><span class="id" title="binder">H</span></a> <a id="H':15" class="idref" href="#H':15"><span class="id" title="binder">H'</span></a> <a id="Q:16" class="idref" href="#Q:16"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:13"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:14"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:16"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:13"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#H:14"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H':15"><span class="id" title="variable">H'</span></a>) <a class="idref" href="Affine.html#Q:16"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
Observe the difference between the two rules. In <span class="inlinecode"><span class="id" title="var">triple_hany_post</span></span>,
    the discarded predicate <span class="inlinecode"><span class="id" title="var">H'</span></span> appears in the premise, reflecting the
    fact that we discard it after the evaluation of the term <span class="inlinecode"><span class="id" title="var">t</span></span>. On the
    contrary, in <span class="inlinecode"><span class="id" title="var">triple_hany_pre</span></span>, the discarded predicate <span class="inlinecode"><span class="id" title="var">H'</span></span> appears
    in the conclusion, reflecting the fact that we discard it before the
    evaluation of <span class="inlinecode"><span class="id" title="var">t</span></span>. 
<div class="paragraph"> </div>

 The two rules <span class="inlinecode"><span class="id" title="var">triple_hany_pre</span></span> and <span class="inlinecode"><span class="id" title="var">triple_hany_post</span></span> can be derived from
    each other. As we will establish further on, the rule <span class="inlinecode"><span class="id" title="var">triple_hany_pre</span></span> is
    derivable from <span class="inlinecode"><span class="id" title="var">triple_hany_post</span></span>, by a simple application of the frame
    rule. Reciprocally, <span class="inlinecode"><span class="id" title="var">triple_hany_post</span></span> is derivable from <span class="inlinecode"><span class="id" title="var">triple_hany_pre</span></span>,
    however the proof is more involved (it appears in the bonus section). 
</div>

<div class="doc">
<a id="lab362"></a><h2 class="section">Fine-grained Control on Collectable Predicates</h2>

<div class="paragraph"> </div>

 As suggested in the introduction, it may be useful to constrain
    the discard rule in such a way that it can be used to discard only
    certain types of heap predicates, and not arbitrary heap predicates.

<div class="paragraph"> </div>

    For example, even in a programming language featuring a garbage
    collector, it may be useful to ensure that every file handle opened
    eventually gets closed, or that every lock acquired is eventually
    released. File handles and locks are example of resources that may
    be described in Separation Logic, yet that one should not be allowed
    to discard freely.

<div class="paragraph"> </div>

    As another example, consider the extension of Separation Logic with
    "time credits", which are used for complexity analysis. In such a
    setting, it is desirable to be able to throw away a positive number of
    credits to reflect for over-approximations in the analysis. However,
    the logic must forbid discarding predicates that capture a negative
    number of credits, otherwise soundness would be compromised. 
<div class="paragraph"> </div>

 The idea is to restrict the discard rules so that only predicates
    satisyfing a predicate called <span class="inlinecode"><span class="id" title="var">haffine</span></span> may get discarded. The two
    discard rules will thus feature an extra premise requiring <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H'</span></span>,
    where <span class="inlinecode"><span class="id" title="var">H'</span></span> denotes the heap predicate being discarded. 
</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="Preview" class="idref" href="#Preview"><span class="id" title="module">Preview</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Parameter</span> <a id="Preview.haffine" class="idref" href="#Preview.haffine"><span class="id" title="axiom">haffine</span></a> : <a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Parameter</span> <a id="Preview.triple_haffine_post" class="idref" href="#Preview.triple_haffine_post"><span class="id" title="axiom">triple_haffine_post</span></a> : <span class="id" title="keyword">∀</span> <a id="t:19" class="idref" href="#t:19"><span class="id" title="binder">t</span></a> <a id="H:20" class="idref" href="#H:20"><span class="id" title="binder">H</span></a> <a id="H':21" class="idref" href="#H':21"><span class="id" title="binder">H'</span></a> <a id="Q:22" class="idref" href="#Q:22"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#Preview.haffine"><span class="id" title="axiom">haffine</span></a> <a class="idref" href="Affine.html#H':21"><span class="id" title="variable">H'</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:19"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:20"><span class="id" title="variable">H</span></a> (<a class="idref" href="Affine.html#Q:22"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H':21"><span class="id" title="variable">H'</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:19"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:20"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:22"><span class="id" title="variable">Q</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Parameter</span> <a id="Preview.triple_haffine_pre" class="idref" href="#Preview.triple_haffine_pre"><span class="id" title="axiom">triple_haffine_pre</span></a> : <span class="id" title="keyword">∀</span> <a id="t:24" class="idref" href="#t:24"><span class="id" title="binder">t</span></a> <a id="H:25" class="idref" href="#H:25"><span class="id" title="binder">H</span></a> <a id="H':26" class="idref" href="#H':26"><span class="id" title="binder">H'</span></a> <a id="Q:27" class="idref" href="#Q:27"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#Preview.haffine"><span class="id" title="axiom">haffine</span></a> <a class="idref" href="Affine.html#H':26"><span class="id" title="variable">H'</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:24"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:25"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:27"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:24"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#H:25"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H':26"><span class="id" title="variable">H'</span></a>) <a class="idref" href="Affine.html#Q:27"><span class="id" title="variable">Q</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#Preview"><span class="id" title="module">Preview</span></a>.<br/>
</div>

<div class="doc">
To constraint the discard rule and allow fine-tuning of which heap
    predicates may be thrown away, we introduce the notions of "affine
    heap" and of "affine heap predicates", captured by the judgments
    <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> and <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>, respectively.

<div class="paragraph"> </div>

    The definition of <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> is left abstract for the moment.
    We will show two extreme instantiations: one that leads to a logic
    where all predicates are affine (i.e. can be freely discarded),
    one one that leads to a logic where all predicates are linear
    (i.e. none can be freely discarded, like in our previous set up). 
</div>

<div class="doc">
<a id="lab363"></a><h2 class="section">Definition of <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> and of <span class="inlinecode"><span class="id" title="var">haffine</span></span></h2>

<div class="paragraph"> </div>

 Concretely, the notion of "affine heap" is characterize by the abstract
    predicate named <span class="inlinecode"><span class="id" title="var">heap_affine</span></span>, which is a predicate over heaps. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="heap_affine" class="idref" href="#heap_affine"><span class="id" title="axiom">heap_affine</span></a> : <a class="idref" href="LibSepReference.html#heap"><span class="id" title="definition">heap</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span>.<br/>
</div>

<div class="doc">
This predicate <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> is assumed to satisfy two properties: it holds
    of the empty heap, and it is stable by (disjoint) union of heaps. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="heap_affine_empty" class="idref" href="#heap_affine_empty"><span class="id" title="axiom">heap_affine_empty</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="LibSepReference.html#Fmap.empty"><span class="id" title="definition">Fmap.empty</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Parameter</span> <a id="heap_affine_union" class="idref" href="#heap_affine_union"><span class="id" title="axiom">heap_affine_union</span></a> : <span class="id" title="keyword">∀</span> <a id="h<sub>1</sub>:31" class="idref" href="#h<sub>1</sub>:31"><span class="id" title="binder">h<sub>1</sub></span></a> <a id="h<sub>2</sub>:32" class="idref" href="#h<sub>2</sub>:32"><span class="id" title="binder">h<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:31"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:32"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.disjoint"><span class="id" title="definition">Fmap.disjoint</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:31"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:32"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> (<a class="idref" href="LibSepReference.html#Fmap.union"><span class="id" title="definition">Fmap.union</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:31"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:32"><span class="id" title="variable">h<sub>2</sub></span></a>).<br/>
</div>

<div class="doc">
The predicate <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> captures the notion of "affine heap predicate".
    A heap predicate is affine iff it only holds of affine heaps. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="haffine" class="idref" href="#haffine"><span class="id" title="definition">haffine</span></a> (<a id="H:34" class="idref" href="#H:34"><span class="id" title="binder">H</span></a>:<a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a id="h:35" class="idref" href="#h:35"><span class="id" title="binder">h</span></a>, <a class="idref" href="Affine.html#H:34"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#h:35"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h:35"><span class="id" title="variable">h</span></a>.<br/>
</div>

<div class="doc">
The predicate <span class="inlinecode"><span class="id" title="var">haffine</span></span> distributes in a natural way on each of the
    operators of Separation Logic: the combination of affine heap predicates
    yields affine heap predicates. In particular:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class='gray-font'>\</span>[]</span> and <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">P</span>]</span>, which describes empty heaps, can always be discarded;

</li>
<li> <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> can be discarded if both <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> can be discarded;

</li>
<li> <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">H</span></span> and <span class="inlinecode">\<span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">H</span></span> can be discarded if <span class="inlinecode"><span class="id" title="var">H</span></span> can be
      discarded for any <span class="inlinecode"><span class="id" title="var">x</span></span>.

</li>
</ul>

<div class="paragraph"> </div>


</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="haffine_hempty" class="idref" href="#haffine_hempty"><span class="id" title="lemma">haffine_hempty</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">K</span>. <span class="id" title="var">lets</span> <span class="id" title="var">E</span>: <a class="idref" href="LibSepReference.html#SepSimplArgs.hempty_inv"><span class="id" title="lemma">hempty_inv</span></a> <span class="id" title="var">K</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#heap_affine_empty"><span class="id" title="axiom">heap_affine_empty</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="haffine_hpure" class="idref" href="#haffine_hpure"><span class="id" title="lemma">haffine_hpure</span></a> : <span class="id" title="keyword">∀</span> <a id="P:36" class="idref" href="#P:36"><span class="id" title="binder">P</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Affine.html#P:36"><span class="id" title="variable">P</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span> <span class="id" title="var">K</span>. <span class="id" title="var">lets</span> (<span class="id" title="var">HP</span>&amp;<span class="id" title="var">M</span>): <a class="idref" href="LibSepReference.html#SepSimplArgs.hpure_inv"><span class="id" title="lemma">hpure_inv</span></a> <span class="id" title="var">K</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">subst</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#heap_affine_empty"><span class="id" title="axiom">heap_affine_empty</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="haffine_hstar" class="idref" href="#haffine_hstar"><span class="id" title="lemma">haffine_hstar</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:37" class="idref" href="#H<sub>1</sub>:37"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:38" class="idref" href="#H<sub>2</sub>:38"><span class="id" title="binder">H<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:37"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:38"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="Affine.html#H<sub>1</sub>:37"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:38"><span class="id" title="variable">H<sub>2</sub></span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">M<sub>1</sub></span> <span class="id" title="var">M<sub>2</sub></span> <span class="id" title="var">K</span>. <span class="id" title="var">lets</span> (<span class="id" title="var">h<sub>1</sub></span>&amp;<span class="id" title="var">h<sub>2</sub></span>&amp;<span class="id" title="var">K<sub>1</sub></span>&amp;<span class="id" title="var">K<sub>2</sub></span>&amp;<span class="id" title="var">D</span>&amp;<span class="id" title="var">U</span>): <a class="idref" href="LibSepReference.html#SepSimplArgs.hstar_inv"><span class="id" title="lemma">hstar_inv</span></a> <span class="id" title="var">K</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">subst</span>. <span class="id" title="var">applys</span>* <a class="idref" href="Affine.html#heap_affine_union"><span class="id" title="axiom">heap_affine_union</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="haffine_hexists" class="idref" href="#haffine_hexists"><span class="id" title="lemma">haffine_hexists</span></a> : <span class="id" title="keyword">∀</span> <a id="A:39" class="idref" href="#A:39"><span class="id" title="binder">A</span></a> (<a id="J:40" class="idref" href="#J:40"><span class="id" title="binder">J</span></a>:<a class="idref" href="Affine.html#A:39"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="x:41" class="idref" href="#x:41"><span class="id" title="binder">x</span></a>, <a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="Affine.html#J:40"><span class="id" title="variable">J</span></a> <a class="idref" href="Affine.html#x:41"><span class="id" title="variable">x</span></a>)<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="x:42" class="idref" href="#x:42"><span class="id" title="binder">x</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#J:40"><span class="id" title="variable">J</span></a> <a class="idref" href="Affine.html#x:42"><span class="id" title="variable">x</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">F<sub>1</sub></span> (<span class="id" title="var">x</span>&amp;<span class="id" title="var">Hx</span>). <span class="id" title="var">applys</span>* <span class="id" title="var">F<sub>1</sub></span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="haffine_hforall'" class="idref" href="#haffine_hforall'"><span class="id" title="lemma">haffine_hforall'</span></a> : <span class="id" title="keyword">∀</span> <a id="A:43" class="idref" href="#A:43"><span class="id" title="binder">A</span></a> (<a id="J:44" class="idref" href="#J:44"><span class="id" title="binder">J</span></a>:<a class="idref" href="Affine.html#A:43"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="notation">∃</span> <a id="x:45" class="idref" href="#x:45"><span class="id" title="binder">x</span></a><span class="id" title="notation">,</span> <a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="Affine.html#J:44"><span class="id" title="variable">J</span></a> <a class="idref" href="Affine.html#x:45"><span class="id" title="variable">x</span></a>)<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">∀</span></a> <a id="x:46" class="idref" href="#x:46"><span class="id" title="binder">x</span></a><a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#J:44"><span class="id" title="variable">J</span></a> <a class="idref" href="Affine.html#x:46"><span class="id" title="variable">x</span></a><a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> (<span class="id" title="var">x</span>&amp;<span class="id" title="var">Hx</span>) <span class="id" title="var">M</span>. <span class="id" title="var">lets</span> <span class="id" title="var">N</span>: <a class="idref" href="LibSepReference.html#SepSimplArgs.hforall_inv"><span class="id" title="lemma">hforall_inv</span></a> <span class="id" title="var">M</span>. <span class="id" title="var">applys</span>* <span class="id" title="var">Hx</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The rule <span class="inlinecode"><span class="id" title="var">haffine_hforall'</span></span> requires the user to provide evidence
    that there exists at least one value <span class="inlinecode"><span class="id" title="var">x</span></span> of type <span class="inlinecode"><span class="id" title="var">A</span></span> for which
    <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode">(<span class="id" title="var">J</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span> is true. In practice, the user is generally not
    interested in proving properties of a specific value <span class="inlinecode"><span class="id" title="var">x</span></span>, but is
    happy to justify that <span class="inlinecode"><span class="id" title="var">J</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> is affine for any <span class="inlinecode"><span class="id" title="var">x</span></span>. The corresponding
    statement appears below, with an assumption <span class="inlinecode"><span class="id" title="var">Inhab</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> asserting that
    the type <span class="inlinecode"><span class="id" title="var">A</span></span> is inhabited. In practice, the <span class="inlinecode">\<span class="id" title="keyword">∀</span></span> quantifier
    is always invoked on inhabited types, so this is a benign restriction. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="haffine_hforall" class="idref" href="#haffine_hforall"><span class="id" title="lemma">haffine_hforall</span></a> : <span class="id" title="keyword">∀</span> <a id="A:47" class="idref" href="#A:47"><span class="id" title="binder">A</span></a> `{<a id="H:48" class="idref" href="#H:48"><span class="id" title="binder">Inhab</span></a> <a id="H:48" class="idref" href="#H:48"><span class="id" title="binder">A</span></a>} (<a id="J:49" class="idref" href="#J:49"><span class="id" title="binder">J</span></a>:<a class="idref" href="Affine.html#A:47"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="x:50" class="idref" href="#x:50"><span class="id" title="binder">x</span></a>, <a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="Affine.html#J:49"><span class="id" title="variable">J</span></a> <a class="idref" href="Affine.html#x:50"><span class="id" title="variable">x</span></a>)<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">∀</span></a> <a id="x:51" class="idref" href="#x:51"><span class="id" title="binder">x</span></a><a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#J:49"><span class="id" title="variable">J</span></a> <a class="idref" href="Affine.html#x:51"><span class="id" title="variable">x</span></a><a class="idref" href="LibSepReference.html#466ecb7d71d07e4d74c1c028c2497a<sub>33</sub>"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">IA</span> <span class="id" title="var">M</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#haffine_hforall'"><span class="id" title="lemma">haffine_hforall'</span></a>. <span class="id" title="tactic">∃</span> (<span class="id" title="definition">arbitrary</span> (<span class="id" title="var">A</span>:=<span class="id" title="var">A</span>)). <span class="id" title="var">applys</span> <span class="id" title="var">M</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
In addition, <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode">(<span class='gray-font'>\</span>[<span class="id" title="var">P</span>]</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H</span>)</span> should simplify to <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>
    under the hypothesis <span class="inlinecode"><span class="id" title="var">P</span></span>. Indeed, if a heap <span class="inlinecode"><span class="id" title="var">h</span></span> satisfies <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">P</span>]</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H</span></span>,
    then it must be the case that the proposition <span class="inlinecode"><span class="id" title="var">P</span></span> is true. Formally: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="haffine_hstar_hpure_l" class="idref" href="#haffine_hstar_hpure_l"><span class="id" title="lemma">haffine_hstar_hpure_l</span></a> : <span class="id" title="keyword">∀</span> <a id="P:52" class="idref" href="#P:52"><span class="id" title="binder">P</span></a> <a id="H:53" class="idref" href="#H:53"><span class="id" title="binder">H</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#P:52"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:53"><span class="id" title="variable">H</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Affine.html#P:52"><span class="id" title="variable">P</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H:53"><span class="id" title="variable">H</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span> <span class="id" title="var">K</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.hstar_hpure_l"><span class="id" title="lemma">hstar_hpure_l</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">K</span>. <span class="id" title="var">applys</span>* <span class="id" title="var">M</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab364"></a><h2 class="section">Definition of the "Affine Top" Heap Predicates</h2>

<div class="paragraph"> </div>

 We next introduce a new heap predicate, called "affine top" and
    written <span class="inlinecode">\<span class="id" title="var">GC</span></span>, that is very handy for describing "the possibility
    to discard a heap predicate". We use this predicate to reformulate the
    discard rules in a more concise and more usable manner.

<div class="paragraph"> </div>

    This predicate is written <span class="inlinecode">\<span class="id" title="var">GC</span></span> and named <span class="inlinecode"><span class="id" title="var">hgc</span></span> in the formalization.
    It holds of any affine heap.

<div class="paragraph"> </div>

    <span class="inlinecode">\<span class="id" title="var">GC</span></span> can be equivalently defined as <span class="inlinecode"><span class="id" title="var">heap_affine</span></span>, or as
    <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">H</span>,</span> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H</span>]</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H</span></span>. The latter formulation is expressed
    in terms of existing Separation Logic operators, hence it is easier
    to manipulate in proofs using the <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> tactic. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="hgc" class="idref" href="#hgc"><span class="id" title="definition">hgc</span></a> : <a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="H:54" class="idref" href="#H:54"><span class="id" title="binder">H</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:54"><span class="id" title="variable">H</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H:54"><span class="id" title="variable">H</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="var">Declare</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">hgc_scope</span>.<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">hgc_scope</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> <a id="60de723b3758066ad921153335e0c677" class="idref" href="#60de723b3758066ad921153335e0c677"><span class="id" title="notation">&quot;</span></a>\GC" := (<a class="idref" href="Affine.html#hgc"><span class="id" title="definition">hgc</span></a>) : <span class="id" title="var">hgc_scope</span>.<br/>
</div>

<div class="doc">
The introduction lemmas asserts that <span class="inlinecode">\<span class="id" title="var">GC</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> holds when <span class="inlinecode"><span class="id" title="var">h</span></span>
    satisfies <span class="inlinecode"><span class="id" title="var">heap_affine</span></span>. 
<div class="paragraph"> </div>

<a id="lab365"></a><h4 class="section">Exercise: 2 stars, standard, especially useful (triple_frame)</h4>
 Prove that the affine heap predicate holds of any affine heap. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="hgc_intro" class="idref" href="#hgc_intro"><span class="id" title="lemma">hgc_intro</span></a> : <span class="id" title="keyword">∀</span> <a id="h:55" class="idref" href="#h:55"><span class="id" title="binder">h</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h:55"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">h</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 The elimination lemma asserts the reciprocal. 
<div class="paragraph"> </div>

<a id="lab366"></a><h4 class="section">Exercise: 2 stars, standard, optional (hgc_inv)</h4>
 Prove the elimination lemma for <span class="inlinecode">\<span class="id" title="var">GC</span></span> expressed using <span class="inlinecode"><span class="id" title="var">heap_affine</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="hgc_inv" class="idref" href="#hgc_inv"><span class="id" title="lemma">hgc_inv</span></a> : <span class="id" title="keyword">∀</span> <a id="h:56" class="idref" href="#h:56"><span class="id" title="binder">h</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h:56"><span class="id" title="variable">h</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 Together, the introduction and the elimination rule justify the fact that
    <span class="inlinecode"><span class="id" title="var">hgc</span></span> could equivalently have been defined as <span class="inlinecode"><span class="id" title="var">heap_affine</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="hgc_eq_heap_affine" class="idref" href="#hgc_eq_heap_affine"><span class="id" title="lemma">hgc_eq_heap_affine</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#hgc"><span class="id" title="definition">hgc</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.himpl_antisym"><span class="id" title="lemma">himpl_antisym</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span> <span class="id" title="var">M</span>. <span class="id" title="var">applys</span>* <a class="idref" href="Affine.html#hgc_inv"><span class="id" title="axiom">hgc_inv</span></a>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span> <span class="id" title="var">M</span>. <span class="id" title="var">applys</span>* <a class="idref" href="Affine.html#hgc_intro"><span class="id" title="axiom">hgc_intro</span></a>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab367"></a><h2 class="section">Properties of the <span class="inlinecode">\<span class="id" title="var">GC</span></span> Predicate</h2>

<div class="paragraph"> </div>

 One fundamental property that appears necessary in many of the
    soundness proofs is the following lemma, which asserts that two
    occurences of <span class="inlinecode">\<span class="id" title="var">GC</span></span> can be collapsed into just one. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="hstar_hgc_hgc" class="idref" href="#hstar_hgc_hgc"><span class="id" title="lemma">hstar_hgc_hgc</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#hgc"><span class="id" title="definition">hgc</span></a>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.himpl_antisym"><span class="id" title="lemma">himpl_antisym</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xpull</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H<sub>1</sub></span> <span class="id" title="var">K<sub>1</sub></span> <span class="id" title="var">H<sub>2</sub></span> <span class="id" title="var">K<sub>2</sub></span>. <span class="id" title="var">xsimpl</span> (<span class="id" title="var">H<sub>1</sub></span> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <span class="id" title="var">H<sub>2</sub></span>). <span class="id" title="var">applys</span>* <a class="idref" href="Affine.html#haffine_hstar"><span class="id" title="lemma">haffine_hstar</span></a>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xpull</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span> <span class="id" title="var">K</span>. <span class="id" title="var">xsimpl</span> <span class="id" title="var">H</span> <a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a>. <span class="id" title="tactic">auto</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#haffine_hempty"><span class="id" title="lemma">haffine_hempty</span></a>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Another useful property is that the heap predicate <span class="inlinecode">\<span class="id" title="var">GC</span></span> itself
    satisifes <span class="inlinecode"><span class="id" title="var">haffine</span></span>. Indeed, <span class="inlinecode">\<span class="id" title="var">GC</span></span> denotes some heap <span class="inlinecode"><span class="id" title="var">H</span></span> such that
   <span class="inlinecode"><span class="id" title="var">H</span></span> is affine; Thus, by essence, it denotes an affine heap predicate. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="haffine_hgc" class="idref" href="#haffine_hgc"><span class="id" title="lemma">haffine_hgc</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="Affine.html#haffine_hexists"><span class="id" title="lemma">haffine_hexists</span></a>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#haffine_hstar_hpure_l"><span class="id" title="lemma">haffine_hstar_hpure_l</span></a>. <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The process of exploiting the <span class="inlinecode">\<span class="id" title="var">GC</span></span> to "absorb" affine heap predicates
    is captured by the following lemma, which asserts that a heap predicate
    <span class="inlinecode"><span class="id" title="var">H</span></span> entails <span class="inlinecode">\<span class="id" title="var">GC</span></span> whenever <span class="inlinecode"><span class="id" title="var">H</span></span> is affine. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="himpl_hgc_r" class="idref" href="#himpl_hgc_r"><span class="id" title="lemma">himpl_hgc_r</span></a> : <span class="id" title="keyword">∀</span> <a id="H:57" class="idref" href="#H:57"><span class="id" title="binder">H</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:57"><span class="id" title="variable">H</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:57"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span> <span class="id" title="var">K</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#hgc_intro"><span class="id" title="axiom">hgc_intro</span></a>. <span class="id" title="var">applys</span> <span class="id" title="var">M</span> <span class="id" title="var">K</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
In particular, the empty heap predicate <span class="inlinecode"><span class='gray-font'>\</span>[]</span> entails <span class="inlinecode">\<span class="id" title="var">GC</span></span>, because the
    empty heap predicate is affine (recall lemma <span class="inlinecode"><span class="id" title="var">haffine_hempty</span></span>). 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="hempty_himpl_hgc" class="idref" href="#hempty_himpl_hgc"><span class="id" title="lemma">hempty_himpl_hgc</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#himpl_hgc_r"><span class="id" title="lemma">himpl_hgc_r</span></a>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#haffine_hempty"><span class="id" title="lemma">haffine_hempty</span></a>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Using the predicate <span class="inlinecode">\<span class="id" title="var">GC</span></span>, we can reformulate the constrained
    discard rule <span class="inlinecode"><span class="id" title="var">triple_haffine_post</span></span> as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_hgc_post" class="idref" href="#triple_hgc_post"><span class="id" title="axiom">triple_hgc_post</span></a> : <span class="id" title="keyword">∀</span> <a id="t:58" class="idref" href="#t:58"><span class="id" title="binder">t</span></a> <a id="H:59" class="idref" href="#H:59"><span class="id" title="binder">H</span></a> <a id="Q:60" class="idref" href="#Q:60"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:58"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:59"><span class="id" title="variable">H</span></a> (<a class="idref" href="Affine.html#Q:60"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:58"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:59"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:60"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
Not only is this rule more concise than <span class="inlinecode"><span class="id" title="var">triple_haffine_post</span></span>, it
    also has the benefits that the piece of heap discarded, previously
    described by <span class="inlinecode"><span class="id" title="var">H'</span></span>, no longer needs to be provided upfront at the
    moment of applying the rule. It may be provided further on in the
    reasoning, for example in an entailment, by instantiating the
    existential quantifier carried into the definition of <span class="inlinecode">\<span class="id" title="var">GC</span></span>. 
</div>

<div class="doc">
<a id="lab368"></a><h2 class="section">Instantiation of <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> for a Fully Affine Logic</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="FullyAffineLogic" class="idref" href="#FullyAffineLogic"><span class="id" title="module">FullyAffineLogic</span></a>.<br/>
</div>

<div class="doc">
To set up a fully affine logic, we consider a definition of
    <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> that holds of any heap. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="FullyAffineLogic.heap_affine_def" class="idref" href="#FullyAffineLogic.heap_affine_def"><span class="id" title="axiom">heap_affine_def</span></a> : <span class="id" title="keyword">∀</span> <a id="h:62" class="idref" href="#h:62"><span class="id" title="binder">h</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h:62"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>
</div>

<div class="doc">
It is trivial to check that <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> satisfies the required
    distribution properties on the empty heap and the union of heaps. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="FullyAffineLogic.heap_affine_empty" class="idref" href="#FullyAffineLogic.heap_affine_empty"><span class="id" title="lemma">heap_affine_empty</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="LibSepReference.html#Fmap.empty"><span class="id" title="definition">Fmap.empty</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="tactic">rewrite</span>* <a class="idref" href="Affine.html#FullyAffineLogic.heap_affine_def"><span class="id" title="axiom">heap_affine_def</span></a>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="FullyAffineLogic.heap_affine_union" class="idref" href="#FullyAffineLogic.heap_affine_union"><span class="id" title="lemma">heap_affine_union</span></a> : <span class="id" title="keyword">∀</span> <a id="h<sub>1</sub>:64" class="idref" href="#h<sub>1</sub>:64"><span class="id" title="binder">h<sub>1</sub></span></a> <a id="h<sub>2</sub>:65" class="idref" href="#h<sub>2</sub>:65"><span class="id" title="binder">h<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:64"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:65"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.disjoint"><span class="id" title="definition">Fmap.disjoint</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:64"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:65"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> (<a class="idref" href="LibSepReference.html#Fmap.union"><span class="id" title="definition">Fmap.union</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:64"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:65"><span class="id" title="variable">h<sub>2</sub></span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">rewrite</span>* <a class="idref" href="Affine.html#FullyAffineLogic.heap_affine_def"><span class="id" title="axiom">heap_affine_def</span></a>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
With that instantiation, <span class="inlinecode"><span class="id" title="var">haffine</span></span> holds of any heap predicate. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="FullyAffineLogic.haffine_equiv" class="idref" href="#FullyAffineLogic.haffine_equiv"><span class="id" title="lemma">haffine_equiv</span></a> : <span class="id" title="keyword">∀</span> <a id="H:66" class="idref" href="#H:66"><span class="id" title="binder">H</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:66"><span class="id" title="variable">H</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">iff</span> <span class="id" title="var">M</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">auto</span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">rewrite</span>* <a class="idref" href="Affine.html#FullyAffineLogic.heap_affine_def"><span class="id" title="axiom">heap_affine_def</span></a>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
With that instantiation, the affine top predicate <span class="inlinecode">\<span class="id" title="var">GC</span></span> is equivalent
    to the top predicate <span class="inlinecode"><span class="id" title="var">htop</span></span>, defined as <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">True</span></span> or, equivalently,
    as <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">H</span>,</span> <span class="inlinecode"><span class="id" title="var">H</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="FullyAffineLogic.htop" class="idref" href="#FullyAffineLogic.htop"><span class="id" title="definition">htop</span></a> : <a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="H:67" class="idref" href="#H:67"><span class="id" title="binder">H</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="Affine.html#H:67"><span class="id" title="variable">H</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="FullyAffineLogic.hgc_eq_htop" class="idref" href="#FullyAffineLogic.hgc_eq_htop"><span class="id" title="lemma">hgc_eq_htop</span></a> : <a class="idref" href="Affine.html#hgc"><span class="id" title="definition">hgc</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Affine.html#FullyAffineLogic.htop"><span class="id" title="definition">htop</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#hgc"><span class="id" title="definition">hgc</span></a>, <a class="idref" href="Affine.html#FullyAffineLogic.htop"><span class="id" title="definition">htop</span></a>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.himpl_antisym"><span class="id" title="lemma">himpl_antisym</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xsimpl</span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xsimpl</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">rewrite</span>* <a class="idref" href="Affine.html#FullyAffineLogic.haffine_equiv"><span class="id" title="lemma">haffine_equiv</span></a>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#FullyAffineLogic"><span class="id" title="module">FullyAffineLogic</span></a>.<br/>
</div>

<div class="doc">
<a id="lab369"></a><h2 class="section">Instantiation of <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> for a Fully Linear Logic</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="FullyLinearLogic" class="idref" href="#FullyLinearLogic"><span class="id" title="module">FullyLinearLogic</span></a>.<br/>
</div>

<div class="doc">
To set up a fully affine logic, we consider a definition of
    <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> that holds only of empty heaps. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="FullyLinearLogic.heap_affine_def" class="idref" href="#FullyLinearLogic.heap_affine_def"><span class="id" title="axiom">heap_affine_def</span></a> : <span class="id" title="keyword">∀</span> <a id="h:68" class="idref" href="#h:68"><span class="id" title="binder">h</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h:68"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#h:68"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#Fmap.empty"><span class="id" title="definition">Fmap.empty</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
Again, it is not hard to check that <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> satisfies the
    required distributivity properties. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="FullyLinearLogic.heap_affine_empty" class="idref" href="#FullyLinearLogic.heap_affine_empty"><span class="id" title="lemma">heap_affine_empty</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="LibSepReference.html#Fmap.empty"><span class="id" title="definition">Fmap.empty</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="tactic">rewrite</span>* <a class="idref" href="Affine.html#FullyLinearLogic.heap_affine_def"><span class="id" title="axiom">heap_affine_def</span></a>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="FullyLinearLogic.heap_affine_union" class="idref" href="#FullyLinearLogic.heap_affine_union"><span class="id" title="lemma">heap_affine_union</span></a> : <span class="id" title="keyword">∀</span> <a id="h<sub>1</sub>:70" class="idref" href="#h<sub>1</sub>:70"><span class="id" title="binder">h<sub>1</sub></span></a> <a id="h<sub>2</sub>:71" class="idref" href="#h<sub>2</sub>:71"><span class="id" title="binder">h<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:70"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:71"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.disjoint"><span class="id" title="definition">Fmap.disjoint</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:70"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:71"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> (<a class="idref" href="LibSepReference.html#Fmap.union"><span class="id" title="definition">Fmap.union</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:70"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:71"><span class="id" title="variable">h<sub>2</sub></span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">K<sub>1</sub></span> <span class="id" title="var">K<sub>2</sub></span> <span class="id" title="var">D</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="Affine.html#FullyLinearLogic.heap_affine_def"><span class="id" title="axiom">heap_affine_def</span></a> <span class="id" title="keyword">in</span> *.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">subst</span>. <span class="id" title="tactic">rewrite</span>* <a class="idref" href="LibSepReference.html#Fmap.union_empty_r"><span class="id" title="lemma">Fmap.union_empty_r</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The predicate <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> is equivalent to <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class='gray-font'>\</span>[]</span>,
    that is, it characterizes heap predicates that hold of the
    empty heap. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="FullyLinearLogic.haffine_equiv" class="idref" href="#FullyLinearLogic.haffine_equiv"><span class="id" title="lemma">haffine_equiv</span></a> : <span class="id" title="keyword">∀</span> <a id="H:72" class="idref" href="#H:72"><span class="id" title="binder">H</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:72"><span class="id" title="variable">H</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#H:72"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a>. <span class="id" title="var">iff</span> <span class="id" title="var">M</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span> <span class="id" title="var">K</span>. <span class="id" title="var">specializes</span> <span class="id" title="var">M</span> <span class="id" title="var">K</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="Affine.html#FullyLinearLogic.heap_affine_def"><span class="id" title="axiom">heap_affine_def</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">M</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">subst</span>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.hempty_intro"><span class="id" title="lemma">hempty_intro</span></a>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span> <span class="id" title="var">K</span>. <span class="id" title="var">specializes</span> <span class="id" title="var">M</span> <span class="id" title="var">K</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="Affine.html#FullyLinearLogic.heap_affine_def"><span class="id" title="axiom">heap_affine_def</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.hempty_inv"><span class="id" title="lemma">hempty_inv</span></a> <span class="id" title="var">M</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
With that instantiation, the affine top predicate <span class="inlinecode">\<span class="id" title="var">GC</span></span> is equivalent
    to the empty heap predicate <span class="inlinecode"><span class="id" title="var">hempty</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="FullyLinearLogic.hgc_eq_hempty" class="idref" href="#FullyLinearLogic.hgc_eq_hempty"><span class="id" title="lemma">hgc_eq_hempty</span></a> : <a class="idref" href="Affine.html#hgc"><span class="id" title="definition">hgc</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#SepSimplArgs.hempty"><span class="id" title="definition">hempty</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#hgc"><span class="id" title="definition">hgc</span></a>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.himpl_antisym"><span class="id" title="lemma">himpl_antisym</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xpull</span>. <span class="id" title="var">introv</span> <span class="id" title="var">N</span>. <span class="id" title="tactic">rewrite</span>* <a class="idref" href="Affine.html#FullyLinearLogic.haffine_equiv"><span class="id" title="lemma">haffine_equiv</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">N</span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xsimpl</span> <a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#haffine_hempty"><span class="id" title="lemma">haffine_hempty</span></a>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#FullyLinearLogic"><span class="id" title="module">FullyLinearLogic</span></a>.<br/>
</div>

<div class="doc">
<a id="lab370"></a><h2 class="section">Refined Definition of Separation Logic Triples</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="NewTriples" class="idref" href="#NewTriples"><span class="id" title="module">NewTriples</span></a>.<br/>
</div>

<div class="doc">
Thereafter, we purposely leave the definition of <span class="inlinecode"><span class="id" title="var">haffine</span></span>
    abstract, for the sake of generality.

<div class="paragraph"> </div>

    In what follows, we explain how to refine the notion of Separation
    Logic triple so as to accomodate the discard rule.

<div class="paragraph"> </div>

    Recall the definition of triple for a linear logic.
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">triple</span> (<span class="id" title="var">t</span>:<span class="id" title="var">trm</span>) (<span class="id" title="var">H</span>:<span class="id" title="var">hprop</span>) (<span class="id" title="var">Q</span>:<span class="id" title="var">val</span>→<span class="id" title="var">hprop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">H'</span>:<span class="id" title="var">hprop</span>), <span class="id" title="var">hoare</span> <span class="id" title="var">t</span> (<span class="id" title="var">H</span> <span class='gray-font'>\</span>* <span class="id" title="var">H'</span>) (<span class="id" title="var">Q</span> <span class='gray-font'>\</span>*+ <span class="id" title="var">H'</span>).
</span>    The discard rule <span class="inlinecode"><span class="id" title="var">triple_htop_post</span></span> asserts that postconditions
    may be freely extended with the <span class="inlinecode">\<span class="id" title="var">GC</span></span> predicate. To support
    this rule, it suffices to modify the definition of <span class="inlinecode"><span class="id" title="var">triple</span></span> to
    include the predicate <span class="inlinecode">\<span class="id" title="var">GC</span></span> in the postcondition of the underlying
    Hoare triple, as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="NewTriples.triple" class="idref" href="#NewTriples.triple"><span class="id" title="definition">triple</span></a> (<a id="t:73" class="idref" href="#t:73"><span class="id" title="binder">t</span></a>:<a class="idref" href="LibSepReference.html#trm"><span class="id" title="inductive">trm</span></a>) (<a id="H:74" class="idref" href="#H:74"><span class="id" title="binder">H</span></a>:<a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>) (<a id="Q:75" class="idref" href="#Q:75"><span class="id" title="binder">Q</span></a>:<a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<a id="H':76" class="idref" href="#H':76"><span class="id" title="binder">H'</span></a>:<a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>), <a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> <a class="idref" href="Affine.html#t:73"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#H:74"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H':76"><span class="id" title="variable">H'</span></a>) (<a class="idref" href="Affine.html#Q:75"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H':76"><span class="id" title="variable">H'</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>).<br/>
</div>

<div class="doc">
Observe that this definition of <span class="inlinecode"><span class="id" title="var">triple</span></span> is strictly more general than
    the previous one. Indeed, as explained earlier on, when considering the
    fully linear instantiation of <span class="inlinecode"><span class="id" title="var">haffine</span></span>, the predicate <span class="inlinecode">\<span class="id" title="var">GC</span></span> is equivalent
    to the empty predicate <span class="inlinecode"><span class='gray-font'>\</span>[]</span>. In this case, the occurence of <span class="inlinecode">\<span class="id" title="var">GC</span></span> that
    appears in the definition of <span class="inlinecode"><span class="id" title="var">triple</span></span> can be replaced with <span class="inlinecode"><span class='gray-font'>\</span>[]</span>, yielding
    a definition equivalent to our original definition of <span class="inlinecode"><span class="id" title="var">triple</span></span>. 
<div class="paragraph"> </div>

 For the updated definition of <span class="inlinecode"><span class="id" title="var">triple</span></span> using <span class="inlinecode">\<span class="id" title="var">GC</span></span>, one can prove that:

<div class="paragraph"> </div>

<ul class="doclist">
<li> all the existing reasoning rules of Separation Logic remain sound;

</li>
<li> the discard rules <span class="inlinecode"><span class="id" title="var">triple_htop_post</span></span>, <span class="inlinecode"><span class="id" title="var">triple_haffine_hpost</span></span>
      and <span class="inlinecode"><span class="id" title="var">triple_haffine_hpre</span></span> can be proved sound.

</li>
</ul>

<div class="paragraph"> </div>


</div>

<div class="doc">
<a id="lab371"></a><h2 class="section">Soundness of the Existing Rules</h2>

<div class="paragraph"> </div>

 Let us update the soundness proof for the other structural rules. 
<div class="paragraph"> </div>

<a id="lab372"></a><h4 class="section">Exercise: 3 stars, standard, especially useful (triple_frame)</h4>
 Prove the frame rule for the definition of <span class="inlinecode"><span class="id" title="var">triple</span></span> that includes <span class="inlinecode">\<span class="id" title="var">GC</span></span>.
    Hint: unfold the definition of <span class="inlinecode"><span class="id" title="var">triple</span></span> but not that of <span class="inlinecode"><span class="id" title="var">hoare</span></span>,
    then exploit lemma <span class="inlinecode"><span class="id" title="var">hoare_conseq</span></span> and conclude using the tactic <span class="inlinecode"><span class="id" title="var">xsimpl</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.triple_frame" class="idref" href="#NewTriples.triple_frame"><span class="id" title="lemma">triple_frame</span></a> : <span class="id" title="keyword">∀</span> <a id="t:77" class="idref" href="#t:77"><span class="id" title="binder">t</span></a> <a id="H:78" class="idref" href="#H:78"><span class="id" title="binder">H</span></a> <a id="Q:79" class="idref" href="#Q:79"><span class="id" title="binder">Q</span></a> <a id="H':80" class="idref" href="#H':80"><span class="id" title="binder">H'</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:77"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:78"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:79"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:77"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#H:78"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H':80"><span class="id" title="variable">H'</span></a>) (<a class="idref" href="Affine.html#Q:79"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H':80"><span class="id" title="variable">H'</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab373"></a><h4 class="section">Exercise: 3 stars, standard, optional (triple_conseq)</h4>
 Prove the frame rule for the definition of <span class="inlinecode"><span class="id" title="var">triple</span></span> that includes <span class="inlinecode">\<span class="id" title="var">GC</span></span>.
    Hint: follow the same approach as in the proof of <span class="inlinecode"><span class="id" title="var">triple_frame</span></span>,
    and leverage the tactic <span class="inlinecode"><span class="id" title="var">xchange</span></span> to conclude. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.triple_conseq" class="idref" href="#NewTriples.triple_conseq"><span class="id" title="lemma">triple_conseq</span></a> : <span class="id" title="keyword">∀</span> <a id="t:81" class="idref" href="#t:81"><span class="id" title="binder">t</span></a> <a id="H':82" class="idref" href="#H':82"><span class="id" title="binder">H'</span></a> <a id="Q':83" class="idref" href="#Q':83"><span class="id" title="binder">Q'</span></a> <a id="H:84" class="idref" href="#H:84"><span class="id" title="binder">H</span></a> <a id="Q:85" class="idref" href="#Q:85"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:81"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H':82"><span class="id" title="variable">H'</span></a> <a class="idref" href="Affine.html#Q':83"><span class="id" title="variable">Q'</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:84"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#H':82"><span class="id" title="variable">H'</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#Q':83"><span class="id" title="variable">Q'</span></a> <a class="idref" href="LibSepReference.html#9351a4f098e275023c32e0091e608189"><span class="id" title="notation">===&gt;</span></a> <a class="idref" href="Affine.html#Q:85"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:81"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:84"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:85"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 The extraction rules remain valid as well. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.triple_hpure" class="idref" href="#NewTriples.triple_hpure"><span class="id" title="lemma">triple_hpure</span></a> : <span class="id" title="keyword">∀</span> <a id="t:86" class="idref" href="#t:86"><span class="id" title="binder">t</span></a> (<a id="P:87" class="idref" href="#P:87"><span class="id" title="binder">P</span></a>:<span class="id" title="keyword">Prop</span>) <a id="H:88" class="idref" href="#H:88"><span class="id" title="binder">H</span></a> <a id="Q:89" class="idref" href="#Q:89"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#P:87"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:86"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:88"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:89"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:86"><span class="id" title="variable">t</span></a> (<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Affine.html#P:87"><span class="id" title="variable">P</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H:88"><span class="id" title="variable">H</span></a>) <a class="idref" href="Affine.html#Q:89"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="var">unfolds</span> <a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.hstar_assoc"><span class="id" title="lemma">hstar_assoc</span></a>. <span class="id" title="var">applys</span>* <a class="idref" href="LibSepReference.html#hoare_hpure"><span class="id" title="lemma">hoare_hpure</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="NewTriples.triple_hexists" class="idref" href="#NewTriples.triple_hexists"><span class="id" title="lemma">triple_hexists</span></a> : <span class="id" title="keyword">∀</span> <a id="t:90" class="idref" href="#t:90"><span class="id" title="binder">t</span></a> (<a id="A:91" class="idref" href="#A:91"><span class="id" title="binder">A</span></a>:<span class="id" title="keyword">Type</span>) (<a id="J:92" class="idref" href="#J:92"><span class="id" title="binder">J</span></a>:<a class="idref" href="Affine.html#A:91"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>) <a id="Q:93" class="idref" href="#Q:93"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="x:94" class="idref" href="#x:94"><span class="id" title="binder">x</span></a>, <a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:90"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#J:92"><span class="id" title="variable">J</span></a> <a class="idref" href="Affine.html#x:94"><span class="id" title="variable">x</span></a>) <a class="idref" href="Affine.html#Q:93"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:90"><span class="id" title="variable">t</span></a> (<a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="x:95" class="idref" href="#x:95"><span class="id" title="binder">x</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="Affine.html#J:92"><span class="id" title="variable">J</span></a> <a class="idref" href="Affine.html#x:95"><span class="id" title="variable">x</span></a>) <a class="idref" href="Affine.html#Q:93"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="var">unfolds</span> <a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.hstar_hexists"><span class="id" title="lemma">hstar_hexists</span></a>. <span class="id" title="var">applys</span>* <a class="idref" href="LibSepReference.html#hoare_hexists"><span class="id" title="lemma">hoare_hexists</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The standard reasoning rules of Separation Logic can be derived
    for the revised notion of Separation Logic triple, the one which
    includes <span class="inlinecode">\<span class="id" title="var">GC</span></span>, following essentially the same proofs as for the
    original Separation Logic triples. The main difference is that one
    sometimes needs to invoke the lemma <span class="inlinecode"><span class="id" title="var">hstar_hgc_hgc</span></span> for collapsing
    two <span class="inlinecode">\<span class="id" title="var">GC</span></span> into a single one.

<div class="paragraph"> </div>

    In what follows, we present just one representative example of
    such proofs, namely the reasoning rule for sequences. This proof
    is similar to that of lemma <span class="inlinecode"><span class="id" title="var">triple_seq</span></span> from chapter <a href="Rules.html"><span class="inlineref">Rules</span></a>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.triple_seq" class="idref" href="#NewTriples.triple_seq"><span class="id" title="lemma">triple_seq</span></a> : <span class="id" title="keyword">∀</span> <a id="t<sub>1</sub>:96" class="idref" href="#t<sub>1</sub>:96"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="t<sub>2</sub>:97" class="idref" href="#t<sub>2</sub>:97"><span class="id" title="binder">t<sub>2</sub></span></a> <a id="H:98" class="idref" href="#H:98"><span class="id" title="binder">H</span></a> <a id="Q:99" class="idref" href="#Q:99"><span class="id" title="binder">Q</span></a> <a id="H<sub>1</sub>:100" class="idref" href="#H<sub>1</sub>:100"><span class="id" title="binder">H<sub>1</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t<sub>1</sub>:96"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Affine.html#H:98"><span class="id" title="variable">H</span></a> (<span class="id" title="keyword">fun</span> <a id="v:101" class="idref" href="#v:101"><span class="id" title="binder">v</span></a> ⇒ <a class="idref" href="Affine.html#H<sub>1</sub>:100"><span class="id" title="variable">H<sub>1</sub></span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t<sub>2</sub>:97"><span class="id" title="variable">t<sub>2</sub></span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:100"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Affine.html#Q:99"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_seq"><span class="id" title="constructor">trm_seq</span></a> <a class="idref" href="Affine.html#t<sub>1</sub>:96"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Affine.html#t<sub>2</sub>:97"><span class="id" title="variable">t<sub>2</sub></span></a>) <a class="idref" href="Affine.html#H:98"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:99"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">M<sub>1</sub></span> <span class="id" title="var">M<sub>2</sub></span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>. <span class="id" title="var">unfolds</span> <a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#hoare_seq"><span class="id" title="lemma">hoare_seq</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <span class="id" title="var">M<sub>1</sub></span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#hoare_conseq"><span class="id" title="lemma">hoare_conseq</span></a>. { <span class="id" title="var">applys</span> <span class="id" title="var">M<sub>2</sub></span>. } { <span class="id" title="var">xsimpl</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">xchanges</span> <a class="idref" href="Affine.html#hstar_hgc_hgc"><span class="id" title="lemma">hstar_hgc_hgc</span></a>. } }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab374"></a><h2 class="section">Soundness of the Discard Rules</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a id="NewTriples.GCRules" class="idref" href="#NewTriples.GCRules"><span class="id" title="module">GCRules</span></a>.<br/>
</div>

<div class="doc">
Let us first establish the soundness of the discard rule
    <span class="inlinecode"><span class="id" title="var">triple_htop_post</span></span>. 
<div class="paragraph"> </div>

<a id="lab375"></a><h4 class="section">Exercise: 3 stars, standard, especially useful (triple_hgc_post)</h4>
 Prove <span class="inlinecode"><span class="id" title="var">triple_h_post</span></span> with respect to the refined definition of
    <span class="inlinecode"><span class="id" title="var">triple</span></span> that includes <span class="inlinecode">\<span class="id" title="var">GC</span></span> in the postcondition.
    Hint: exploit <span class="inlinecode"><span class="id" title="var">hoare_conseq</span></span>, then exploit <span class="inlinecode"><span class="id" title="var">hstar_hgc_hgc</span></span>, with
    help of the tactics <span class="inlinecode"><span class="id" title="var">xchange</span></span> and <span class="inlinecode"><span class="id" title="var">xsimpl</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.GCRules.triple_hgc_post" class="idref" href="#NewTriples.GCRules.triple_hgc_post"><span class="id" title="lemma">triple_hgc_post</span></a> : <span class="id" title="keyword">∀</span> <a id="t:102" class="idref" href="#t:102"><span class="id" title="binder">t</span></a> <a id="H:103" class="idref" href="#H:103"><span class="id" title="binder">H</span></a> <a id="Q:104" class="idref" href="#Q:104"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:102"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:103"><span class="id" title="variable">H</span></a> (<a class="idref" href="Affine.html#Q:104"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:102"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:103"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:104"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab376"></a><h4 class="section">Exercise: 1 star, standard, especially useful (triple_haffine_post)</h4>
 Prove that <span class="inlinecode"><span class="id" title="var">triple_haffine_post</span></span> is derivable from <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span>.
    Hint: unfold the definition of <span class="inlinecode">\<span class="id" title="var">GC</span></span> using <span class="inlinecode"><span class="id" title="tactic">unfold</span></span> <span class="inlinecode"><span class="id" title="var">hgc</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.GCRules.triple_haffine_post" class="idref" href="#NewTriples.GCRules.triple_haffine_post"><span class="id" title="lemma">triple_haffine_post</span></a> : <span class="id" title="keyword">∀</span> <a id="t:105" class="idref" href="#t:105"><span class="id" title="binder">t</span></a> <a id="H:106" class="idref" href="#H:106"><span class="id" title="binder">H</span></a> <a id="H':107" class="idref" href="#H':107"><span class="id" title="binder">H'</span></a> <a id="Q:108" class="idref" href="#Q:108"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H':107"><span class="id" title="variable">H'</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:105"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:106"><span class="id" title="variable">H</span></a> (<a class="idref" href="Affine.html#Q:108"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H':107"><span class="id" title="variable">H'</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:105"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:106"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:108"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab377"></a><h4 class="section">Exercise: 1 star, standard, optional (triple_hgc_post_from_triple_haffine_post)</h4>
 Reciprocally, prove that <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span> is derivable from
    <span class="inlinecode"><span class="id" title="var">triple_haffine_post</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.GCRules.triple_hgc_post_from_triple_haffine_post" class="idref" href="#NewTriples.GCRules.triple_hgc_post_from_triple_haffine_post"><span class="id" title="lemma">triple_hgc_post_from_triple_haffine_post</span></a> : <span class="id" title="keyword">∀</span> <a id="t:109" class="idref" href="#t:109"><span class="id" title="binder">t</span></a> <a id="H:110" class="idref" href="#H:110"><span class="id" title="binder">H</span></a> <a id="Q:111" class="idref" href="#Q:111"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:109"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:110"><span class="id" title="variable">H</span></a> (<a class="idref" href="Affine.html#Q:111"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:109"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:110"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:111"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab378"></a><h4 class="section">Exercise: 1 star, standard, optional (triple_haffine_pre)</h4>
 Prove that <span class="inlinecode"><span class="id" title="var">triple_haffine_pre</span></span> is derivable from <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span>.
    Hint: exploit the frame rule, and leverage <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span>
    either directly or by invoking its corollary <span class="inlinecode"><span class="id" title="var">triple_haffine_post</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.GCRules.triple_haffine_pre" class="idref" href="#NewTriples.GCRules.triple_haffine_pre"><span class="id" title="lemma">triple_haffine_pre</span></a> : <span class="id" title="keyword">∀</span> <a id="t:112" class="idref" href="#t:112"><span class="id" title="binder">t</span></a> <a id="H:113" class="idref" href="#H:113"><span class="id" title="binder">H</span></a> <a id="H':114" class="idref" href="#H':114"><span class="id" title="binder">H'</span></a> <a id="Q:115" class="idref" href="#Q:115"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H':114"><span class="id" title="variable">H'</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:112"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:113"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:115"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:112"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#H:113"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H':114"><span class="id" title="variable">H'</span></a>) <a class="idref" href="Affine.html#Q:115"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab379"></a><h4 class="section">Exercise: 1 star, standard, optional (triple_conseq_frame_hgc)</h4>
 Prove the combined structural rule <span class="inlinecode"><span class="id" title="var">triple_conseq_frame_hgc</span></span>, which
    extends <span class="inlinecode"><span class="id" title="var">triple_conseq_frame</span></span> with the discard rule, replacing
    <span class="inlinecode"><span class="id" title="var">Q<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*+</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> <span class="inlinecode">===&gt;</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> with <span class="inlinecode"><span class="id" title="var">Q<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*+</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> <span class="inlinecode">===&gt;</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*+</span> <span class="inlinecode">\<span class="id" title="var">GC</span></span>.
    Hint: invoke <span class="inlinecode"><span class="id" title="var">triple_conseq</span></span>, <span class="inlinecode"><span class="id" title="var">triple_frame</span></span> and <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span>
    in the appropriate order. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.GCRules.triple_conseq_frame_hgc" class="idref" href="#NewTriples.GCRules.triple_conseq_frame_hgc"><span class="id" title="lemma">triple_conseq_frame_hgc</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>2</sub>:116" class="idref" href="#H<sub>2</sub>:116"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="H<sub>1</sub>:117" class="idref" href="#H<sub>1</sub>:117"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="Q<sub>1</sub>:118" class="idref" href="#Q<sub>1</sub>:118"><span class="id" title="binder">Q<sub>1</sub></span></a> <a id="t:119" class="idref" href="#t:119"><span class="id" title="binder">t</span></a> <a id="H:120" class="idref" href="#H:120"><span class="id" title="binder">H</span></a> <a id="Q:121" class="idref" href="#Q:121"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:119"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:117"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Affine.html#Q<sub>1</sub>:118"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:120"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:117"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:116"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#Q<sub>1</sub>:118"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:116"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#9351a4f098e275023c32e0091e608189"><span class="id" title="notation">===&gt;</span></a> <a class="idref" href="Affine.html#Q:121"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:119"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:120"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:121"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab380"></a><h4 class="section">Exercise: 1 star, standard, optional (triple_ramified_frame_hgc)</h4>
 Prove the following generalization of the ramified frame rule
    that includes the discard rule.
    Hint: it is a corollary of <span class="inlinecode"><span class="id" title="var">triple_conseq_frame_hgc</span></span>. Take inspiration
    from the proof of <span class="inlinecode"><span class="id" title="var">triple_ramified_frame</span></span> in chapter <a href="Wand.html"><span class="inlineref">Wand</span></a>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.GCRules.triple_ramified_frame_hgc" class="idref" href="#NewTriples.GCRules.triple_ramified_frame_hgc"><span class="id" title="lemma">triple_ramified_frame_hgc</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:122" class="idref" href="#H<sub>1</sub>:122"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="Q<sub>1</sub>:123" class="idref" href="#Q<sub>1</sub>:123"><span class="id" title="binder">Q<sub>1</sub></span></a> <a id="t:124" class="idref" href="#t:124"><span class="id" title="binder">t</span></a> <a id="H:125" class="idref" href="#H:125"><span class="id" title="binder">H</span></a> <a id="Q:126" class="idref" href="#Q:126"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:124"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:122"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="Affine.html#Q<sub>1</sub>:123"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:125"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:122"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#Q<sub>1</sub>:123"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation"><span class='gray-font'>\</span><span class="nowrap">&minus;&minus;&lowast;</span></span></a> <a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#Q:126"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a><a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation">)</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:124"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:125"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:126"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="code">

<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#NewTriples.GCRules"><span class="id" title="module">GCRules</span></a>.<br/>
</div>

<div class="doc">
<a id="lab381"></a><h2 class="section">Discard Rules in WP Style</h2>

<div class="paragraph"> </div>

 Let us update the definition of <span class="inlinecode"><span class="id" title="var">wp</span></span> to use the new definition
    of <span class="inlinecode"><span class="id" title="var">triple</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="NewTriples.wp" class="idref" href="#NewTriples.wp"><span class="id" title="definition">wp</span></a> (<a id="t:127" class="idref" href="#t:127"><span class="id" title="binder">t</span></a>:<a class="idref" href="LibSepReference.html#trm"><span class="id" title="inductive">trm</span></a>) (<a id="Q:128" class="idref" href="#Q:128"><span class="id" title="binder">Q</span></a>:<a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>) : <a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">(</span></a><a id="H:129" class="idref" href="#H:129"><span class="id" title="binder">H</span></a>:<a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">),</span></a> <a class="idref" href="Affine.html#H:129"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:127"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:129"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:128"><span class="id" title="variable">Q</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>.<br/>
</div>

<div class="doc">
Recall the characteristic equivalence of <span class="inlinecode"><span class="id" title="var">wp</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.wp_equiv" class="idref" href="#NewTriples.wp_equiv"><span class="id" title="lemma">wp_equiv</span></a> : <span class="id" title="keyword">∀</span> <a id="t:130" class="idref" href="#t:130"><span class="id" title="binder">t</span></a> <a id="H:131" class="idref" href="#H:131"><span class="id" title="binder">H</span></a> <a id="Q:132" class="idref" href="#Q:132"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#H:131"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a> <a class="idref" href="Affine.html#t:130"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#Q:132"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:130"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:131"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:132"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a>. <span class="id" title="var">iff</span> <span class="id" title="var">M</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span>* <a class="idref" href="Affine.html#NewTriples.triple_conseq"><span class="id" title="axiom">triple_conseq</span></a> <span class="id" title="var">Q</span> <span class="id" title="var">M</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="Affine.html#NewTriples.triple_hexists"><span class="id" title="lemma">triple_hexists</span></a>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.hstar_comm"><span class="id" title="lemma">hstar_comm</span></a>. <span class="id" title="var">applys</span>* <a class="idref" href="Affine.html#NewTriples.triple_hpure"><span class="id" title="lemma">triple_hpure</span></a>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xsimpl</span>* <span class="id" title="var">H</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
In weakest precondition style, the discard rule <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span>
    translates into the entailment <span class="inlinecode"><span class="id" title="var">wp</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">(<span class="id" title="var">Q</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*+</span> <span class="inlinecode">\<span class="id" title="var">GC</span>)</span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class="id" title="var">wp</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span>,
    as we prove next. 
<div class="paragraph"> </div>

<a id="lab382"></a><h4 class="section">Exercise: 1 star, standard, optional (wp_hgc_post)</h4>
 Prove the discard rule in wp-style.
    Hint: exploit <span class="inlinecode"><span class="id" title="var">wp_equiv</span></span> and <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.wp_hgc_post" class="idref" href="#NewTriples.wp_hgc_post"><span class="id" title="lemma">wp_hgc_post</span></a> : <span class="id" title="keyword">∀</span> <a id="t:133" class="idref" href="#t:133"><span class="id" title="binder">t</span></a> <a id="Q:134" class="idref" href="#Q:134"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a> <a class="idref" href="Affine.html#t:133"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#Q:134"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>) <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a> <a class="idref" href="Affine.html#t:133"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#Q:134"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 Likewise, the wp-style presentation of the rule <span class="inlinecode"><span class="id" title="var">triple_hgc_pre</span></span>
    takes the following form. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.wp_haffine_pre" class="idref" href="#NewTriples.wp_haffine_pre"><span class="id" title="lemma">wp_haffine_pre</span></a> : <span class="id" title="keyword">∀</span> <a id="t:135" class="idref" href="#t:135"><span class="id" title="binder">t</span></a> <a id="H:136" class="idref" href="#H:136"><span class="id" title="binder">H</span></a> <a id="Q:137" class="idref" href="#Q:137"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:136"><span class="id" title="variable">H</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a> <a class="idref" href="Affine.html#t:135"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#Q:137"><span class="id" title="variable">Q</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H:136"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a> <a class="idref" href="Affine.html#t:135"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#Q:137"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">K</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="Affine.html#NewTriples.wp_equiv"><span class="id" title="lemma">wp_equiv</span></a>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#NewTriples.triple_haffine_pre"><span class="id" title="axiom">triple_haffine_pre</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <span class="id" title="var">K</span>. } { <span class="id" title="tactic">rewrite</span>* &lt;- <a class="idref" href="Affine.html#NewTriples.wp_equiv"><span class="id" title="lemma">wp_equiv</span></a>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The revised presentation of the wp-style ramified frame rule includes
    an extra <span class="inlinecode">\<span class="id" title="var">GC</span></span> predicate. This rule captures at once all the structural
    properties of Separation Logic, including the discard rule. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.wp_ramified" class="idref" href="#NewTriples.wp_ramified"><span class="id" title="lemma">wp_ramified</span></a> : <span class="id" title="keyword">∀</span> <a id="Q<sub>1</sub>:138" class="idref" href="#Q<sub>1</sub>:138"><span class="id" title="binder">Q<sub>1</sub></span></a> <a id="Q<sub>2</sub>:139" class="idref" href="#Q<sub>2</sub>:139"><span class="id" title="binder">Q<sub>2</sub></span></a> <a id="t:140" class="idref" href="#t:140"><span class="id" title="binder">t</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a> <a class="idref" href="Affine.html#t:140"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#Q<sub>1</sub>:138"><span class="id" title="variable">Q<sub>1</sub></span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#Q<sub>1</sub>:138"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation"><span class='gray-font'>\</span><span class="nowrap">&minus;&minus;&lowast;</span></span></a> <a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#Q<sub>2</sub>:139"><span class="id" title="variable">Q<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a><a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation">)</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a> <a class="idref" href="Affine.html#t:140"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#Q<sub>2</sub>:139"><span class="id" title="variable">Q<sub>2</sub></span></a><a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
For a change, let us present below a direct proof for this lemma,
    that is, not reusing the structural rules associated with triples. 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#NewTriples.wp"><span class="id" title="definition">wp</span></a>. <span class="id" title="var">xpull</span> ;=&gt; <span class="id" title="var">H</span> <span class="id" title="var">M</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xsimpl</span> (<span class="id" title="var">H</span> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><span class="id" title="var">Q<sub>1</sub></span> <a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation"><span class='gray-font'>\</span><span class="nowrap">&minus;&minus;&lowast;</span></span></a> <span class="id" title="var">Q<sub>2</sub></span> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="var">unfolds</span> <a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#hoare_conseq"><span class="id" title="lemma">hoare_conseq</span></a> (<span class="id" title="var">M</span> (<a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><span class="id" title="var">Q<sub>1</sub></span> <a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation"><span class='gray-font'>\</span><span class="nowrap">&minus;&minus;&lowast;</span></span></a> <span class="id" title="var">Q<sub>2</sub></span> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <span class="id" title="var">H'</span>)).<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xsimpl</span>. } { <span class="id" title="var">xchange</span> <a class="idref" href="Affine.html#hstar_hgc_hgc"><span class="id" title="lemma">hstar_hgc_hgc</span></a>. <span class="id" title="var">xsimpl</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab383"></a><h2 class="section">Exploiting the Discard Rule in Proofs</h2>

<div class="paragraph"> </div>

 In a practical verification proof, there are two useful ways to
    discard heap predicates that are no longer needed:

<div class="paragraph"> </div>

<ul class="doclist">
<li> either by invoking <span class="inlinecode"><span class="id" title="var">triple_haffine_pre</span></span> to remove a specific
      predicate from the current state, i.e., the precondition;

</li>
<li> or by invoking <span class="inlinecode"><span class="id" title="var">triple_htop_post</span></span> to add a <span class="inlinecode">\<span class="id" title="var">GC</span></span> into the
      current postcondition and allow subsequent removal of any
      predicate that may be left-over in the final entailment
      justifying that the final state satisfies the postcondition.

</li>
</ul>

<div class="paragraph"> </div>

    Eager removal of predicates from the current state is never
    necessary: one can always be lazy and postpone the application
    of the discard rule until the last step of reasoning.

<div class="paragraph"> </div>

    In practical, it usually suffices to anticipate, right from the
    beginning of the verification proof, the possibility of discarding
    heap predicates from the final state.

<div class="paragraph"> </div>

    To that end, we apply the rule <span class="inlinecode"><span class="id" title="var">triple_htop_post</span></span> as very first
    step of the proof to extend the postcondition with a <span class="inlinecode">\<span class="id" title="var">GC</span></span> predicate,
    which will be used to absorb all the garbage left-over at the end
    of the proof.

<div class="paragraph"> </div>

    We implement this strategy in a systematic manner by integrating
    directly the rule <span class="inlinecode"><span class="id" title="var">triple_htop_post</span></span> into the tactic <span class="inlinecode"><span class="id" title="var">xwp</span></span>, which
    sets up the verification proof by computing the characteristic formula.
    To that end, we generalize the lemma <span class="inlinecode"><span class="id" title="var">xwp_lemma</span></span>, which the tactic
    <span class="inlinecode"><span class="id" title="var">xwp</span></span> applies. Its original statement is as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="NewTriples.xwp_lemma" class="idref" href="#NewTriples.xwp_lemma"><span class="id" title="axiom">xwp_lemma</span></a> : <span class="id" title="keyword">∀</span> <a id="v<sub>1</sub>:141" class="idref" href="#v<sub>1</sub>:141"><span class="id" title="binder">v<sub>1</sub></span></a> <a id="v<sub>2</sub>:142" class="idref" href="#v<sub>2</sub>:142"><span class="id" title="binder">v<sub>2</sub></span></a> <a id="x:143" class="idref" href="#x:143"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:144" class="idref" href="#t<sub>1</sub>:144"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="H:145" class="idref" href="#H:145"><span class="id" title="binder">H</span></a> <a id="Q:146" class="idref" href="#Q:146"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#v<sub>1</sub>:141"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_fun"><span class="id" title="constructor">val_fun</span></a> <a class="idref" href="Affine.html#x:143"><span class="id" title="variable">x</span></a> <a class="idref" href="Affine.html#t<sub>1</sub>:144"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:145"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#wpgen"><span class="id" title="definition">wpgen</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#x:143"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><a class="idref" href="Affine.html#v<sub>2</sub>:142"><span class="id" title="variable">v<sub>2</sub></span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><span class="id" title="notation">::</span><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a>) <a class="idref" href="Affine.html#t<sub>1</sub>:144"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="Affine.html#Q:146"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_app"><span class="id" title="constructor">trm_app</span></a> <a class="idref" href="Affine.html#v<sub>1</sub>:141"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Affine.html#v<sub>2</sub>:142"><span class="id" title="variable">v<sub>2</sub></span></a>) <a class="idref" href="Affine.html#H:145"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:146"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
Its generalized form extends the postcondition to which the formula
    computed by <span class="inlinecode"><span class="id" title="var">wpgen</span></span> is applied from <span class="inlinecode"><span class="id" title="var">Q</span></span> to <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*+</span> <span class="inlinecode">\<span class="id" title="var">GC</span></span>, as shown below. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.xwp_lemma'" class="idref" href="#NewTriples.xwp_lemma'"><span class="id" title="lemma">xwp_lemma'</span></a> : <span class="id" title="keyword">∀</span> <a id="v<sub>1</sub>:148" class="idref" href="#v<sub>1</sub>:148"><span class="id" title="binder">v<sub>1</sub></span></a> <a id="v<sub>2</sub>:149" class="idref" href="#v<sub>2</sub>:149"><span class="id" title="binder">v<sub>2</sub></span></a> <a id="x:150" class="idref" href="#x:150"><span class="id" title="binder">x</span></a> <a id="t<sub>1</sub>:151" class="idref" href="#t<sub>1</sub>:151"><span class="id" title="binder">t<sub>1</sub></span></a> <a id="H:152" class="idref" href="#H:152"><span class="id" title="binder">H</span></a> <a id="Q:153" class="idref" href="#Q:153"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#v<sub>1</sub>:148"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_fun"><span class="id" title="constructor">val_fun</span></a> <a class="idref" href="Affine.html#x:150"><span class="id" title="variable">x</span></a> <a class="idref" href="Affine.html#t<sub>1</sub>:151"><span class="id" title="variable">t<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:152"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#wpgen"><span class="id" title="definition">wpgen</span></a> (<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#x:150"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><a class="idref" href="Affine.html#v<sub>2</sub>:149"><span class="id" title="variable">v<sub>2</sub></span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><span class="id" title="notation">::</span><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a>) <a class="idref" href="Affine.html#t<sub>1</sub>:151"><span class="id" title="variable">t<sub>1</sub></span></a> (<a class="idref" href="Affine.html#Q:153"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#trm_app"><span class="id" title="constructor">trm_app</span></a> <a class="idref" href="Affine.html#v<sub>1</sub>:148"><span class="id" title="variable">v<sub>1</sub></span></a> <a class="idref" href="Affine.html#v<sub>2</sub>:149"><span class="id" title="variable">v<sub>2</sub></span></a>) <a class="idref" href="Affine.html#H:152"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:153"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">E</span> <span class="id" title="var">M</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#NewTriples.triple_hgc_post"><span class="id" title="axiom">triple_hgc_post</span></a>. <span class="id" title="var">applys</span>* <a class="idref" href="Affine.html#NewTriples.xwp_lemma"><span class="id" title="axiom">xwp_lemma</span></a>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Let us update the tactic <span class="inlinecode"><span class="id" title="var">xwp</span></span> to exploit the lemma <span class="inlinecode"><span class="id" title="var">xwp_lemma'</span></span>
    instead of <span class="inlinecode"><span class="id" title="var">xwp_lemma</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Tactic Notation</span> "xwp" :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#NewTriples.xwp_lemma'"><span class="id" title="lemma">xwp_lemma'</span></a>;<br/>
&nbsp;&nbsp;[ <span class="id" title="tactic">reflexivity</span> | <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">unfold</span> <a class="idref" href="LibSepReference.html#wpgen_var"><span class="id" title="definition">wpgen_var</span></a>; <span class="id" title="tactic">simpl</span> ].<br/>
</div>

<div class="doc">
<a id="lab384"></a><h2 class="section">Example Proof Involving Discarded Heap Predicates</h2>

<div class="paragraph"> </div>

 Using the updated version of <span class="inlinecode"><span class="id" title="var">xwp</span></span>, let us revisite the proof of our
    motivating example <span class="inlinecode"><span class="id" title="var">succ_using_incr</span></span> in a fully affine logic, i.e.,
    a logical where any predicate can be discarded. 
</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="NewTriples.MotivatingExampleWithUpdatedXwp" class="idref" href="#NewTriples.MotivatingExampleWithUpdatedXwp"><span class="id" title="module">MotivatingExampleWithUpdatedXwp</span></a>.<br/>
<span class="id" title="keyword">Export</span> <span class="id" title="var">MotivatingExample</span>.<br/>
</div>

<div class="doc">
Assume a fully affine logic. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="NewTriples.MotivatingExampleWithUpdatedXwp.haffine_hany" class="idref" href="#NewTriples.MotivatingExampleWithUpdatedXwp.haffine_hany"><span class="id" title="axiom">haffine_hany</span></a> : <span class="id" title="keyword">∀</span> (<a id="H:154" class="idref" href="#H:154"><span class="id" title="binder">H</span></a>:<a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:154"><span class="id" title="variable">H</span></a>.<br/>
</div>

<div class="doc">
Observe in the proof below the <span class="inlinecode">\<span class="id" title="var">GC</span></span> introduced in the postcondition
    by the call to <span class="inlinecode"><span class="id" title="var">xwp</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.MotivatingExampleWithUpdatedXwp.triple_succ_using_incr" class="idref" href="#NewTriples.MotivatingExampleWithUpdatedXwp.triple_succ_using_incr"><span class="id" title="lemma">triple_succ_using_incr</span></a> : <span class="id" title="keyword">∀</span> (<a id="n:156" class="idref" href="#n:156"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Affine.html#MotivatingExample.succ_using_incr"><span class="id" title="definition">succ_using_incr</span></a> <a class="idref" href="Affine.html#n:156"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:157" class="idref" href="#r:157"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Affine.html#r:157"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Affine.html#n:156"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">r</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>. { <span class="id" title="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;There&nbsp;remains&nbsp;to&nbsp;absorb&nbsp;the&nbsp;left-over&nbsp;reference&nbsp;into&nbsp;the&nbsp;<span class="inlinecode">\<span class="id" title="var">GC</span></span>&nbsp;predicate&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="Affine.html#himpl_hgc_r"><span class="id" title="lemma">himpl_hgc_r</span></a>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#NewTriples.MotivatingExampleWithUpdatedXwp.haffine_hany"><span class="id" title="axiom">haffine_hany</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
We will show further on how to automate the work from the last line
    of the proof above, by setting up <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> to automatically resolve
    goals of the form <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode">\<span class="id" title="var">GC</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#NewTriples.MotivatingExampleWithUpdatedXwp"><span class="id" title="module">MotivatingExampleWithUpdatedXwp</span></a>.<br/>
</div>

<div class="doc">
<a id="lab385"></a><h1 class="section">More Details</h1>

</div>

<div class="doc">
<a id="lab386"></a><h2 class="section">Revised Definition of <span class="inlinecode"><span class="id" title="var">mkstruct</span></span></h2>

<div class="paragraph"> </div>

 Recall the definition <span class="inlinecode"><span class="id" title="var">mkstruct</span></span>, as stated in the file <span class="inlinecode"><span class="id" title="var">Wand</span></span>.
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">mkstruct</span> (<span class="id" title="var">F</span>:<span class="id" title="var">formula</span>) : <span class="id" title="var">formula</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">Q</span> ⇒ <span class='gray-font'>\</span><span class="id" title="tactic">∃</span> <span class="id" title="var">Q'</span>, (<span class="id" title="var">F</span> <span class="id" title="var">Q'</span>) <span class='gray-font'>\</span>* (<span class="id" title="var">Q'</span> <span class='gray-font'>\</span><span class="nowrap">&minus;&minus;&lowast;</span> <span class="id" title="var">Q</span>).
</span>    This definition can be generalized to handle not just the consequence
    and the frame rule, but also the discard rule.

<div class="paragraph"> </div>

    To that end, we augment <span class="inlinecode"><span class="id" title="var">mkstruct</span></span> with an additional <span class="inlinecode">\<span class="id" title="var">GC</span></span>, as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="NewTriples.mkstruct" class="idref" href="#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> (<a id="F:158" class="idref" href="#F:158"><span class="id" title="binder">F</span></a>:<a class="idref" href="LibSepReference.html#formula"><span class="id" title="definition">formula</span></a>) : <a class="idref" href="LibSepReference.html#formula"><span class="id" title="definition">formula</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <a id="Q:159" class="idref" href="#Q:159"><span class="id" title="binder">Q</span></a> ⇒ <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="Q':160" class="idref" href="#Q':160"><span class="id" title="binder">Q'</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="Affine.html#F:158"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q':160"><span class="id" title="variable">Q'</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#Q':160"><span class="id" title="variable">Q'</span></a> <a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation"><span class='gray-font'>\</span><span class="nowrap">&minus;&minus;&lowast;</span></span></a> <a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#Q:159"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a><a class="idref" href="LibSepReference.html#5609a52f091556b9923d5758aa61f543"><span class="id" title="notation">)</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
Let us prove that this revised definition of <span class="inlinecode"><span class="id" title="var">mkstruct</span></span> does sastisfy
    the <span class="inlinecode"><span class="id" title="var">wp</span></span>-style statement of the discard rule, which is stated
    in a way similar to <span class="inlinecode"><span class="id" title="var">wp_hgc_post</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.mkstruct_hgc" class="idref" href="#NewTriples.mkstruct_hgc"><span class="id" title="lemma">mkstruct_hgc</span></a> : <span class="id" title="keyword">∀</span> <a id="Q:161" class="idref" href="#Q:161"><span class="id" title="binder">Q</span></a> <a id="F:162" class="idref" href="#F:162"><span class="id" title="binder">F</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:162"><span class="id" title="variable">F</span></a> (<a class="idref" href="Affine.html#Q:161"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>) <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:162"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:161"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a>. <span class="id" title="tactic">set</span> (<span class="id" title="var">X</span> := <a class="idref" href="Affine.html#hgc"><span class="id" title="definition">hgc</span></a>) <span class="id" title="tactic">at</span> 3. <span class="id" title="tactic">replace</span> <span class="id" title="var">X</span> <span class="id" title="keyword">with</span> (<a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>).<br/>
&nbsp;&nbsp;{ <span class="id" title="var">xsimpl</span>. } { <span class="id" title="tactic">subst</span> <span class="id" title="var">X</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#hstar_hgc_hgc"><span class="id" title="lemma">hstar_hgc_hgc</span></a>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Besides, let us prove that the revised definition of <span class="inlinecode"><span class="id" title="var">mkstruct</span></span> still
    satisfies the three originally required properties: erasure, consequence,
    and frame.

<div class="paragraph"> </div>

    Remark: the proofs shown below exploit a version of <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> that handles
    the magic wand but provides no built-in support for the <span class="inlinecode">\<span class="id" title="var">GC</span></span> predicate. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.mkstruct_erase" class="idref" href="#NewTriples.mkstruct_erase"><span class="id" title="lemma">mkstruct_erase</span></a> : <span class="id" title="keyword">∀</span> <a id="F:163" class="idref" href="#F:163"><span class="id" title="binder">F</span></a> <a id="Q:164" class="idref" href="#Q:164"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#F:163"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:164"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:163"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:164"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a>. <span class="id" title="var">xsimpl</span> <span class="id" title="var">Q</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#himpl_hgc_r"><span class="id" title="lemma">himpl_hgc_r</span></a>. <span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#haffine_hempty"><span class="id" title="lemma">haffine_hempty</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="NewTriples.mkstruct_conseq" class="idref" href="#NewTriples.mkstruct_conseq"><span class="id" title="lemma">mkstruct_conseq</span></a> : <span class="id" title="keyword">∀</span> <a id="F:165" class="idref" href="#F:165"><span class="id" title="binder">F</span></a> <a id="Q<sub>1</sub>:166" class="idref" href="#Q<sub>1</sub>:166"><span class="id" title="binder">Q<sub>1</sub></span></a> <a id="Q<sub>2</sub>:167" class="idref" href="#Q<sub>2</sub>:167"><span class="id" title="binder">Q<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#Q<sub>1</sub>:166"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#9351a4f098e275023c32e0091e608189"><span class="id" title="notation">===&gt;</span></a> <a class="idref" href="Affine.html#Q<sub>2</sub>:167"><span class="id" title="variable">Q<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:165"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q<sub>1</sub>:166"><span class="id" title="variable">Q<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:165"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q<sub>2</sub>:167"><span class="id" title="variable">Q<sub>2</sub></span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">WQ</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a>. <span class="id" title="var">xpull</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">Q'</span>. <span class="id" title="var">xsimpl</span> <span class="id" title="var">Q'</span>. <span class="id" title="var">xchange</span> <span class="id" title="var">WQ</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="NewTriples.mkstruct_frame" class="idref" href="#NewTriples.mkstruct_frame"><span class="id" title="lemma">mkstruct_frame</span></a> : <span class="id" title="keyword">∀</span> <a id="F:168" class="idref" href="#F:168"><span class="id" title="binder">F</span></a> <a id="H:169" class="idref" href="#H:169"><span class="id" title="binder">H</span></a> <a id="Q:170" class="idref" href="#Q:170"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:168"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:170"><span class="id" title="variable">Q</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H:169"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:168"><span class="id" title="variable">F</span></a> (<a class="idref" href="Affine.html#Q:170"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H:169"><span class="id" title="variable">H</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a>. <span class="id" title="var">xpull</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">Q'</span>. <span class="id" title="var">xsimpl</span> <span class="id" title="var">Q'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab387"></a><h4 class="section">Exercise: 2 stars, standard, optional (mkstruct_haffine_post)</h4>
 Prove the reformulation of <span class="inlinecode"><span class="id" title="var">triple_haffine_post</span></span> adapted to <span class="inlinecode"><span class="id" title="var">mkstruct</span></span>,
    for discarding an affine piece of postcondition.
    Hint: <span class="inlinecode"><span class="id" title="var">haffine</span></span> is an opaque definition at this stage; the assumption
    <span class="inlinecode"><span class="id" title="var">haffine</span></span> needs to be exploited using the lemma <span class="inlinecode"><span class="id" title="var">himpl_hgc_r</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.mkstruct_haffine_post" class="idref" href="#NewTriples.mkstruct_haffine_post"><span class="id" title="lemma">mkstruct_haffine_post</span></a> : <span class="id" title="keyword">∀</span> <a id="H:171" class="idref" href="#H:171"><span class="id" title="binder">H</span></a> <a id="Q:172" class="idref" href="#Q:172"><span class="id" title="binder">Q</span></a> <a id="F:173" class="idref" href="#F:173"><span class="id" title="binder">F</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:171"><span class="id" title="variable">H</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:173"><span class="id" title="variable">F</span></a> (<a class="idref" href="Affine.html#Q:172"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H:171"><span class="id" title="variable">H</span></a>) <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:173"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:172"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab388"></a><h4 class="section">Exercise: 2 stars, standard, optional (mkstruct_haffine_pre)</h4>
 Prove the reformulation of <span class="inlinecode"><span class="id" title="var">triple_haffine_pre</span></span> adapted to <span class="inlinecode"><span class="id" title="var">mkstruct</span></span>,
    for discarding an affine piece of postcondition. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="NewTriples.mkstruct_haffine_pre" class="idref" href="#NewTriples.mkstruct_haffine_pre"><span class="id" title="lemma">mkstruct_haffine_pre</span></a> : <span class="id" title="keyword">∀</span> <a id="H:174" class="idref" href="#H:174"><span class="id" title="binder">H</span></a> <a id="Q:175" class="idref" href="#Q:175"><span class="id" title="binder">Q</span></a> <a id="F:176" class="idref" href="#F:176"><span class="id" title="binder">F</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H:174"><span class="id" title="variable">H</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:176"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:175"><span class="id" title="variable">Q</span></a><a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H:174"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#NewTriples.mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:176"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:175"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="code">

<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#NewTriples"><span class="id" title="module">NewTriples</span></a>.<br/>
</div>

<div class="doc">
<a id="lab389"></a><h2 class="section">The Tactic <span class="inlinecode"><span class="id" title="var">xaffine</span></span>, and Behavior of <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> on <span class="inlinecode">\<span class="id" title="var">GC</span></span></h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="Xaffine" class="idref" href="#Xaffine"><span class="id" title="module">Xaffine</span></a>.<br/>
</div>

<div class="doc">
The tactic <span class="inlinecode"><span class="id" title="var">xaffine</span></span> applys to a goal of the form <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>.
    The tactic simplifies the goal using all the distributivity rules
    associated with <span class="inlinecode"><span class="id" title="var">haffine</span></span>. Ultimately, it invokes <span class="inlinecode"><span class="id" title="tactic">eauto</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><span class="id" title="var">haffine</span></span>,
    which can leverage knowledge specific to the definition of <span class="inlinecode"><span class="id" title="var">haffine</span></span>
    from the Separation Logic set up at hand. 
</div>
<div class="code">

<span class="id" title="var">Create</span> <span class="id" title="var">HintDb</span> <span class="id" title="var">haffine</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Tactic Notation</span> "xaffine" :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span> &#x22A2; <a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> ?<span class="id" title="var">H</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">H</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="LibSepReference.html#SepSimplArgs.hempty"><span class="id" title="definition">hempty</span></a>) ⇒ <span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#haffine_hempty"><span class="id" title="lemma">haffine_hempty</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="LibSepReference.html#SepSimplArgs.hpure"><span class="id" title="definition">hpure</span></a> <span class="id" title="var">_</span>) ⇒ <span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#haffine_hpure"><span class="id" title="lemma">haffine_hpure</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="LibSepReference.html#SepSimplArgs.hstar"><span class="id" title="definition">hstar</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) ⇒ <span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#haffine_hstar"><span class="id" title="lemma">haffine_hstar</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="LibSepReference.html#SepSimplArgs.hexists"><span class="id" title="definition">hexists</span></a> <span class="id" title="var">_</span>) ⇒ <span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#haffine_hexists"><span class="id" title="lemma">haffine_hexists</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="LibSepReference.html#SepSimplArgs.hforall"><span class="id" title="definition">hforall</span></a> <span class="id" title="var">_</span>) ⇒ <span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#haffine_hforall"><span class="id" title="lemma">haffine_hforall</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<a class="idref" href="Affine.html#hgc"><span class="id" title="definition">hgc</span></a>) ⇒ <span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#haffine_hgc"><span class="id" title="lemma">haffine_hgc</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">eauto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">haffine</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="Xaffine.xaffine_demo" class="idref" href="#Xaffine.xaffine_demo"><span class="id" title="lemma">xaffine_demo</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:177" class="idref" href="#H<sub>1</sub>:177"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:178" class="idref" href="#H<sub>2</sub>:178"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="H<sub>3</sub>:179" class="idref" href="#H<sub>3</sub>:179"><span class="id" title="binder">H<sub>3</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:177"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>3</sub>:179"><span class="id" title="variable">H<sub>3</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="Affine.html#H<sub>1</sub>:177"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:178"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>3</sub>:179"><span class="id" title="variable">H<sub>3</sub></span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">K<sub>1</sub></span> <span class="id" title="var">KJ</span>. <span class="id" title="var">xaffine</span>. <span class="comment">(*&nbsp;remains&nbsp;<span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span>&nbsp;*)</span> <span class="id" title="keyword">Abort</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#Xaffine"><span class="id" title="module">Xaffine</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Module</span> <a id="XsimplExtended" class="idref" href="#XsimplExtended"><span class="id" title="module">XsimplExtended</span></a>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">LibSepReference</span>.<br/>
</div>

<div class="doc">
The tactic <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> is extended with support for simplifying goals
    of the form <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode">\<span class="id" title="var">GC</span></span> into <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>, using lemma <span class="inlinecode"><span class="id" title="var">himpl_hgc_r</span></span>.
    For example, <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> can simplify the goal <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode">\<span class="id" title="var">GC</span></span>
    into just <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="XsimplExtended.xsimpl_xgc_demo" class="idref" href="#XsimplExtended.xsimpl_xgc_demo"><span class="id" title="lemma">xsimpl_xgc_demo</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:180" class="idref" href="#H<sub>1</sub>:180"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:181" class="idref" href="#H<sub>2</sub>:181"><span class="id" title="binder">H<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H<sub>1</sub>:180"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:181"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:181"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">GC</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="var">xsimpl</span>. <span class="comment">(*&nbsp;remains&nbsp;<span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span>&nbsp;*)</span> <span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
In addition, <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> invokes the tactic <span class="inlinecode"><span class="id" title="var">xaffine</span></span> to simplify
    side-conditions of the form <span class="inlinecode"><span class="id" title="var">haffine</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>. For example, <span class="inlinecode"><span class="id" title="var">xsimpl</span></span>
    can prove the following lemma. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="XsimplExtended.xsimpl_xaffine_demo" class="idref" href="#XsimplExtended.xsimpl_xaffine_demo"><span class="id" title="lemma">xsimpl_xaffine_demo</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:182" class="idref" href="#H<sub>1</sub>:182"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:183" class="idref" href="#H<sub>2</sub>:183"><span class="id" title="binder">H<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#SepSimplArgs.haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:182"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H<sub>1</sub>:182"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:183"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:183"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">GC</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">K<sub>1</sub></span>. <span class="id" title="var">xsimpl</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#XsimplExtended"><span class="id" title="module">XsimplExtended</span></a>.<br/>
</div>

<div class="doc">
<a id="lab390"></a><h2 class="section">The Proof Tactics for Applying the Discard Rules</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="XGC" class="idref" href="#XGC"><span class="id" title="module">XGC</span></a>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">LibSepReference</span>.<br/>
</div>

<div class="doc">
To present the discard tactics <span class="inlinecode"><span class="id" title="var">xgc</span></span>, <span class="inlinecode"><span class="id" title="var">xc_keep</span></span> and <span class="inlinecode"><span class="id" title="var">xgc_post</span></span>,
    we import the definitions from <span class="inlinecode"><span class="id" title="var">LibSepDirect</span></span> but assume that the
    definition of <span class="inlinecode"><span class="id" title="var">mkstruct</span></span> is like the one presented in the present
    file, that is, including the <span class="inlinecode">\<span class="id" title="var">GC</span></span> when defining <span class="inlinecode"><span class="id" title="var">mkstruct</span></span> <span class="inlinecode"><span class="id" title="var">F</span></span>
    as <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">Q'</span>,</span> <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode"><span class="id" title="var">Q'</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode">(<span class="id" title="var">Q'</span></span> <span class="inlinecode"><span class='gray-font'>\</span><span class="nowrap">&minus;&minus;&lowast;</span></span> <span class="inlinecode">(<span class="id" title="var">Q</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*+</span> <span class="inlinecode">\<span class="id" title="var">GC</span>))</span>.

<div class="paragraph"> </div>

    As argued earlier on, with this definition, <span class="inlinecode"><span class="id" title="var">mkstruct</span></span> satisfies the
    following discard rule. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="XGC.mkstruct_hgc" class="idref" href="#XGC.mkstruct_hgc"><span class="id" title="axiom">mkstruct_hgc</span></a> : <span class="id" title="keyword">∀</span> <a id="Q:184" class="idref" href="#Q:184"><span class="id" title="binder">Q</span></a> <a id="F:185" class="idref" href="#F:185"><span class="id" title="binder">F</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:185"><span class="id" title="variable">F</span></a> (<a class="idref" href="Affine.html#Q:184"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">GC</span></a>) <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:185"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:184"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
The tactic <span class="inlinecode"><span class="id" title="var">xgc</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> removes <span class="inlinecode"><span class="id" title="var">H</span></span> from the precondition (i.e. from the
    current state), in the course of a proof exploiting a formula produced
    by <span class="inlinecode"><span class="id" title="var">wpgen</span></span>.

<div class="paragraph"> </div>

    More precisely, the tactic invokes the following variant of the rule
    <span class="inlinecode"><span class="id" title="var">triple_haffine_pre</span></span>, which allows to leverage <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> for computing
    the heap predicate <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> that remains after a predicate <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> is removed
    from a precondition <span class="inlinecode"><span class="id" title="var">H</span></span>, through the entailment <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="XGC.xgc_lemma" class="idref" href="#XGC.xgc_lemma"><span class="id" title="lemma">xgc_lemma</span></a>: <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:187" class="idref" href="#H<sub>1</sub>:187"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:188" class="idref" href="#H<sub>2</sub>:188"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="H:189" class="idref" href="#H:189"><span class="id" title="binder">H</span></a> <a id="F:190" class="idref" href="#F:190"><span class="id" title="binder">F</span></a> <a id="Q:191" class="idref" href="#Q:191"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:189"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:187"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:188"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#SepSimplArgs.haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:187"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H<sub>2</sub>:188"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:190"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:191"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:189"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:190"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:191"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">WH</span> <span class="id" title="var">K</span> <span class="id" title="var">M</span>. <span class="id" title="var">xchange</span> <span class="id" title="var">WH</span>. <span class="id" title="var">xchange</span> <span class="id" title="var">M</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.himpl_trans"><span class="id" title="lemma">himpl_trans</span></a> <a class="idref" href="LibSepReference.html#mkstruct_frame"><span class="id" title="lemma">mkstruct_frame</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.himpl_trans"><span class="id" title="lemma">himpl_trans</span></a> <a class="idref" href="Affine.html#XGC.mkstruct_hgc"><span class="id" title="axiom">mkstruct_hgc</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#mkstruct_conseq"><span class="id" title="lemma">mkstruct_conseq</span></a>. <span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Tactic Notation</span> "xgc" <span class="id" title="keyword">constr</span>(<span class="id" title="var">H</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> (@<a class="idref" href="Affine.html#XGC.xgc_lemma"><span class="id" title="lemma">xgc_lemma</span></a> <span class="id" title="var">H</span>); [ <span class="id" title="var">xsimpl</span> | <span class="id" title="var">xaffine</span> | ].<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="XGC.xgc_demo" class="idref" href="#XGC.xgc_demo"><span class="id" title="lemma">xgc_demo</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:192" class="idref" href="#H<sub>1</sub>:192"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:193" class="idref" href="#H<sub>2</sub>:193"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="H<sub>3</sub>:194" class="idref" href="#H<sub>3</sub>:194"><span class="id" title="binder">H<sub>3</sub></span></a> <a id="F:195" class="idref" href="#F:195"><span class="id" title="binder">F</span></a> <a id="Q:196" class="idref" href="#Q:196"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#SepSimplArgs.haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:193"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#H<sub>1</sub>:192"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:193"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>3</sub>:194"><span class="id" title="variable">H<sub>3</sub></span></a><a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:195"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:196"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">K<sub>2</sub></span>. <span class="id" title="var">xgc</span> <span class="id" title="var">H<sub>2</sub></span>. <span class="comment">(*&nbsp;clears&nbsp;<span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span>&nbsp;*)</span> <span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
The tactic <span class="inlinecode"><span class="id" title="var">xgc_keep</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> is a variant of <span class="inlinecode"><span class="id" title="var">xgc</span></span> that enables to discard
    everything but <span class="inlinecode"><span class="id" title="var">H</span></span> from the precondition.

<div class="paragraph"> </div>

    The implementation of the tactic leverages the same lemma <span class="inlinecode"><span class="id" title="var">xgc_lemma</span></span>,
    only providing <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> instead of <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Tactic Notation</span> "xgc_keep" <span class="id" title="keyword">constr</span>(<span class="id" title="var">H</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> (@<a class="idref" href="Affine.html#XGC.xgc_lemma"><span class="id" title="lemma">xgc_lemma</span></a> <span class="id" title="var">_</span> <span class="id" title="var">H</span>); [ <span class="id" title="var">xsimpl</span> | <span class="id" title="var">xaffine</span> | ].<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="XGC.xgc_keep_demo" class="idref" href="#XGC.xgc_keep_demo"><span class="id" title="lemma">xgc_keep_demo</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:197" class="idref" href="#H<sub>1</sub>:197"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:198" class="idref" href="#H<sub>2</sub>:198"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="H<sub>3</sub>:199" class="idref" href="#H<sub>3</sub>:199"><span class="id" title="binder">H<sub>3</sub></span></a> <a id="F:200" class="idref" href="#F:200"><span class="id" title="binder">F</span></a> <a id="Q:201" class="idref" href="#Q:201"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#SepSimplArgs.haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:197"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#SepSimplArgs.haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>3</sub>:199"><span class="id" title="variable">H<sub>3</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">(</span></a><a class="idref" href="Affine.html#H<sub>1</sub>:197"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:198"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H<sub>3</sub>:199"><span class="id" title="variable">H<sub>3</sub></span></a><a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:200"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:201"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">K<sub>1</sub></span> <span class="id" title="var">K<sub>3</sub></span>. <span class="id" title="var">xgc_keep</span> <span class="id" title="var">H<sub>2</sub></span>. <span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
The tactic <span class="inlinecode"><span class="id" title="var">xgc_post</span></span> simply extends the postcondition with a <span class="inlinecode">\<span class="id" title="var">GC</span></span>,
    to enable subsequent discarding of heap predicates in the final
    entailment. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="XGC.xgc_post_lemma" class="idref" href="#XGC.xgc_post_lemma"><span class="id" title="lemma">xgc_post_lemma</span></a> : <span class="id" title="keyword">∀</span> <a id="H:202" class="idref" href="#H:202"><span class="id" title="binder">H</span></a> <a id="Q:203" class="idref" href="#Q:203"><span class="id" title="binder">Q</span></a> <a id="F:204" class="idref" href="#F:204"><span class="id" title="binder">F</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:202"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:204"><span class="id" title="variable">F</span></a> (<a class="idref" href="Affine.html#Q:203"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">GC</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:202"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:204"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:203"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="var">xchange</span> <span class="id" title="var">M</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#XGC.mkstruct_hgc"><span class="id" title="axiom">mkstruct_hgc</span></a>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Tactic Notation</span> "xgc_post" :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Affine.html#XGC.xgc_post_lemma"><span class="id" title="lemma">xgc_post_lemma</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="XGC.xgc_keep_demo" class="idref" href="#XGC.xgc_keep_demo"><span class="id" title="lemma">xgc_keep_demo</span></a> : <span class="id" title="keyword">∀</span> <a id="H<sub>1</sub>:205" class="idref" href="#H<sub>1</sub>:205"><span class="id" title="binder">H<sub>1</sub></span></a> <a id="H<sub>2</sub>:206" class="idref" href="#H<sub>2</sub>:206"><span class="id" title="binder">H<sub>2</sub></span></a> <a id="H<sub>3</sub>:207" class="idref" href="#H<sub>3</sub>:207"><span class="id" title="binder">H<sub>3</sub></span></a> <a id="F:208" class="idref" href="#F:208"><span class="id" title="binder">F</span></a> <a id="Q:209" class="idref" href="#Q:209"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#SepSimplArgs.haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>1</sub>:205"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#SepSimplArgs.haffine"><span class="id" title="definition">haffine</span></a> <a class="idref" href="Affine.html#H<sub>3</sub>:207"><span class="id" title="variable">H<sub>3</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H<sub>1</sub>:205"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:208"><span class="id" title="variable">F</span></a> (<a class="idref" href="Affine.html#Q:209"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H<sub>2</sub>:206"><span class="id" title="variable">H<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H<sub>3</sub>:207"><span class="id" title="variable">H<sub>3</sub></span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H<sub>1</sub>:205"><span class="id" title="variable">H<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#c7ebd77e939e3f02c508e57b470dc021"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="LibSepReference.html#mkstruct"><span class="id" title="definition">mkstruct</span></a> <a class="idref" href="Affine.html#F:208"><span class="id" title="variable">F</span></a> <a class="idref" href="Affine.html#Q:209"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">K<sub>1</sub></span> <span class="id" title="var">K<sub>3</sub></span> <span class="id" title="var">M</span>. <span class="id" title="var">xgc_post</span>. <span class="id" title="var">xchange</span> <span class="id" title="var">M</span>. <span class="id" title="var">applys</span> <a class="idref" href="LibSepReference.html#mkstruct_conseq"><span class="id" title="lemma">mkstruct_conseq</span></a>. <span class="id" title="var">xsimpl</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Check&nbsp;out&nbsp;how&nbsp;the&nbsp;end&nbsp;proof&nbsp;fails&nbsp;without&nbsp;the&nbsp;call&nbsp;to&nbsp;<span class="inlinecode"><span class="id" title="var">xgc_post</span></span>.&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#XGC"><span class="id" title="module">XGC</span></a>.<br/>
</div>

<div class="doc">
<a id="lab391"></a><h1 class="section">Optional Material</h1>

</div>

<div class="doc">
<a id="lab392"></a><h2 class="section">Alternative Statement for Distribution of <span class="inlinecode"><span class="id" title="var">haffine</span></span> on Quantifiers</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="HaffineQuantifiers" class="idref" href="#HaffineQuantifiers"><span class="id" title="module">HaffineQuantifiers</span></a>.<br/>
</div>

<div class="doc">
Recall the lemmas <span class="inlinecode"><span class="id" title="var">haffine_hexists</span></span> and <span class="inlinecode"><span class="id" title="var">haffine_hforall</span></span>.
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">haffine_hexists</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> (<span class="id" title="var">J</span>:<span class="id" title="var">A</span>→<span class="id" title="var">hprop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">haffine</span> (<span class="id" title="var">J</span> <span class="id" title="var">x</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">haffine</span> (<span class='gray-font'>\</span><span class="id" title="tactic">∃</span> <span class="id" title="var">x</span>, (<span class="id" title="var">J</span> <span class="id" title="var">x</span>)).<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">haffine_hforall</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> `{<span class="id" title="var">Inhab</span> <span class="id" title="var">A</span>} (<span class="id" title="var">J</span>:<span class="id" title="var">A</span>→<span class="id" title="var">hprop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">haffine</span> (<span class="id" title="var">J</span> <span class="id" title="var">x</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">haffine</span> (\<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, (<span class="id" title="var">J</span> <span class="id" title="var">x</span>)).
</span>    They can be reformulated in a more concise way, as explained next. 
<div class="paragraph"> </div>

 First, to smoothly handle the distribution on the quantifiers, let us
    extend the notion of "affinity" to postconditions. The predicate
    <span class="inlinecode"><span class="id" title="var">haffine_post</span></span> <span class="inlinecode"><span class="id" title="var">J</span></span> asserts that <span class="inlinecode"><span class="id" title="var">haffine</span></span> holds of <span class="inlinecode"><span class="id" title="var">J</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> for any <span class="inlinecode"><span class="id" title="var">x</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="HaffineQuantifiers.haffine_post" class="idref" href="#HaffineQuantifiers.haffine_post"><span class="id" title="definition">haffine_post</span></a> (<a id="A:210" class="idref" href="#A:210"><span class="id" title="binder">A</span></a>:<span class="id" title="keyword">Type</span>) (<a id="J:211" class="idref" href="#J:211"><span class="id" title="binder">J</span></a>:<a class="idref" href="Affine.html#A:210"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a id="x:212" class="idref" href="#x:212"><span class="id" title="binder">x</span></a>, <a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="Affine.html#J:211"><span class="id" title="variable">J</span></a> <a class="idref" href="Affine.html#x:212"><span class="id" title="variable">x</span></a>).<br/>
</div>

<div class="doc">
The rules then reformulate as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="HaffineQuantifiers.haffine_hexists" class="idref" href="#HaffineQuantifiers.haffine_hexists"><span class="id" title="lemma">haffine_hexists</span></a> : <span class="id" title="keyword">∀</span> <a id="A:213" class="idref" href="#A:213"><span class="id" title="binder">A</span></a> (<a id="J:214" class="idref" href="#J:214"><span class="id" title="binder">J</span></a>:<a class="idref" href="Affine.html#A:213"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#HaffineQuantifiers.haffine_post"><span class="id" title="definition">haffine_post</span></a> <a class="idref" href="Affine.html#J:214"><span class="id" title="variable">J</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="LibSepReference.html#SepSimplArgs.hexists"><span class="id" title="definition">hexists</span></a> <a class="idref" href="Affine.html#J:214"><span class="id" title="variable">J</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">F<sub>1</sub></span> (<span class="id" title="var">x</span>&amp;<span class="id" title="var">Hx</span>). <span class="id" title="var">applys</span>* <span class="id" title="var">F<sub>1</sub></span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="HaffineQuantifiers.haffine_hforall" class="idref" href="#HaffineQuantifiers.haffine_hforall"><span class="id" title="lemma">haffine_hforall</span></a> : <span class="id" title="keyword">∀</span> <a id="A:215" class="idref" href="#A:215"><span class="id" title="binder">A</span></a> `{<a id="H:216" class="idref" href="#H:216"><span class="id" title="binder">Inhab</span></a> <a id="H:216" class="idref" href="#H:216"><span class="id" title="binder">A</span></a>} (<a id="J:217" class="idref" href="#J:217"><span class="id" title="binder">J</span></a>:<a class="idref" href="Affine.html#A:215"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#HaffineQuantifiers.haffine_post"><span class="id" title="definition">haffine_post</span></a> <a class="idref" href="Affine.html#J:217"><span class="id" title="variable">J</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#haffine"><span class="id" title="definition">haffine</span></a> (<a class="idref" href="LibSepReference.html#SepSimplArgs.hforall"><span class="id" title="definition">hforall</span></a> <a class="idref" href="Affine.html#J:217"><span class="id" title="variable">J</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">IA</span> <span class="id" title="var">F<sub>1</sub></span> <span class="id" title="var">Hx</span>. <span class="id" title="var">lets</span> <span class="id" title="var">N</span>: <a class="idref" href="LibSepReference.html#SepSimplArgs.hforall_inv"><span class="id" title="lemma">hforall_inv</span></a> <span class="id" title="var">Hx</span>. <span class="id" title="var">applys</span>* <span class="id" title="var">F<sub>1</sub></span> (<span class="id" title="definition">arbitrary</span> (<span class="id" title="var">A</span>:=<span class="id" title="var">A</span>)).<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#HaffineQuantifiers"><span class="id" title="module">HaffineQuantifiers</span></a>.<br/>
</div>

<div class="doc">
<a id="lab393"></a><h2 class="section">Pre and Post Rules</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="FromPreToPostGC" class="idref" href="#FromPreToPostGC"><span class="id" title="module">FromPreToPostGC</span></a>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">Rules</span> <span class="id" title="var">ProofsSameSemantics</span>.<br/>
</div>

<div class="doc">
Earlier on, we proved that <span class="inlinecode"><span class="id" title="var">triple_hgc_pre</span></span> is derivable from
    <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span>, through a simple application of the frame rule.

<div class="paragraph"> </div>

    We wrote that, reciprocally, the rule <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span> is derivable
    from <span class="inlinecode"><span class="id" title="var">triple_hgc_pre</span></span>, yet with a slightly more involved proof.
    Let us present this proof.

<div class="paragraph"> </div>

    In other word, assume <span class="inlinecode"><span class="id" title="var">triple_hgc_pre</span></span>, and let us prove the
    result <span class="inlinecode"><span class="id" title="var">triple_hgc_post</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="FromPreToPostGC.triple_hgc_pre" class="idref" href="#FromPreToPostGC.triple_hgc_pre"><span class="id" title="axiom">triple_hgc_pre</span></a> : <span class="id" title="keyword">∀</span> <a id="t:218" class="idref" href="#t:218"><span class="id" title="binder">t</span></a> <a id="H:219" class="idref" href="#H:219"><span class="id" title="binder">H</span></a> <a id="Q:220" class="idref" href="#Q:220"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:218"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:219"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:220"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:218"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#H:219"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">GC</span></a>) <a class="idref" href="Affine.html#Q:220"><span class="id" title="variable">Q</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="FromPreToPostGC.triple_hgc_post" class="idref" href="#FromPreToPostGC.triple_hgc_post"><span class="id" title="lemma">triple_hgc_post</span></a> : <span class="id" title="keyword">∀</span> <a id="t:222" class="idref" href="#t:222"><span class="id" title="binder">t</span></a> <a id="H:223" class="idref" href="#H:223"><span class="id" title="binder">H</span></a> <a id="Q:224" class="idref" href="#Q:224"><span class="id" title="binder">Q</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:222"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:223"><span class="id" title="variable">H</span></a> (<a class="idref" href="Affine.html#Q:224"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#5e7f0b24a844c8e20e7e8da54b64a002"><span class="id" title="notation">GC</span></a>) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="Affine.html#t:222"><span class="id" title="variable">t</span></a> <a class="idref" href="Affine.html#H:223"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#Q:224"><span class="id" title="variable">Q</span></a>.<br/>
</div>

<div class="doc">
The key idea of the proof is that a term <span class="inlinecode"><span class="id" title="var">t</span></span> admits the same behavior
    as <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>. Thus, to simulate discarding a predicate from
    the postcondition of <span class="inlinecode"><span class="id" title="var">t</span></span>, one can invoke the discard rule on the
    precondition of the variable <span class="inlinecode"><span class="id" title="var">x</span></span> that appears at the end of
    <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>.

<div class="paragraph"> </div>

    To formalize this idea, recall from <span class="inlinecode"><span class="id" title="var">Rules</span></span> the lemma
    <span class="inlinecode"><span class="id" title="var">eval_like_eta_expansion</span></span> which asserts the equivalence of
    <span class="inlinecode"><span class="id" title="var">t</span></span> and <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>, and recall the lemma <span class="inlinecode"><span class="id" title="var">triple_eval_like</span></span>,
    which asserts that two equivalent terms satisfy the same triples. 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="var">lets</span> <span class="id" title="var">E</span>: <a class="idref" href="Rules.html#ProofsSameSemantics.eval_like_eta_expansion"><span class="id" title="lemma">eval_like_eta_expansion</span></a> <span class="id" title="var">t</span> "x".<br/>
&nbsp;&nbsp;<span class="id" title="var">applys</span> <a class="idref" href="Rules.html#ProofsSameSemantics.triple_eval_like"><span class="id" title="lemma">triple_eval_like</span></a> <span class="id" title="var">E</span>. <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#triple_let"><span class="id" title="axiom">triple_let</span></a>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <span class="id" title="var">M</span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">v</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#FromPreToPostGC.triple_hgc_pre"><span class="id" title="axiom">triple_hgc_pre</span></a>. <span class="id" title="var">applys</span> <a class="idref" href="Rules.html#triple_val"><span class="id" title="axiom">triple_val</span></a>. <span class="id" title="tactic">auto</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#FromPreToPostGC"><span class="id" title="module">FromPreToPostGC</span></a>.<br/>
</div>

<div class="doc">
<a id="lab394"></a><h2 class="section">Low-level Definition of Refined Triples</h2>

</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="LowLevel" class="idref" href="#LowLevel"><span class="id" title="module">LowLevel</span></a>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">NewTriples</span>.<br/>
</div>

<div class="doc">
Consider the updated definition of <span class="inlinecode"><span class="id" title="var">triple</span></span> introduced in this chapter. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="LowLevel.triple" class="idref" href="#LowLevel.triple"><span class="id" title="definition">triple</span></a> (<a id="t:225" class="idref" href="#t:225"><span class="id" title="binder">t</span></a>:<a class="idref" href="LibSepReference.html#trm"><span class="id" title="inductive">trm</span></a>) (<a id="H:226" class="idref" href="#H:226"><span class="id" title="binder">H</span></a>:<a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>) (<a id="Q:227" class="idref" href="#Q:227"><span class="id" title="binder">Q</span></a>:<a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<a id="H':228" class="idref" href="#H':228"><span class="id" title="binder">H'</span></a>:<a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>), <a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a> <a class="idref" href="Affine.html#t:225"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#H:226"><span class="id" title="variable">H</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Affine.html#H':228"><span class="id" title="variable">H'</span></a>) (<a class="idref" href="Affine.html#Q:227"><span class="id" title="variable">Q</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#H':228"><span class="id" title="variable">H'</span></a> <a class="idref" href="LibSepReference.html#635f8491703dab9d0d18a6c2474b0d2a"><span class="id" title="notation"><span class='gray-font'>\</span>*+</span></a> <a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">\</span></a><a class="idref" href="Affine.html#60de723b3758066ad921153335e0c677"><span class="id" title="notation">GC</span></a>).<br/>
</div>

<div class="doc">
In chapter <a href="Hprop.html"><span class="inlineref">Hprop</span></a>, we presented an alternative definition for
    Separation Logic triples, called <span class="inlinecode"><span class="id" title="var">triple_lowlevel</span></span>, expressed directly
    in terms of heaps.
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">triple_lowlevel</span> (<span class="id" title="var">t</span>:<span class="id" title="var">trm</span>) (<span class="id" title="var">H</span>:<span class="id" title="var">hprop</span>) (<span class="id" title="var">Q</span>:<span class="id" title="var">val</span>→<span class="id" title="var">hprop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>2</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Fmap.disjoint</span> <span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>2</sub></span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">H</span> <span class="id" title="var">h<sub>1</sub></span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">h<sub>1</sub>'</span> <span class="id" title="var">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Fmap.disjoint</span> <span class="id" title="var">h<sub>1</sub>'</span> <span class="id" title="var">h<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∧ <span class="id" title="tactic">eval</span> (<span class="id" title="var">h<sub>1</sub></span> \<span class="id" title="var">u</span> <span class="id" title="var">h<sub>2</sub></span>) <span class="id" title="var">t</span> (<span class="id" title="var">h<sub>1</sub>'</span> \<span class="id" title="var">u</span> <span class="id" title="var">h<sub>2</sub></span>) <span class="id" title="var">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∧ <span class="id" title="var">Q</span> <span class="id" title="var">v</span> <span class="id" title="var">h<sub>1</sub>'</span>.
</span>    In what follows, we explain how to generalize this definition to match
    our revised definition of <span class="inlinecode"><span class="id" title="var">triple</span></span>, and thereby obtain a direct definition
    expressed in terms of heap, that does not depend on the definition of
    <span class="inlinecode"><span class="id" title="var">hstar</span></span> nor that of <span class="inlinecode">\<span class="id" title="var">GC</span></span>.

<div class="paragraph"> </div>

    Let us aim instead for a direct definition, entirely expressed in terms
    of union of heaps. To that end, we need to introduce an additional piece of
    state to describe the piece of the final heap covered by the <span class="inlinecode">\<span class="id" title="var">GC</span></span>
    predicate.

<div class="paragraph"> </div>

    We will need to describe the disjointness of the 3 pieces of heap that
    describe the final state. To that end, we exploit the auxiliary definition
    <span class="inlinecode"><span class="id" title="var">Fmap.disjoint_3</span></span> <span class="inlinecode"><span class="id" title="var">h<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">h<sub>2</sub></span></span> <span class="inlinecode"><span class="id" title="var">h<sub>3</sub></span></span>, which asserts that the three arguments denote
    pairwise disjoint heaps. It is defined in the module <span class="inlinecode"><span class="id" title="var">Fmap</span></span> as follows.
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">disjoint_3</span> (<span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>2</sub></span> <span class="id" title="var">h<sub>3</sub></span>:<span class="id" title="var">heap</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">disjoint</span> <span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∧ <span class="id" title="var">disjoint</span> <span class="id" title="var">h<sub>2</sub></span> <span class="id" title="var">h<sub>3</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∧ <span class="id" title="var">disjoint</span> <span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>3</sub></span>.
</span>
<div class="paragraph"> </div>

 We then formulate <span class="inlinecode"><span class="id" title="var">triple_lowlevel</span></span> using a final state of the from
    <span class="inlinecode"><span class="id" title="var">h<sub>1</sub>'</span></span> <span class="inlinecode">\<span class="id" title="var">u</span></span> <span class="inlinecode"><span class="id" title="var">h<sub>2</sub></span></span> <span class="inlinecode">\<span class="id" title="var">u</span></span> <span class="inlinecode"><span class="id" title="var">h<sub>3</sub>'</span></span> instead of just <span class="inlinecode"><span class="id" title="var">h<sub>1</sub>'</span></span> <span class="inlinecode">\<span class="id" title="var">u</span></span> <span class="inlinecode"><span class="id" title="var">h<sub>2</sub></span></span>. There, <span class="inlinecode"><span class="id" title="var">h<sub>3</sub>'</span></span> denotes
    the piece of the final state covered by the <span class="inlinecode">\<span class="id" title="var">GC</span></span> heap predicate.
    This piece of state is an affine heap, as captured by <span class="inlinecode"><span class="id" title="var">heap_affine</span></span> <span class="inlinecode"><span class="id" title="var">h<sub>3</sub>'</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="LowLevel.triple_lowlevel" class="idref" href="#LowLevel.triple_lowlevel"><span class="id" title="definition">triple_lowlevel</span></a> (<a id="t:229" class="idref" href="#t:229"><span class="id" title="binder">t</span></a>:<a class="idref" href="LibSepReference.html#trm"><span class="id" title="inductive">trm</span></a>) (<a id="H:230" class="idref" href="#H:230"><span class="id" title="binder">H</span></a>:<a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>) (<a id="Q:231" class="idref" href="#Q:231"><span class="id" title="binder">Q</span></a>:<a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><a class="idref" href="LibSepReference.html#SepSimplArgs.hprop"><span class="id" title="definition">hprop</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a id="h<sub>1</sub>:232" class="idref" href="#h<sub>1</sub>:232"><span class="id" title="binder">h<sub>1</sub></span></a> <a id="h<sub>2</sub>:233" class="idref" href="#h<sub>2</sub>:233"><span class="id" title="binder">h<sub>2</sub></span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.disjoint"><span class="id" title="definition">Fmap.disjoint</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:232"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:233"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#H:230"><span class="id" title="variable">H</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>:232"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<span class="id" title="notation">∃</span> <a id="h<sub>1</sub>':234" class="idref" href="#h<sub>1</sub>':234"><span class="id" title="binder">h<sub>1</sub>'</span></a> <a id="h<sub>3</sub>':235" class="idref" href="#h<sub>3</sub>':235"><span class="id" title="binder">h<sub>3</sub>'</span></a> <a id="v:236" class="idref" href="#v:236"><span class="id" title="binder">v</span></a><span class="id" title="notation">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#Fmap.disjoint_3"><span class="id" title="definition">Fmap.disjoint_3</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>':234"><span class="id" title="variable">h<sub>1</sub>'</span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:233"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="Affine.html#h<sub>3</sub>':235"><span class="id" title="variable">h<sub>3</sub>'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="Affine.html#heap_affine"><span class="id" title="axiom">heap_affine</span></a> <a class="idref" href="Affine.html#h<sub>3</sub>':235"><span class="id" title="variable">h<sub>3</sub>'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="LibSepReference.html#eval"><span class="id" title="inductive">eval</span></a> (<a class="idref" href="Affine.html#h<sub>1</sub>:232"><span class="id" title="variable">h<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">u</span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:233"><span class="id" title="variable">h<sub>2</sub></span></a>) <a class="idref" href="Affine.html#t:229"><span class="id" title="variable">t</span></a> (<a class="idref" href="Affine.html#h<sub>1</sub>':234"><span class="id" title="variable">h<sub>1</sub>'</span></a> <a class="idref" href="LibSepReference.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">u</span></a> <a class="idref" href="Affine.html#h<sub>2</sub>:233"><span class="id" title="variable">h<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">u</span></a> <a class="idref" href="Affine.html#h<sub>3</sub>':235"><span class="id" title="variable">h<sub>3</sub>'</span></a>) <a class="idref" href="Affine.html#v:236"><span class="id" title="variable">v</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="Affine.html#Q:231"><span class="id" title="variable">Q</span></a> <a class="idref" href="Affine.html#v:236"><span class="id" title="variable">v</span></a> <a class="idref" href="Affine.html#h<sub>1</sub>':234"><span class="id" title="variable">h<sub>1</sub>'</span></a>.<br/>
</div>

<div class="doc">
One can prove the equivalence of <span class="inlinecode"><span class="id" title="var">triple</span></span> and <span class="inlinecode"><span class="id" title="var">triple_lowlevel</span></span>
    following a similar proof pattern as previously. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="LowLevel.triple_eq_triple_lowlevel" class="idref" href="#LowLevel.triple_eq_triple_lowlevel"><span class="id" title="lemma">triple_eq_triple_lowlevel</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Affine.html#LowLevel.triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Affine.html#LowLevel.triple_lowlevel"><span class="id" title="definition">triple_lowlevel</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">applys</span> <span class="id" title="lemma">pred_ext_3</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">t</span> <span class="id" title="var">H</span> <span class="id" title="var">Q</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Affine.html#LowLevel.triple"><span class="id" title="definition">triple</span></a>, <a class="idref" href="Affine.html#LowLevel.triple_lowlevel"><span class="id" title="definition">triple_lowlevel</span></a>, <a class="idref" href="LibSepReference.html#hoare"><span class="id" title="definition">hoare</span></a>. <span class="id" title="var">iff</span> <span class="id" title="var">M</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">introv</span> <span class="id" title="var">D</span> <span class="id" title="var">P<sub>1</sub></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">forwards</span>¬(<span class="id" title="var">h'</span>&amp;<span class="id" title="var">v</span>&amp;<span class="id" title="var">R<sub>1</sub></span>&amp;<span class="id" title="var">R<sub>2</sub></span>): <span class="id" title="var">M</span> (<span class="id" title="notation">=</span><span class="id" title="var">h<sub>2</sub></span>) (<span class="id" title="var">h<sub>1</sub></span> <a class="idref" href="LibSepReference.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">u</span></a> <span class="id" title="var">h<sub>2</sub></span>). { <span class="id" title="tactic">apply</span>* <a class="idref" href="LibSepReference.html#SepSimplArgs.hstar_intro"><span class="id" title="lemma">hstar_intro</span></a>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">R<sub>2</sub></span> <span class="id" title="keyword">as</span> (<span class="id" title="var">h<sub>2</sub>'</span>&amp;<span class="id" title="var">h<sub>1</sub>''</span>&amp;<span class="id" title="var">N<sub>0</sub></span>&amp;<span class="id" title="var">N<sub>1</sub></span>&amp;<span class="id" title="var">N<sub>2</sub></span>&amp;<span class="id" title="var">N<sub>3</sub></span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">N<sub>0</sub></span> <span class="id" title="keyword">as</span> (<span class="id" title="var">h<sub>1</sub>'</span>&amp;<span class="id" title="var">h<sub>3</sub>'</span>&amp;<span class="id" title="var">T<sub>0</sub></span>&amp;<span class="id" title="var">T<sub>1</sub></span>&amp;<span class="id" title="var">T<sub>2</sub></span>&amp;<span class="id" title="var">T<sub>3</sub></span>). <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">h<sub>1</sub>'</span> <span class="id" title="var">h<sub>1</sub>''</span> <span class="id" title="var">v</span>. <span class="id" title="var">splits</span>*.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">rew_disjoint</span>. <span class="id" title="tactic">auto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">applys</span> <a class="idref" href="Affine.html#hgc_inv"><span class="id" title="axiom">hgc_inv</span></a> <span class="id" title="var">N<sub>1</sub></span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">applys_eq</span>* <span class="id" title="var">R<sub>1</sub></span>. } }<br/>
&nbsp;&nbsp;{ <span class="id" title="var">introv</span> (<span class="id" title="var">h<sub>1</sub></span>&amp;<span class="id" title="var">h<sub>2</sub></span>&amp;<span class="id" title="var">N<sub>1</sub></span>&amp;<span class="id" title="var">N<sub>2</sub></span>&amp;<span class="id" title="var">D</span>&amp;<span class="id" title="var">U</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">forwards</span>¬(<span class="id" title="var">h<sub>1</sub>'</span>&amp;<span class="id" title="var">h<sub>3</sub>'</span>&amp;<span class="id" title="var">v</span>&amp;<span class="id" title="var">R<sub>1</sub></span>&amp;<span class="id" title="var">R<sub>2</sub></span>&amp;<span class="id" title="var">R<sub>3</sub></span>&amp;<span class="id" title="var">R<sub>4</sub></span>): <span class="id" title="var">M</span> <span class="id" title="var">h<sub>1</sub></span> <span class="id" title="var">h<sub>2</sub></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> (<span class="id" title="var">h<sub>1</sub>'</span> <a class="idref" href="LibSepReference.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">u</span></a> <span class="id" title="var">h<sub>3</sub>'</span> <a class="idref" href="LibSepReference.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#11dbc5cc324072f557c3f348a31ba1a<sub>0</sub>"><span class="id" title="notation">u</span></a> <span class="id" title="var">h<sub>2</sub></span>) <span class="id" title="var">v</span>. <span class="id" title="var">splits</span>*.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">applys_eq</span>* <span class="id" title="var">R<sub>3</sub></span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.hstar_assoc"><span class="id" title="lemma">hstar_assoc</span></a>. <span class="id" title="tactic">apply</span>* <a class="idref" href="LibSepReference.html#SepSimplArgs.hstar_intro"><span class="id" title="lemma">hstar_intro</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="LibSepReference.html#SepSimplArgs.hstar_comm"><span class="id" title="lemma">hstar_comm</span></a>. <span class="id" title="var">applys</span>* <a class="idref" href="LibSepReference.html#SepSimplArgs.hstar_intro"><span class="id" title="lemma">hstar_intro</span></a>. <span class="id" title="var">applys</span>* <a class="idref" href="Affine.html#hgc_intro"><span class="id" title="axiom">hgc_intro</span></a>. } }<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Affine.html#LowLevel"><span class="id" title="module">LowLevel</span></a>.<br/>
</div>

<div class="doc">
<a id="lab395"></a><h2 class="section">Historical Notes</h2>

<div class="paragraph"> </div>

 The seminal presentation of Separation Logic concerns a linear logic, for
    a programming language with explicit deallocation. More recent works on
    Separation Logic for ML-style languages, equipped with a garbage collector,
    consider affine logics. For example, the original presentation of the Iris
    framework provides an affine entailment, for which <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class='gray-font'>\</span>[]</span> is always
    true. Follow-up work on Iris provides encodings for supporting linear
    resources, i.e., resources that are not allowed to be "dropped on the
    floor".

<div class="paragraph"> </div>

    This chapter gives a presentation of Separation Logic featuring a
    customizable predicate <span class="inlinecode"><span class="id" title="var">haffine</span></span> for controlling which resources should be
    treated as affine, and which ones should be treated as linear. This
    direct approach to controlling linearity was introduced in the context of
    CFML, in work by <a href="Bib.html#Guéneau,-Jourdan, Charguéraud, and Pottier 2019"><span class="inlineref">[Guéneau, Jourdan, Charguéraud, and Pottier 2019]</span></a> 
</div>
<div class="code">

<span class="comment">(*&nbsp;2022-07-08&nbsp;20:09&nbsp;*)</span><br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>