<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>Basic: Basic Proofs in Separation Logic</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/slf.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<div id="page">

<div id="header">
<div id='logoinheader'><a href='https://softwarefoundations.cis.upenn.edu'>
<img src='common/media/image/sf_logo_sm.png' alt='Software Foundations Logo'></a></div>
<div class='booktitleinheader'><a href='index.html'>Volume 6: Separation Logic Foundations</a></div>
<ul id='menu'>
   <li class='section_name'><a href='toc.html'>Table of Contents</a></li>
   <li class='section_name'><a href='coqindex.html'>Index</a></li>
   <li class='section_name'><a href='deps.html'>Roadmap</a></li>
</ul>
</div>

<div id="main">

<h1 class="libtitle">Basic<span class="subtitle">Basic Proofs in Separation Logic</span></h1>


<div class="code">

<span class="id" title="keyword">Set Implicit Arguments</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">SLF</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="LibSepReference.html#"><span class="id" title="library">LibSepReference</span></a>.<br/>
<span class="id" title="keyword">Import</span> <a class="idref" href="LibSepReference.html#ProgramSyntax"><span class="id" title="module">ProgramSyntax</span></a> <a class="idref" href="LibSepReference.html#DemoPrograms"><span class="id" title="module">DemoPrograms</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="notation">int</span>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span> : <a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>.<br/>
</div>

<div class="doc">
<a id="lab13"></a><h1 class="section">A First Taste</h1>

<div class="paragraph"> </div>

 This chapter gives an overview of the basic features of Separation Logic, by
    means of examples. Example programs are specified and verified using a
    Separation Logic framework whose construction is explained throughout the
    course. 
</div>

<div class="doc">
<a id="lab14"></a><h2 class="section">Parsing of Programs</h2>

<div class="paragraph"> </div>

 The programs we consider are written within Coq, using a "custom grammar"
    that allows writing code that reads almost like OCaml code. For example,
    consider the function <span class="inlinecode"><span class="id" title="var">incr</span></span>, which increments the contents of a mutable
    cell that stores an integer. In OCaml syntax, this function could be defined
    as:

<div class="paragraph"> </div>

<span class="inlinecode-ocaml">&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">incr</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">p</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">n</span> = !<span class="id" title="var">p</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">m</span> = <span class="id" title="var">n</span> + 1 <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">p</span> := <span class="id" title="var">m</span>
</span>
<div class="paragraph"> </div>

 In Coq, the corresponding program is described as shown below. The function
    defined, named <span class="inlinecode"><span class="id" title="var">incr</span></span>, admits the type <span class="inlinecode"><span class="id" title="var">val</span></span>. This type is defined by the
    framework. Observe that all variable names are prefixed with a quote symbol.
    This presentation avoids conflict between program variables and Coq
    constants. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="incr" class="idref" href="#incr"><span class="id" title="definition">incr</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> 1 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#e0633f114fcb17e965cb872e30ce07a<sub>5</sub>"><span class="id" title="notation">:=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
There is no need to learn how to write programs in this custom syntax:
    source code is provided for all the programs involved in this course. 
<div class="paragraph"> </div>

 To simplify the implementation of the framework and the reasoning about
    programs, we make throughout the course the simplifying assumption that
    programs are written in "A-normal form": all intermediate expressions must
    be named using a let-binding. 
</div>

<div class="doc">
<a id="lab15"></a><h2 class="section">Specification of the Increment Function</h2>

<div class="paragraph"> </div>

 The specification of <span class="inlinecode"><span class="id" title="var">incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> is expressed using a "Separation Logic
    triple", that is, a predicate of the form <span class="inlinecode"><span class="id" title="var">triple</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span>. The term <span class="inlinecode"><span class="id" title="var">t</span></span> here
    corresponds to the application of the function <span class="inlinecode"><span class="id" title="var">incr</span></span> to the argument <span class="inlinecode"><span class="id" title="var">p</span></span>.
    We could write this application in the form <span class="inlinecode">&lt;{</span> <span class="inlinecode"><span class="id" title="var">incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">}&gt;</span>, using the custom
    syntax for parsing programs.

<div class="paragraph"> </div>

    The components <span class="inlinecode"><span class="id" title="var">H</span></span> and <span class="inlinecode"><span class="id" title="var">Q</span></span> correspond to the precondition and to the
    postcondition, which are explained next. To improve readability, we follow
    the convention of writing both the precondition and the postcondition on
    separate lines. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_incr" class="idref" href="#triple_incr"><span class="id" title="lemma">triple_incr</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:1" class="idref" href="#p:1"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:2" class="idref" href="#n:2"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="Basic.html#incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="Basic.html#p:1"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:1"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:2"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ (<a class="idref" href="Basic.html#p:1"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:2"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>)).<br/>
</div>

<div class="doc">
In the specification above, <span class="inlinecode"><span class="id" title="var">p</span></span> denotes the "location" -- that is, the
    address in memory of the reference cell provided as argument to the
    increment function. Locations have type <span class="inlinecode"><span class="id" title="var">loc</span></span> in the framework.

<div class="paragraph"> </div>

    The precondition is written <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. This Separation Logic predicate
    describes a memory state in which the contents of the location <span class="inlinecode"><span class="id" title="var">p</span></span> is the
    value <span class="inlinecode"><span class="id" title="var">n</span></span>. In the present example, <span class="inlinecode"><span class="id" title="var">n</span></span> stands for an integer value.

<div class="paragraph"> </div>

    The behavior of the operation <span class="inlinecode"><span class="id" title="var">incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> consists of updating the memory state
    by incrementing the contents of the cell at location <span class="inlinecode"><span class="id" title="var">p</span></span>, updating its
    contents to <span class="inlinecode"><span class="id" title="var">n</span>+1</span>. Thus, the memory state posterior to the increment
    operation is described by the predicate <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>.

<div class="paragraph"> </div>

    The result value returned by <span class="inlinecode"><span class="id" title="var">incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> is the unit value, which does not
    carry any useful information. In the specification of <span class="inlinecode"><span class="id" title="var">incr</span></span>, the
    postcondition is of the form <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode">...</span>, indicating that there is no
    need to bind a name for the unit result value. 
<div class="paragraph"> </div>

 The general pattern of a specification admits the following scheme.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Quantification of the arguments of the functions---here, the variable
      <span class="inlinecode"><span class="id" title="var">p</span></span>.

</li>
<li> Quantification of the "ghost variables" used to describe the input
      state---here, the variable <span class="inlinecode"><span class="id" title="var">n</span></span>.

</li>
<li> The application of the predicate <span class="inlinecode"><span class="id" title="var">triple</span></span> to the function application
      <span class="inlinecode"><span class="id" title="var">incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>---here, the term being specified by the triple.

</li>
<li> The precondition describing the input state---here, the predicate
      <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>.

</li>
<li> The postcondition describing both the output value and the output state.
      The general pattern is <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">H'</span></span>, where <span class="inlinecode"><span class="id" title="var">r</span></span> names the result and
      <span class="inlinecode"><span class="id" title="var">H'</span></span> describes the final state. Here, <span class="inlinecode"><span class="id" title="var">r</span></span> is just an underscore symbol,
      and the final state is described by <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>. 
</li>
</ul>

<div class="paragraph"> </div>

 Note that we have to write <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span> using parentheses around <span class="inlinecode"><span class="id" title="var">n</span>+1</span>,
    because otherwise <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span>+1</span> would get parsed as <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">+</span> <span class="inlinecode">1</span>. 
</div>

<div class="doc">
<a id="lab16"></a><h2 class="section">Verification of the Increment Function</h2>

<div class="paragraph"> </div>

 Our next step is to prove the specification lemma <span class="inlinecode"><span class="id" title="var">triple_incr</span></span> which
    specifies the behavior of the function <span class="inlinecode"><span class="id" title="var">incr</span></span>. We conduct the proof using
    tactics provided by the frameworks, collectively called "x-tactics" because
    their names all start with the letter "x". These tactics include <span class="inlinecode"><span class="id" title="var">xwp</span></span> for
    starting a proof, <span class="inlinecode"><span class="id" title="var">xapp</span></span> for reasoning about a function call, and <span class="inlinecode"><span class="id" title="var">xsimpl</span></span>
    for proving that a description of a state entails another one. 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">xwp</span></span> begins the verification proof. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">xwp</span>.<br/>
</div>

<div class="doc">
The proof obligation is displayed using a custom notation of the form
    <span class="inlinecode"><span class="id" title="var">PRE</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">CODE</span></span> <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode"><span class="id" title="var">POST</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span>. In the <span class="inlinecode"><span class="id" title="var">CODE</span></span> section, one should be able to somewhat
    recognize the body of <span class="inlinecode"><span class="id" title="var">incr</span></span>. Indeed, if we ignore the back-ticks and
    perform the alpha-renaming from <span class="inlinecode"><span class="id" title="var">v</span></span> to <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">v<sub>0</sub></span></span> to <span class="inlinecode"><span class="id" title="var">m</span></span>, the <span class="inlinecode"><span class="id" title="var">CODE</span></span>
    section reads like:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;[ <span class="id" title="keyword">Let</span> <span class="id" title="var">n</span> := <span class="id" title="var">App</span> <span class="id" title="var">val_get</span> <span class="id" title="var">p</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Let</span> <span class="id" title="var">m</span> := <span class="id" title="var">App</span> <span class="id" title="var">val_add</span> <span class="id" title="var">n</span> 1 <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">App</span> <span class="id" title="var">val_set</span> <span class="id" title="var">p</span> ) ]&gt;
</span>    which is somewhat similar to the original source code, but displayed using a
    special syntax whose meaning will be explained in chapter <a href="WPgen.html"><span class="inlineref">WPgen</span></a>. 
<div class="paragraph"> </div>

 The remainder of the proof performs essentially a symbolic execution of the
    code. At each step, one should not attempt to read the full proof
    obligation, but instead only look at the current state, described by the
    <span class="inlinecode"><span class="id" title="var">PRE</span></span> part (here, <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>), and at the first line only of the <span class="inlinecode"><span class="id" title="var">CODE</span></span> part,
    which corresponds to the next operation to reason about. Each of the
    operations involved here is handled using the tactic <span class="inlinecode"><span class="id" title="var">xapp</span></span>. 
<div class="paragraph"> </div>

 First, we reason about the operation <span class="inlinecode">!<span class="id" title="var">p</span></span> that reads into <span class="inlinecode"><span class="id" title="var">p</span></span>; this read
    operation returns the value <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">xapp</span>.<br/>
</div>

<div class="doc">
Second, we reason about the addition operation <span class="inlinecode"><span class="id" title="var">n</span>+1</span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">xapp</span>.<br/>
</div>

<div class="doc">
Third, we reason about the update operation <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">n</span>+1</span>, thereby updating the
    state to <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">xapp</span>.<br/>
</div>

<div class="doc">
At this stage, the proof obligation takes the form <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span>. It requires
    us to check that the final state matches what is claimed in the
    postcondition. We discharge it using the tactic <span class="inlinecode"><span class="id" title="var">xsimpl</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
This completes the verification of the lemma <span class="inlinecode"><span class="id" title="var">triple_incr</span></span>, which
    establishes a formal specification for the increment function. Before moving
    on to another function, we add the lemma <span class="inlinecode"><span class="id" title="var">triple_incr</span></span> to a hint database
    called <span class="inlinecode"><span class="id" title="var">triple</span></span>, using the command shown below. If at some point we verify a
    function that includes a call to <span class="inlinecode"><span class="id" title="var">incr</span></span>, the <span class="inlinecode"><span class="id" title="var">xapp</span></span> tactic will be able to
    automatically invoke the lemma <span class="inlinecode"><span class="id" title="var">triple_incr</span></span>. 
</div>
<div class="code">

#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Resolve</span> <span class="id" title="var">triple_incr</span> : <span class="id" title="var">triple</span>.<br/>
</div>

<div class="doc">
To minimize the amount of syntactic noise in specifications, we leverage an
    advanced feature of Coq's coercion mechanism. Concretely, instead of writing
    the specification in the form <span class="inlinecode"><span class="id" title="var">triple</span></span> <span class="inlinecode">&lt;{</span> <span class="inlinecode"><span class="id" title="var">incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">}&gt;</span> <span class="inlinecode">...</span>, we write it in the
    form <span class="inlinecode"><span class="id" title="var">triple</span></span> <span class="inlinecode">(<span class="id" title="var">incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span>)</span> <span class="inlinecode">...</span>, that is, with just parentheses. Thanks to the
    coercion mecanism, explained in more detail in chapter <a href="Rules.html"><span class="inlineref">Rules</span></a>, when
    Coq sees a "program value" <span class="inlinecode"><span class="id" title="var">incr</span></span> being applied to an argument <span class="inlinecode"><span class="id" title="var">p</span></span>, it
    automatically interprets this as a "program function call" of <span class="inlinecode"><span class="id" title="var">incr</span></span> to <span class="inlinecode"><span class="id" title="var">p</span></span>.
    Thus, the specification of the increment function can be written as follows.
    
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_incr'" class="idref" href="#triple_incr'"><span class="id" title="lemma">triple_incr'</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:3" class="idref" href="#p:3"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:4" class="idref" href="#n:4"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="Basic.html#p:3"><span class="id" title="variable">p</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:3"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:4"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ (<a class="idref" href="Basic.html#p:3"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:4"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Here,&nbsp;to&nbsp;view&nbsp;coercions,&nbsp;use&nbsp;<span class="inlinecode"><span class="id" title="keyword">Set</span></span> <span class="inlinecode"><span class="id" title="keyword">Printing</span></span> <span class="inlinecode"><span class="id" title="var">Coercions</span>.</span>&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The existence of implicit coercions might be a little confusing at times,
    but coercions make specifications so much more readable that it would be a
    pity to not exploit them. 
<div class="paragraph"> </div>

 The reader may be curious to know what the notation <span class="inlinecode"><span class="id" title="var">PRE</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">CODE</span></span> <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode"><span class="id" title="var">POST</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span>
    stands for, and what the x-tactics are doing. Everything will be explained
    as we move through the course. This chapter and the next avoid such
    explanations to focus on surveying the features of Separation Logic and
    showing how x-tactics can be used to verify programs. 
</div>

<div class="doc">
<a id="lab17"></a><h2 class="section">A Function with a Return Value</h2>

<div class="paragraph"> </div>

 As a second example, let us specify a function that performs simple
    arithmetic computations. The function, whose code appears below, expects an
    integer argument <span class="inlinecode"><span class="id" title="var">n</span></span> (in <span class="inlinecode"><span class="id" title="var">Z</span></span>). It evaluates <span class="inlinecode"><span class="id" title="var">a</span></span> as <span class="inlinecode"><span class="id" title="var">n</span>+1</span>, then evaluates <span class="inlinecode"><span class="id" title="var">b</span></span>
    as <span class="inlinecode"><span class="id" title="var">n</span>-1</span>, and finally returns the sum <span class="inlinecode"><span class="id" title="var">a</span>+<span class="id" title="var">b</span></span>. The function thus always
    returns <span class="inlinecode">2*<span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="example_let" class="idref" href="#example_let"><span class="id" title="definition">example_let</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''a'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''a'"><span class="id" title="notation">a</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> 1 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:x_'-'_x"><span class="id" title="notation">-</span></a> 1 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''a'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''a'"><span class="id" title="notation">a</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
The specification takes the form <span class="inlinecode"><span class="id" title="var">triple</span></span> <span class="inlinecode">(<span class="id" title="var">example_let</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">H'</span>)</span>,
    where <span class="inlinecode"><span class="id" title="var">r</span></span>, of type <span class="inlinecode"><span class="id" title="var">val</span></span>, denotes the output value.

<div class="paragraph"> </div>

    The precondition <span class="inlinecode"><span class="id" title="var">H</span></span> describes what we need to assume about the input state.
    For this function, we need not assume anything, hence we write <span class="inlinecode"><span class='gray-font'>\</span>[]</span> to
    denote the empty precondition. The program might have allocated data prior
    to the call to the function <span class="inlinecode"><span class="id" title="var">example_let</span></span>, but this function will not
    interfere in any way with this previously allocated data.

<div class="paragraph"> </div>

    The postcondition describes what the function produces. More precisely, the
    postcondition specifies both the output that the function returns and the
    data from memory that the function has allocated, accessed, or updated. The
    function <span class="inlinecode"><span class="id" title="var">example_let</span></span> does not interact with the memory, thus the
    postcondition could be described using the empty predicate <span class="inlinecode"><span class='gray-font'>\</span>[]</span>.

<div class="paragraph"> </div>

    Yet, if we write just <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode">(<span class="id" title="var">r</span>:<span class="id" title="var">val</span>)</span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class='gray-font'>\</span>[]</span> as postcondition, we would have
    said nothing about the output value <span class="inlinecode"><span class="id" title="var">r</span></span> produced by a call <span class="inlinecode"><span class="id" title="var">example_let</span></span>.
    Instead, we would like to specify that the result <span class="inlinecode"><span class="id" title="var">r</span></span> is equal to <span class="inlinecode">2*<span class="id" title="var">n</span></span>. To
    that end, we write the postcondition <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode">2*<span class="id" title="var">n</span>]</span>. Here, we use the
    predicate format <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">P</span>]</span>, which allows to embed "pure facts", of type <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>
    in preconditions and postconditions.

<div class="paragraph"> </div>

    The equality <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode">2*<span class="id" title="var">n</span></span> actually resolves to <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">val_int</span></span> <span class="inlinecode">(2*<span class="id" title="var">n</span>)</span>, where
    <span class="inlinecode"><span class="id" title="var">val_int</span></span> is a coercion that translates the integer value <span class="inlinecode">2*<span class="id" title="var">n</span></span> into the
    corresponding integer value, of type <span class="inlinecode"><span class="id" title="var">val</span></span>, from the programming language.
    If you do not know what a coercion is, just ignore the previous sentence. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_example_let" class="idref" href="#triple_example_let"><span class="id" title="lemma">triple_example_let</span></a> : <span class="id" title="keyword">∀</span> (<a id="n:5" class="idref" href="#n:5"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#example_let"><span class="id" title="definition">example_let</span></a> <a class="idref" href="Basic.html#n:5"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:6" class="idref" href="#r:6"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:6"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 2<a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#d3ea1afb7d81263dc23c4eb0da2a3c4e"><span class="id" title="notation">*</span></a><a class="idref" href="Basic.html#n:5"><span class="id" title="variable">n</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
</div>

<div class="doc">
The proof script is quite similar to the previous one: <span class="inlinecode"><span class="id" title="var">xwp</span></span> begins the
    proof, <span class="inlinecode"><span class="id" title="var">xapp</span></span> performs symbolic execution. and <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> simplifies the
    entailment. Ultimately, we need to check that the expression computed,
    <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> <span class="inlinecode">+</span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode">1)</span>, is equal to the specified result, that is, <span class="inlinecode">2*<span class="id" title="var">n</span></span>. To
    prove this equality, we invoke the tactic <span class="inlinecode"><span class="id" title="var">math</span></span> provided by the TLC
    library. Recall from the preface that this course leverages TLC for enhanced
    definitions and tactics. (Technically, <span class="inlinecode"><span class="id" title="var">math</span></span> is a wrapper around the
    standard Coq tactic <span class="inlinecode"><span class="id" title="var">lia</span></span>; this wrapper is needed because TLC uses different
    definitions for arithmetic inequalities than Coq's standard library.) 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>. <span class="id" title="var">math</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab18"></a><h4 class="section">Exercise: 1 star, standard, especially useful (triple_quadruple)</h4>

<div class="paragraph"> </div>

 Consider the function <span class="inlinecode"><span class="id" title="var">quadruple</span></span>, which expects an integer <span class="inlinecode"><span class="id" title="var">n</span></span> and returns
    its quadruple, that is, the value <span class="inlinecode">4*<span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="quadruple" class="idref" href="#quadruple"><span class="id" title="definition">quadruple</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
Specify and verify the function <span class="inlinecode"><span class="id" title="var">quadruple</span></span> to express that it returns
    <span class="inlinecode">4*<span class="id" title="var">n</span></span>. Follow the pattern of the previous proof. 
</div>
<div class="code">

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab19"></a><h4 class="section">Exercise: 2 stars, standard, especially useful (triple_inplace_double)</h4>

<div class="paragraph"> </div>

 Consider the function <span class="inlinecode"><span class="id" title="var">inplace_double</span></span>, which expects a reference to an
    integer, reads its contents, then updates the contents with the double of
    the original value. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="inplace_double" class="idref" href="#inplace_double"><span class="id" title="definition">inplace_double</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#e0633f114fcb17e965cb872e30ce07a<sub>5</sub>"><span class="id" title="notation">:=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
Specify and verify the function <span class="inlinecode"><span class="id" title="var">inplace_double</span></span>, following the pattern of
    the first example, <span class="inlinecode"><span class="id" title="var">triple_incr</span></span>. 
</div>
<div class="code">

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 From here on, we use the command <span class="inlinecode"><span class="id" title="keyword">Proof</span></span> <span class="inlinecode"><span class="id" title="keyword">using</span></span> for introducing a proof
    instead of writing just <span class="inlinecode"><span class="id" title="keyword">Proof</span></span>. Writing <span class="inlinecode"><span class="id" title="keyword">Proof</span></span> <span class="inlinecode"><span class="id" title="keyword">using</span>.</span> tells Coq that the
    proof of the lemma does not depend on section variables others than the ones
    involved for typechecking the statement of the lemma. The <span class="inlinecode"><span class="id" title="keyword">Proof</span></span> <span class="inlinecode"><span class="id" title="keyword">using</span>.</span>
    enables Coq to compile proofs in parallel when the <span class="inlinecode">-<span class="id" title="var">vos</span></span> flag is passed.
    For more details, see the "Need for Proof using" section from:
    <a href='https://coq.inria.fr/refman/practical-tools/coq-commands.html'>https://coq.inria.fr/refman/practical-tools/coq-commands.html</a>
</div>

<div class="doc">
<a id="lab20"></a><h1 class="section">Separation Logic Operators</h1>

</div>

<div class="doc">
<a id="lab21"></a><h2 class="section">Increment of Two References</h2>

<div class="paragraph"> </div>

 Consider the following function, which expects the addresses of two
    reference cells and increments both of them. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="incr_two" class="idref" href="#incr_two"><span class="id" title="definition">incr_two</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#bfe3f2ff4c10f23c7c7f24aa5367bca5"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a> <a class="idref" href="LibSepReference.html#bfe3f2ff4c10f23c7c7f24aa5367bca5"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basic.html#incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basic.html#incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
The specification of this function takes the form
    <span class="inlinecode"><span class="id" title="var">triple</span></span> <span class="inlinecode">(<span class="id" title="var">incr_two</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">q</span>)</span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">H'</span>)</span>, where again the underscore symbol
    denotes the unit result value.

<div class="paragraph"> </div>

    The precondition describes two references cells: <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">m</span></span>. To
    assert that the two cells are distinct from each other, we separate their
    description with the operator <span class="inlinecode"><span class='gray-font'>\</span>*</span>. Thus, the precondition is
    <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode">(<span class="id" title="var">q</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>, or simply <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">m</span></span>. The operator <span class="inlinecode"><span class='gray-font'>\</span>*</span>
    is called the "separating conjunction" of Separation Logic. It is also known
    as the "star" operator.

<div class="paragraph"> </div>

    The postcondition describes the final state in a similar way, as
    <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">m</span>+1)</span>. This predicate reflects the fact that both
    references have their contents increased by one unit.

<div class="paragraph"> </div>

    The specification triple for <span class="inlinecode"><span class="id" title="var">incr_two</span></span> is thus as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_incr_two" class="idref" href="#triple_incr_two"><span class="id" title="lemma">triple_incr_two</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:7" class="idref" href="#p:7"><span class="id" title="binder">p</span></a> <a id="q:8" class="idref" href="#q:8"><span class="id" title="binder">q</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:9" class="idref" href="#n:9"><span class="id" title="binder">n</span></a> <a id="m:10" class="idref" href="#m:10"><span class="id" title="binder">m</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#incr_two"><span class="id" title="definition">incr_two</span></a> <a class="idref" href="Basic.html#p:7"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#q:8"><span class="id" title="variable">q</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:7"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:9"><span class="id" title="variable">n</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#q:8"><span class="id" title="variable">q</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#m:10"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:7"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:9"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#q:8"><span class="id" title="variable">q</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#m:10"><span class="id" title="variable">m</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
We will make use of the function <span class="inlinecode"><span class="id" title="var">incr_two</span></span> later in this chapter, so we
    register the specification <span class="inlinecode"><span class="id" title="var">triple_incr_two</span></span> in the <span class="inlinecode"><span class="id" title="var">triple</span></span> database. 
</div>
<div class="code">

#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Resolve</span> <span class="id" title="var">triple_incr_two</span> : <span class="id" title="var">triple</span>.<br/>
</div>

<div class="doc">
Separation Logic expressions such as <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> or <span class="inlinecode"><span class='gray-font'>\</span>[]</span> or <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> are
    called "heap predicates", because they corresponding to predicates over
    "heaps", i.e., over memory states. 
</div>

<div class="doc">
<a id="lab22"></a><h2 class="section">Aliased Arguments</h2>

<div class="paragraph"> </div>

 The specification <span class="inlinecode"><span class="id" title="var">triple_incr_two</span></span> describes the behavior of calls to the
    function <span class="inlinecode"><span class="id" title="var">incr_two</span></span> <i>only</i> when the two arguments provided correspond to
    distinct reference cells. It says nothing at all about a call of the form
    <span class="inlinecode"><span class="id" title="var">incr_two</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>. Indeed, in Separation Logic, a state described by <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>
    cannot be matched against a state described by <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>, because
    the star operator requires its operand to correspond to disjoint pieces of
    state.

<div class="paragraph"> </div>

    What happens if we nevertheless try to exploit <span class="inlinecode"><span class="id" title="var">triple_incr_two</span></span> to reason
    about a call of the form <span class="inlinecode"><span class="id" title="var">incr_two</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>, that is, with aliased arguments?
    Let's find out, by considering the operation <span class="inlinecode"><span class="id" title="var">aliased_call</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>, which does
    execute such a call. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="aliased_call" class="idref" href="#aliased_call"><span class="id" title="definition">aliased_call</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basic.html#incr_two"><span class="id" title="definition">incr_two</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
A call to <span class="inlinecode"><span class="id" title="var">aliased_call</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> increases the contents of <span class="inlinecode"><span class="id" title="var">p</span></span> by <span class="inlinecode">2</span>. This
    property can be specified as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_aliased_call" class="idref" href="#triple_aliased_call"><span class="id" title="lemma">triple_aliased_call</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:11" class="idref" href="#p:11"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:12" class="idref" href="#n:12"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#aliased_call"><span class="id" title="definition">aliased_call</span></a> <a class="idref" href="Basic.html#p:11"><span class="id" title="variable">p</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:11"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:12"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:11"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:12"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>2<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
</div>

<div class="doc">
If we attempt the proof, we get stuck. The tactic <span class="inlinecode"><span class="id" title="var">xapp</span></span> reports its failure
    by issuing a proof obligation of the form <span class="inlinecode"><span class='gray-font'>\</span>[]</span> <span class="inlinecode">==&gt;</span> <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">?<span class="id" title="var">m</span>)</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">_</span></span>. This
    proof obligation requires us to show that, from the empty heap predicate
    state, one can extract a heap predicate <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">?<span class="id" title="var">m</span></span> describing a reference at
    location <span class="inlinecode"><span class="id" title="var">p</span></span> with some integer contents <span class="inlinecode">?<span class="id" title="var">m</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
On the one hand, the precondition of the specification <span class="inlinecode"><span class="id" title="var">triple_incr_two</span></span>,
    with <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">p</span></span>, requires providing <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">?<span class="id" title="var">n</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">?<span class="id" title="var">m</span></span>. On the other hand,
    the current state is described as <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. When trying to match the two,
    the internal simplification tactic <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> is able to cancel out one
    occurrence of <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> from both expressions, but then there remains to
    match the empty heap predicate <span class="inlinecode"><span class='gray-font'>\</span>[]</span> against <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">?<span class="id" title="var">m</span>)</span>. The issue here is
    that the specification <span class="inlinecode"><span class="id" title="var">triple_incr_two</span></span> is specialized for the case of
    "non-aliased" references. 
<div class="paragraph"> </div>

 One thing we can do is to state and prove an alternative specification for
    the function <span class="inlinecode"><span class="id" title="var">incr_two</span></span> to cover the case of aliased arguments. The
    precondition of this alternative specification mentions a single reference,
    <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. Its postcondition asserts that the contents of that reference is
    increased by two units. This alternative specification is stated and proved
    as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_incr_two_aliased" class="idref" href="#triple_incr_two_aliased"><span class="id" title="lemma">triple_incr_two_aliased</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:13" class="idref" href="#p:13"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:14" class="idref" href="#n:14"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#incr_two"><span class="id" title="definition">incr_two</span></a> <a class="idref" href="Basic.html#p:13"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#p:13"><span class="id" title="variable">p</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:13"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:14"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:13"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:14"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>2<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>. <span class="id" title="var">math</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
By exploiting the alternative specification for <span class="inlinecode"><span class="id" title="var">incr_two</span></span>, we are able to
    prove the specification of the function <span class="inlinecode"><span class="id" title="var">aliased_call</span></span>. In order to indicate
    to the tactic <span class="inlinecode"><span class="id" title="var">xapp</span></span> that it should not invoke the lemma <span class="inlinecode"><span class="id" title="var">triple_incr_two</span></span>
    registered for <span class="inlinecode"><span class="id" title="var">incr_two</span></span>, but instead invoke the lemma
    <span class="inlinecode"><span class="id" title="var">triple_incr_two_aliased</span></span>, we provide that lemma as an explicit argument to
    <span class="inlinecode"><span class="id" title="var">xapp</span></span>, writing <span class="inlinecode"><span class="id" title="var">xapp</span></span> <span class="inlinecode"><span class="id" title="var">triple_incr_two_aliased</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_aliased_call" class="idref" href="#triple_aliased_call"><span class="id" title="lemma">triple_aliased_call</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:15" class="idref" href="#p:15"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:16" class="idref" href="#n:16"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#aliased_call"><span class="id" title="definition">aliased_call</span></a> <a class="idref" href="Basic.html#p:15"><span class="id" title="variable">p</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:15"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:16"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:15"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:16"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>2<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span> <a class="idref" href="Basic.html#triple_incr_two_aliased"><span class="id" title="lemma">triple_incr_two_aliased</span></a>. <span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Taking a step back, it may be somewhat disappointing that we need two
    different specifications for the same function, depending on whether its
    arguments are aliased on not. There are advanced features of Separation
    Logic that do allow handling the two cases through a single specification.
    However, for such a simple function, it is easiest to just state and prove
    the two specifications separately. 
</div>

<div class="doc">
<a id="lab23"></a><h2 class="section">A Function that Takes Two References and Increments One</h2>

<div class="paragraph"> </div>

 Consider the following function, which expects the addresses of two
    reference cells and increments only the first one. What is interesting about
    this function is precisely the fact that it does nothing with its second
    argument. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="incr_first" class="idref" href="#incr_first"><span class="id" title="definition">incr_first</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#bfe3f2ff4c10f23c7c7f24aa5367bca5"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a> <a class="idref" href="LibSepReference.html#bfe3f2ff4c10f23c7c7f24aa5367bca5"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basic.html#incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
We can specify this function by describing its input state as
    <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">m</span></span> and describing its output state as
    <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">m</span></span>. Formally: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_incr_first" class="idref" href="#triple_incr_first"><span class="id" title="lemma">triple_incr_first</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:17" class="idref" href="#p:17"><span class="id" title="binder">p</span></a> <a id="q:18" class="idref" href="#q:18"><span class="id" title="binder">q</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:19" class="idref" href="#n:19"><span class="id" title="binder">n</span></a> <a id="m:20" class="idref" href="#m:20"><span class="id" title="binder">m</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#incr_first"><span class="id" title="definition">incr_first</span></a> <a class="idref" href="Basic.html#p:17"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#q:18"><span class="id" title="variable">q</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:17"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:19"><span class="id" title="variable">n</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#q:18"><span class="id" title="variable">q</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#m:20"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:17"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:19"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#q:18"><span class="id" title="variable">q</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#m:20"><span class="id" title="variable">m</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The second reference plays absolutely no role in the execution of the
    function. Thus, we could equally well consider a specification that mentions
    only the first reference. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_incr_first'" class="idref" href="#triple_incr_first'"><span class="id" title="lemma">triple_incr_first'</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:21" class="idref" href="#p:21"><span class="id" title="binder">p</span></a> <a id="q:22" class="idref" href="#q:22"><span class="id" title="binder">q</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:23" class="idref" href="#n:23"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#incr_first"><span class="id" title="definition">incr_first</span></a> <a class="idref" href="Basic.html#p:21"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#q:22"><span class="id" title="variable">q</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:21"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:23"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:21"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:23"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Interestingly, the specification <span class="inlinecode"><span class="id" title="var">triple_incr_first</span></span>, which mentions the two
    references, is derivable from the specification <span class="inlinecode"><span class="id" title="var">triple_incr_first'</span></span>, which
    mentions only the first. To prove the implication, it suffices to invoke the
    tactic <span class="inlinecode"><span class="id" title="var">xapp</span></span> with argument <span class="inlinecode"><span class="id" title="var">triple_incr_first'</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_incr_first_derived" class="idref" href="#triple_incr_first_derived"><span class="id" title="lemma">triple_incr_first_derived</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:24" class="idref" href="#p:24"><span class="id" title="binder">p</span></a> <a id="q:25" class="idref" href="#q:25"><span class="id" title="binder">q</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:26" class="idref" href="#n:26"><span class="id" title="binder">n</span></a> <a id="m:27" class="idref" href="#m:27"><span class="id" title="binder">m</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#incr_first"><span class="id" title="definition">incr_first</span></a> <a class="idref" href="Basic.html#p:24"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#q:25"><span class="id" title="variable">q</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:24"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:26"><span class="id" title="variable">n</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#q:25"><span class="id" title="variable">q</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#m:27"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:24"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:26"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#q:25"><span class="id" title="variable">q</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#m:27"><span class="id" title="variable">m</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">xapp</span> <a class="idref" href="Basic.html#triple_incr_first'"><span class="id" title="lemma">triple_incr_first'</span></a>. <span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
More generally, in Separation Logic, if a specification triple holds, then
    this triple remains valid when we add the same heap predicate to both the
    precondition and the postcondition. This is the "frame" principle, a key
    modularity feature that we'll come back to later on in the course. 
</div>

<div class="doc">
<a id="lab24"></a><h2 class="section">Transfer from one Reference to Another</h2>

<div class="paragraph"> </div>

 Consider the <span class="inlinecode"><span class="id" title="var">transfer</span></span> function, whose code appears below. Recall that, to
    simplify the implementation of the framework used in the course, we need to
    write in A-normal form, assigning a name to every intermediate result. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="transfer" class="idref" href="#transfer"><span class="id" title="definition">transfer</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#bfe3f2ff4c10f23c7c7f24aa5367bca5"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a> <a class="idref" href="LibSepReference.html#bfe3f2ff4c10f23c7c7f24aa5367bca5"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''s'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''s'"><span class="id" title="notation">s</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#e0633f114fcb17e965cb872e30ce07a<sub>5</sub>"><span class="id" title="notation">:=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''s'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''s'"><span class="id" title="notation">s</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a> <a class="idref" href="LibSepReference.html#e0633f114fcb17e965cb872e30ce07a<sub>5</sub>"><span class="id" title="notation">:=</span></a> 0 <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
<a id="lab25"></a><h4 class="section">Exercise: 1 star, standard, especially useful (triple_transfer)</h4>
 State and prove a lemma called <span class="inlinecode"><span class="id" title="var">triple_transfer</span></span>, specifying the behavior of
    <span class="inlinecode"><span class="id" title="var">transfer</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">q</span></span> in the case where <span class="inlinecode"><span class="id" title="var">p</span></span> and <span class="inlinecode"><span class="id" title="var">q</span></span> denote two distinct references.
    
</div>
<div class="code">

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab26"></a><h4 class="section">Exercise: 1 star, standard, especially useful (triple_transfer_aliased)</h4>
 State and prove a lemma called <span class="inlinecode"><span class="id" title="var">triple_transfer_aliased</span></span> specifying the
    behavior of <span class="inlinecode"><span class="id" title="var">transfer</span></span> when it is applied twice to the same argument. It
    should take the form <span class="inlinecode"><span class="id" title="var">triple</span></span> <span class="inlinecode">(<span class="id" title="var">transfer</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">p</span>)</span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span>. 
</div>
<div class="code">

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab27"></a><h2 class="section">Specification of Allocation</h2>

<div class="paragraph"> </div>

 Consider the operation <span class="inlinecode"><span class="id" title="var">ref</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span>, which allocates a memory cell with contents
    <span class="inlinecode"><span class="id" title="var">v</span></span>. How can we specify this operation using a triple? The precondition of
    this triple should be the empty heap predicate, written <span class="inlinecode"><span class='gray-font'>\</span>[]</span>, because the
    allocation can execute in an empty state. The postcondition should assert
    that the output value is a pointer <span class="inlinecode"><span class="id" title="var">p</span></span>, such that the final state is
    described by <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">v</span></span>.

<div class="paragraph"> </div>

    It would be tempting to write the postcondition <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">v</span></span>. Yet, the
    triple would be ill-typed, because the postcondition of a triple must be a
    predicate over values, of type <span class="inlinecode"><span class="id" title="var">val</span></span> in the framework, whereas here <span class="inlinecode"><span class="id" title="var">p</span></span> is
    an address, of type <span class="inlinecode"><span class="id" title="var">loc</span></span>. We thus need to write the postcondition in the
    form <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode">(<span class="id" title="var">r</span>:<span class="id" title="var">val</span>)</span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">H'</span></span>, where <span class="inlinecode"><span class="id" title="var">r</span></span> denotes the result value, and somehow
    assert that <span class="inlinecode"><span class="id" title="var">r</span></span> is the value that corresponds to the location <span class="inlinecode"><span class="id" title="var">p</span></span>. This
    value is written <span class="inlinecode"><span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>, where <span class="inlinecode"><span class="id" title="var">val_loc</span></span> denotes the constructor that
    injects locations into the grammar of program values.

<div class="paragraph"> </div>

    To formally quantify the variable <span class="inlinecode"><span class="id" title="var">p</span></span>, we use the existential quantifier for
    heap predicates, written <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span>. The correct postcondition for <span class="inlinecode"><span class="id" title="var">ref</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> is
    thus <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode">(<span class="id" title="var">p</span>:<span class="id" title="var">loc</span>),</span> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">p</span>]</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">v</span>)</span>. The complete
    statement of the specification of <span class="inlinecode"><span class="id" title="var">ref</span></span> appears below. It is introduced as a
    <span class="inlinecode"><span class="id" title="keyword">Parameter</span></span> instead of a <span class="inlinecode"><span class="id" title="keyword">Lemma</span></span>, because the proof of the specification of
    this primitive operation is postponed to the chapter <a href="Rules.html"><span class="inlineref">Rules</span></a>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_ref" class="idref" href="#triple_ref"><span class="id" title="axiom">triple_ref</span></a> : <span class="id" title="keyword">∀</span> (<a id="v:28" class="idref" href="#v:28"><span class="id" title="binder">v</span></a>:<a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:'ref'"><span class="id" title="notation">ref</span></a> <a class="idref" href="Basic.html#v:28"><span class="id" title="variable">v</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:29" class="idref" href="#r:29"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="p:30" class="idref" href="#p:30"><span class="id" title="binder">p</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:29"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Basic.html#p:30"><span class="id" title="variable">p</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#p:30"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#v:28"><span class="id" title="variable">v</span></a>).<br/>
</div>

<div class="doc">
The pattern <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">p</span>,</span> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">p</span>]</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H</span>)</span> occurs whenever a
    function returns a pointer. To improve concision for this frequent pattern,
    we introduce a specific notation: <span class="inlinecode"><span class="id" title="var">funloc</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">H</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Notation</span> <a id="41749fe005eef2f7f0316a63bdabe5a<sub>8</sub>" class="idref" href="#41749fe005eef2f7f0316a63bdabe5a<sub>8</sub>"><span class="id" title="notation">&quot;</span></a>'funloc' p '=&gt;' H" :=<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> (<a id="r:32" class="idref" href="#r:32"><span class="id" title="binder">r</span></a>:<a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a>) ⇒ <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="p:33" class="idref" href="#p:33"><span class="id" title="binder">p</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:32"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <span class="id" title="var">p</span><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <span class="id" title="var">H</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 200, <span class="id" title="var">p</span> <span class="id" title="var">name</span>, <span class="id" title="var">format</span> "'funloc'  p  '=&gt;'  H").<br/>
</div>

<div class="doc">
Using this notation, the specification <span class="inlinecode"><span class="id" title="var">triple_ref</span></span> can be reformulated more
    concisely: 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_ref'" class="idref" href="#triple_ref'"><span class="id" title="axiom">triple_ref'</span></a> : <span class="id" title="keyword">∀</span> (<a id="v:34" class="idref" href="#v:34"><span class="id" title="binder">v</span></a>:<a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:'ref'"><span class="id" title="notation">ref</span></a> <a class="idref" href="Basic.html#v:34"><span class="id" title="variable">v</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#41749fe005eef2f7f0316a63bdabe5a<sub>8</sub>"><span class="id" title="notation">funloc</span></a> <a id="p:37" class="idref" href="#p:37"><span class="id" title="binder">p</span></a> <a class="idref" href="Basic.html#41749fe005eef2f7f0316a63bdabe5a<sub>8</sub>"><span class="id" title="notation">⇒</span></a> <a class="idref" href="Basic.html#p:35"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#v:34"><span class="id" title="variable">v</span></a>).<br/>
</div>

<div class="doc">
The CFML tool, which leverages techniques similar to those described in this
    course, leverages type-classes to generalize the notation <span class="inlinecode"><span class="id" title="var">funloc</span></span> to all
    return types. Here, in order to avoid technical difficulties associated with
    type-classes, we will not go for the general presentation, but instead
    exploit the <span class="inlinecode"><span class="id" title="var">funloc</span></span> notation, which is specific to the case where the
    return type is a location. For other types, we can quantify over the result
    value explicitly. 
</div>

<div class="doc">
<a id="lab28"></a><h2 class="section">Allocation of a Reference with Greater Contents</h2>

<div class="paragraph"> </div>

 Consider the function <span class="inlinecode"><span class="id" title="var">ref_greater</span></span>, which takes as argument the address <span class="inlinecode"><span class="id" title="var">p</span></span>
    of a memory cell with contents <span class="inlinecode"><span class="id" title="var">n</span></span>, allocates a fresh memory cell with
    contents <span class="inlinecode"><span class="id" title="var">n</span>+1</span>, and returns the address of that fresh cell. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="ref_greater" class="idref" href="#ref_greater"><span class="id" title="definition">ref_greater</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> 1 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'ref'"><span class="id" title="notation">ref</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
The precondition of <span class="inlinecode"><span class="id" title="var">ref_greater</span></span> asserts the existence of a cell <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>.
    The postcondition asserts the existence of two cells, <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> and
    <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>, where <span class="inlinecode"><span class="id" title="var">q</span></span> denotes the location returned by the function. The
    postcondition is thus written <span class="inlinecode"><span class="id" title="var">funloc</span></span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>, which is
    a shorthand for
    <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode">(<span class="id" title="var">r</span>:<span class="id" title="var">val</span>)</span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">q</span>,</span> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">q</span>]</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>. In
    the proof below, observe that the operation <span class="inlinecode"><span class="id" title="var">ref</span></span> is displayed as <span class="inlinecode"><span class="id" title="var">val_ref</span></span>,
    because this is the name of the operation in the internal abstrat syntax
    tree. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_ref_greater" class="idref" href="#triple_ref_greater"><span class="id" title="lemma">triple_ref_greater</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:39" class="idref" href="#p:39"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:40" class="idref" href="#n:40"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#ref_greater"><span class="id" title="definition">ref_greater</span></a> <a class="idref" href="Basic.html#p:39"><span class="id" title="variable">p</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:39"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:40"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#41749fe005eef2f7f0316a63bdabe5a<sub>8</sub>"><span class="id" title="notation">funloc</span></a> <a id="q:43" class="idref" href="#q:43"><span class="id" title="binder">q</span></a> <a class="idref" href="Basic.html#41749fe005eef2f7f0316a63bdabe5a<sub>8</sub>"><span class="id" title="notation">⇒</span></a> <a class="idref" href="Basic.html#p:39"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:40"><span class="id" title="variable">n</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#q:41"><span class="id" title="variable">q</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:40"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">q</span>. <span class="id" title="var">xsimpl</span>. <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab29"></a><h4 class="section">Exercise: 2 stars, standard, especially useful (triple_ref_greater_abstract)</h4>
 State another specification for the function <span class="inlinecode"><span class="id" title="var">ref_greater</span></span> with a
    postcondition that does not reveal the contents of the fresh reference <span class="inlinecode"><span class="id" title="var">q</span></span>,
    but instead only asserts that it is greater than the contents of <span class="inlinecode"><span class="id" title="var">p</span></span>. To
    that end, introduce in the postcondition an existentially quantified
    variable called <span class="inlinecode"><span class="id" title="var">m</span></span>, with <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. This new specification, to be called
    <span class="inlinecode"><span class="id" title="var">triple_ref_greater_abstract</span></span>, should be derived from <span class="inlinecode"><span class="id" title="var">triple_ref_greater</span></span>,
    following the proof pattern employed in <span class="inlinecode"><span class="id" title="var">triple_incr_first_derived</span></span>.

<div class="paragraph"> </div>

    Hint: Remember that the notation <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">P</span>]</span> injects a Coq proposition into the
    language of Separation Logic predicates. 
</div>
<div class="code">

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab30"></a><h2 class="section">The Power of the Frame Rule with Respect to Allocation</h2>

<div class="paragraph"> </div>

 Recall the specification <span class="inlinecode"><span class="id" title="var">triple_ref'</span></span>, which describes the behavior of an
    allocation of a memory cell with contents <span class="inlinecode"><span class="id" title="var">v</span></span>, performed at location <span class="inlinecode"><span class="id" title="var">p</span></span>.
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">Parameter</span> <span class="id" title="var">triple_ref'</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">v</span>:<span class="id" title="var">val</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">triple</span> &lt;{ <span class="id" title="var">ref</span> <span class="id" title="var">v</span> }&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class='gray-font'>\</span>[]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">funloc</span> <span class="id" title="var">p</span> ⇒ <span class="id" title="var">p</span> ~~&gt; <span class="id" title="var">v</span>).
</span>
<div class="paragraph"> </div>

 According to the frame rule presented in the preface, the above
    specification would remain valid if we extend the precondition and the
    postcondition with a heap predicate. Consider, for example, extending the
    precondition with the predicate <span class="inlinecode"><span class="id" title="var">p'</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">v'</span></span>. By doing so, we derive a lemma
    describing the behavior of the allocation of a cell at location <span class="inlinecode"><span class="id" title="var">p</span></span>,
    starting from a state that already contains a cell allocated at location
    <span class="inlinecode"><span class="id" title="var">p'</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_ref_with_frame" class="idref" href="#triple_ref_with_frame"><span class="id" title="axiom">triple_ref_with_frame</span></a> : <span class="id" title="keyword">∀</span> (<a id="p':44" class="idref" href="#p':44"><span class="id" title="binder">p'</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="v':45" class="idref" href="#v':45"><span class="id" title="binder">v'</span></a>:<a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a>) (<a id="v:46" class="idref" href="#v:46"><span class="id" title="binder">v</span></a>:<a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:'ref'"><span class="id" title="notation">ref</span></a> <a class="idref" href="Basic.html#v:46"><span class="id" title="variable">v</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p':44"><span class="id" title="variable">p'</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#v':45"><span class="id" title="variable">v'</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#41749fe005eef2f7f0316a63bdabe5a<sub>8</sub>"><span class="id" title="notation">funloc</span></a> <a id="p:49" class="idref" href="#p:49"><span class="id" title="binder">p</span></a> <a class="idref" href="Basic.html#41749fe005eef2f7f0316a63bdabe5a<sub>8</sub>"><span class="id" title="notation">⇒</span></a> <a class="idref" href="Basic.html#p:47"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#v:46"><span class="id" title="variable">v</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#p':44"><span class="id" title="variable">p'</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#v':45"><span class="id" title="variable">v'</span></a>).<br/>
</div>

<div class="doc">
The separating conjunction that appears in the above postcondition captures
    the fact that the location <span class="inlinecode"><span class="id" title="var">p</span></span> is distinct from <span class="inlinecode"><span class="id" title="var">p'</span></span>. As illustrated here,
    the frame rule indirectly captures the property that any piece of freshly
    allocated data is distinct from any piece of previously existing data. This
    property may seem obvious, but in the work on program verification prior to
    Separation Logic it was challenging to capture. 
</div>

<div class="doc">
<a id="lab31"></a><h2 class="section">Deallocation in Separation Logic</h2>

<div class="paragraph"> </div>

 Separation Logic, in its simplest form, enforces that every piece of
    allocated data is eventually deallocated. But OCaml is a programming
    language equipped with a garbage collector: programs do not contain explicit
    deallocation operations.

<div class="paragraph"> </div>

    Thus, concretely, if we consider an OCaml program that allocates a
    reference, and if this reference is not described in the postcondition, we
    get stuck in the proof. Let us see how we get stuck and what we can do about
    it. 
<div class="paragraph"> </div>

 To begin with, consider the function shown below. This function computes the
    successor of a integer <span class="inlinecode"><span class="id" title="var">n</span></span>. It does so using a reference: it first stores
    <span class="inlinecode"><span class="id" title="var">n</span></span> into a reference cell, then it increments that reference, and finally it
    returns the new contents of the reference. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="succ_using_incr_attempt" class="idref" href="#succ_using_incr_attempt"><span class="id" title="definition">succ_using_incr_attempt</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:'ref'"><span class="id" title="notation">ref</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basic.html#incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
A call to that function can be specified using an empty precondition and a
    postcondition asserting that the final result is equal to <span class="inlinecode"><span class="id" title="var">n</span>+1</span>. The
    postcondition has no reason to mention the reference used internally by the
    function. But we get stuck on the last step when trying to prove this
    specification. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_succ_using_incr_attempt" class="idref" href="#triple_succ_using_incr_attempt"><span class="id" title="lemma">triple_succ_using_incr_attempt</span></a> : <span class="id" title="keyword">∀</span> (<a id="n:51" class="idref" href="#n:51"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#succ_using_incr_attempt"><span class="id" title="definition">succ_using_incr_attempt</span></a> <a class="idref" href="Basic.html#n:51"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:52" class="idref" href="#r:52"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:52"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#n:51"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>. { <span class="id" title="tactic">auto</span>. }<br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
We get stuck with the unprovable entailment <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class='gray-font'>\</span>[]</span>, where the
    left-hand side describes a state with one reference, whereas the right-hand
    side describes an empty state. There are three possibilities to work around
    the issue. 
<div class="paragraph"> </div>

 The first possibility consists of extending the postcondition to account for
    the existence of the reference <span class="inlinecode"><span class="id" title="var">p</span></span>. This yields a provable specification. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_succ_using_incr_attempt'" class="idref" href="#triple_succ_using_incr_attempt'"><span class="id" title="lemma">triple_succ_using_incr_attempt'</span></a> : <span class="id" title="keyword">∀</span> (<a id="n:53" class="idref" href="#n:53"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#succ_using_incr_attempt"><span class="id" title="definition">succ_using_incr_attempt</span></a> <a class="idref" href="Basic.html#n:53"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:54" class="idref" href="#r:54"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:54"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#n:53"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="p:55" class="idref" href="#p:55"><span class="id" title="binder">p</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#p:55"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:53"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>. { <span class="id" title="tactic">auto</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
However, while the specification above is provable, it is pretty
    unsatisfying. The postcondition <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">p</span>,</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span> is of absolutely no
    use to the caller of the function. Worse, the caller will get its own heap
    predicate polluted with <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">p</span>,</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>, with no way of throwing
    away this predicate. 
<div class="paragraph"> </div>

 A second solution is to alter the code to include an explicit free
    operation, written <span class="inlinecode"><span class="id" title="var">free</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>, for deallocating the reference. This operation
    does not exist in OCaml, but let us nevertheless assume it to be able to
    demonstrate how Separation Logic supports reasoning about explicit
    deallocation. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="succ_using_incr" class="idref" href="#succ_using_incr"><span class="id" title="definition">succ_using_incr</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:'ref'"><span class="id" title="notation">ref</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basic.html#incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">x</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'free'"><span class="id" title="notation">free</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">x</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
This program may be proved correct with respect to the intended
    postcondition <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span>+1]</span>, without the need to mention <span class="inlinecode"><span class="id" title="var">p</span></span>. In the
    proof below, the key step is the last call to <span class="inlinecode"><span class="id" title="var">xapp</span></span>. This call is for
    reasoning about the operation <span class="inlinecode"><span class="id" title="var">free</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>, which consumes the heap predicate
    <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">_</span></span>. At the last proof step, we invoke the tactic <span class="inlinecode"><span class="id" title="var">xval</span></span> for reasoning
    about the return value. When applied to a piece of code that consists of a
    value <span class="inlinecode"><span class="id" title="var">v</span></span>, in a precondition <span class="inlinecode"><span class="id" title="var">H</span></span> and a postcondition <span class="inlinecode"><span class="id" title="var">Q</span></span>, <span class="inlinecode"><span class="id" title="var">xval</span></span> transforms
    the goal into <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span>, which asserts that the current state matches the
    state described by the postcondition, for the return value at hand. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_succ_using_incr" class="idref" href="#triple_succ_using_incr"><span class="id" title="lemma">triple_succ_using_incr</span></a> : <span class="id" title="keyword">∀</span> <a id="n:56" class="idref" href="#n:56"><span class="id" title="binder">n</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#succ_using_incr"><span class="id" title="definition">succ_using_incr</span></a> <a class="idref" href="Basic.html#n:56"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:57" class="idref" href="#r:57"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:57"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#n:56"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xapp</span>. <span class="comment">(*&nbsp;reasoning&nbsp;about&nbsp;the&nbsp;call&nbsp;<span class="inlinecode"><span class="id" title="var">free</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="var">xval</span>. <span class="comment">(*&nbsp;reasoning&nbsp;about&nbsp;the&nbsp;return&nbsp;value,&nbsp;named&nbsp;<span class="inlinecode"><span class="id" title="var">r</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="var">xsimpl</span>. <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The third solution for handling garbage collection involves a generalized
    version of Separation Logic in which specific classes of heap predicates may
    be freely discarded from the current state, at any point during a proof.
    This variant is described in the chapter <a href="Affine.html"><span class="inlineref">Affine</span></a>. For the moment, we
    will keep assuming a language equipped with <span class="inlinecode"><span class="id" title="var">free</span></span>. 
</div>

<div class="doc">
<a id="lab32"></a><h2 class="section">Combined Reading and Freeing of a Reference</h2>

<div class="paragraph"> </div>

 The function <span class="inlinecode"><span class="id" title="var">get_and_free</span></span> takes as argument the address <span class="inlinecode"><span class="id" title="var">p</span></span> of a reference
    cell. It reads the contents of that cell, frees the cell, and returns its
    contents. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="get_and_free" class="idref" href="#get_and_free"><span class="id" title="definition">get_and_free</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''v'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''v'"><span class="id" title="notation">v</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'free'"><span class="id" title="notation">free</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''v'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''v'"><span class="id" title="notation">v</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
<a id="lab33"></a><h4 class="section">Exercise: 2 stars, standard, especially useful (triple_get_and_free)</h4>
 Prove the correctness of the function <span class="inlinecode"><span class="id" title="var">get_and_free</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_get_and_free" class="idref" href="#triple_get_and_free"><span class="id" title="lemma">triple_get_and_free</span></a> : <span class="id" title="keyword">∀</span> <a id="p:58" class="idref" href="#p:58"><span class="id" title="binder">p</span></a> <a id="v:59" class="idref" href="#v:59"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#get_and_free"><span class="id" title="definition">get_and_free</span></a> <a class="idref" href="Basic.html#p:58"><span class="id" title="variable">p</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:58"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#v:59"><span class="id" title="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:60" class="idref" href="#r:60"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:60"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#v:59"><span class="id" title="variable">v</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="code">

#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Resolve</span> <span class="id" title="var">triple_get_and_free</span> : <span class="id" title="var">triple</span>.<br/>
</div>

<div class="doc">
<a id="lab34"></a><h2 class="section">Nondeterminism: Specifying Random Output Values</h2>

<div class="paragraph"> </div>

 Given a positive integer <span class="inlinecode"><span class="id" title="var">n</span></span>, the primitive operation <span class="inlinecode"><span class="id" title="var">val_rand</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> returns
    an integer in the range <span class="inlinecode">0</span> inclusive to <span class="inlinecode"><span class="id" title="var">n</span></span> exclusive. This operation may
    be specified by the following triple, which asserts that the output value
    <span class="inlinecode"><span class="id" title="var">r</span></span> is an integer <span class="inlinecode"><span class="id" title="var">m</span></span> satisfying <span class="inlinecode">0</span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_rand" class="idref" href="#triple_rand"><span class="id" title="axiom">triple_rand</span></a> : <span class="id" title="keyword">∀</span> <a id="n:61" class="idref" href="#n:61"><span class="id" title="binder">n</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#n:61"><span class="id" title="variable">n</span></a> <span class="id" title="notation">&gt;</span> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="LibSepReference.html#val_rand"><span class="id" title="constructor">val_rand</span></a> <a class="idref" href="Basic.html#n:61"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:62" class="idref" href="#r:62"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="m:63" class="idref" href="#m:63"><span class="id" title="binder">m</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:62"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> <a class="idref" href="Basic.html#m:63"><span class="id" title="variable">m</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a>0 <span class="id" title="notation">≤</span> <a class="idref" href="Basic.html#m:63"><span class="id" title="variable">m</span></a> <span class="id" title="notation">&lt;</span> <a class="idref" href="Basic.html#n:61"><span class="id" title="variable">n</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
</div>

<div class="doc">
Consider the function <span class="inlinecode"><span class="id" title="var">two_dice</span></span>, which simulates the throw of two dice and
    returns their sum. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="two_dice" class="idref" href="#two_dice"><span class="id" title="definition">two_dice</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''u'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''u'"><span class="id" title="notation">u</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n<sub>1</sub>'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n<sub>1</sub>'"><span class="id" title="notation">n<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_rand"><span class="id" title="constructor">val_rand</span></a> 6 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n<sub>2</sub>'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n<sub>2</sub>'"><span class="id" title="notation">n<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_rand"><span class="id" title="constructor">val_rand</span></a> 6 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''s'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''s'"><span class="id" title="notation">s</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n<sub>1</sub>'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n<sub>1</sub>'"><span class="id" title="notation">n<sub>1</sub></span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n<sub>2</sub>'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n<sub>2</sub>'"><span class="id" title="notation">n<sub>2</sub></span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''s'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''s'"><span class="id" title="notation">s</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> 2 <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
<a id="lab35"></a><h4 class="section">Exercise: 2 stars, standard, optional (triple_two_dice)</h4>
 Prove the correctness of the function <span class="inlinecode"><span class="id" title="var">two_dice</span></span>. Hint: you'll need to use
    <span class="inlinecode"><span class="id" title="var">xapp</span></span> <span class="inlinecode"><span class="id" title="var">triple_rand</span></span>, because <span class="inlinecode"><span class="id" title="var">xapp</span></span> is not able to discharge the
    side-condition <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;</span> <span class="inlinecode">0</span> automatically. Use <span class="inlinecode"><span class="id" title="var">math</span></span> for handling arithmetic
    proof obligations. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_two_dice" class="idref" href="#triple_two_dice"><span class="id" title="lemma">triple_two_dice</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="Basic.html#two_dice"><span class="id" title="definition">two_dice</span></a> <a class="idref" href="LibSepReference.html#71337baa9b3f1f61552031a8e9cb9237"><span class="id" title="notation">()</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:65" class="idref" href="#r:65"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="n:66" class="idref" href="#n:66"><span class="id" title="binder">n</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:65"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_int"><span class="id" title="constructor">val_int</span></a> <a class="idref" href="Basic.html#n:66"><span class="id" title="variable">n</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a>2 <span class="id" title="notation">≤</span> <a class="idref" href="Basic.html#n:66"><span class="id" title="variable">n</span></a> <span class="id" title="notation">≤</span> 12<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab36"></a><h1 class="section">Recursive Functions</h1>

</div>
<div class="code">

<span class="comment">(*&nbsp;#####################LeadingDash######## *)</span><br/>
</div>

<div class="doc">
<a id="lab37"></a><h2 class="section">Axiomatization of the Mathematical Factorial Function</h2>

<div class="paragraph"> </div>

 Our next example consists of a program that evaluates the factorial
    function. To specify this function, we consider a Coq axiomatization of the
    mathematical factorial function, named <span class="inlinecode"><span class="id" title="var">facto</span></span>. We wrap the axiomatization
    inside a module, so that we can later refer to it from other files. 
</div>
<div class="code">

<span class="id" title="keyword">Module</span> <a id="Facto" class="idref" href="#Facto"><span class="id" title="module">Facto</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Parameter</span> <a id="Facto.facto" class="idref" href="#Facto.facto"><span class="id" title="axiom">facto</span></a> : <span class="id" title="notation">int</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="notation">int</span>.<br/>
</div>

<div class="doc">
The factorial of <span class="inlinecode">0</span> and <span class="inlinecode">1</span> is equal to <span class="inlinecode">1</span>, and the factorial of <span class="inlinecode"><span class="id" title="var">n</span></span> for
    <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;</span> <span class="inlinecode">1</span> is equal to <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">facto</span></span> <span class="inlinecode">(<span class="id" title="var">n</span>-1)</span>. Note that we purposely leave
    unspecified the value of <span class="inlinecode"><span class="id" title="var">facto</span></span> on negative arguments. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="Facto.facto_init" class="idref" href="#Facto.facto_init"><span class="id" title="axiom">facto_init</span></a> : <span class="id" title="keyword">∀</span> <a id="n:68" class="idref" href="#n:68"><span class="id" title="binder">n</span></a>,<br/>
&nbsp;&nbsp;0 <span class="id" title="notation">≤</span> <a class="idref" href="Basic.html#n:68"><span class="id" title="variable">n</span></a> <span class="id" title="notation">≤</span> 1 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#Facto.facto"><span class="id" title="axiom">facto</span></a> <a class="idref" href="Basic.html#n:68"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 1.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Parameter</span> <a id="Facto.facto_step" class="idref" href="#Facto.facto_step"><span class="id" title="axiom">facto_step</span></a> : <span class="id" title="keyword">∀</span> <a id="n:70" class="idref" href="#n:70"><span class="id" title="binder">n</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#n:70"><span class="id" title="variable">n</span></a> <span class="id" title="notation">≥</span> 1 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#Facto.facto"><span class="id" title="axiom">facto</span></a> <a class="idref" href="Basic.html#n:70"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#n:70"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#d3ea1afb7d81263dc23c4eb0da2a3c4e"><span class="id" title="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#d3ea1afb7d81263dc23c4eb0da2a3c4e"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#Facto.facto"><span class="id" title="axiom">facto</span></a> (<a class="idref" href="Basic.html#n:70"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#::Z_scope:x_'-'_x"><span class="id" title="notation">-</span></a>1)<a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#d3ea1afb7d81263dc23c4eb0da2a3c4e"><span class="id" title="notation">)</span></a>.<br/>
</div>

<div class="doc">
Sometimes it is more convenient to simplify the value of an expression of
    the form <span class="inlinecode"><span class="id" title="var">facto</span></span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>, as captured by the following lemma. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="Facto.facto_succ" class="idref" href="#Facto.facto_succ"><span class="id" title="lemma">facto_succ</span></a> : <span class="id" title="keyword">∀</span> <a id="i:72" class="idref" href="#i:72"><span class="id" title="binder">i</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#i:72"><span class="id" title="variable">i</span></a> <span class="id" title="notation">≥</span> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#Facto.facto"><span class="id" title="axiom">facto</span></a> (<a class="idref" href="Basic.html#i:72"><span class="id" title="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> 1) <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#d3ea1afb7d81263dc23c4eb0da2a3c4e"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#i:72"><span class="id" title="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> 1<a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#d3ea1afb7d81263dc23c4eb0da2a3c4e"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#d3ea1afb7d81263dc23c4eb0da2a3c4e"><span class="id" title="notation">*</span></a> <a class="idref" href="Basic.html#Facto.facto"><span class="id" title="axiom">facto</span></a> <a class="idref" href="Basic.html#i:72"><span class="id" title="variable">i</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">Hi</span>. <span class="id" title="tactic">rewrite</span> (@<a class="idref" href="Basic.html#Facto.facto_step"><span class="id" title="axiom">facto_step</span></a> (<span class="id" title="var">i</span><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1)). <span class="id" title="tactic">f_equal</span>. <span class="id" title="tactic">f_equal</span>. <span class="id" title="var">math</span>. <span class="id" title="var">math</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Basic.html#Facto"><span class="id" title="module">Facto</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Import</span> <a class="idref" href="Basic.html#Facto"><span class="id" title="module">Facto</span></a>.<br/>
</div>

<div class="doc">
<a id="lab38"></a><h2 class="section">A Partial Recursive Function, Without State</h2>

<div class="paragraph"> </div>

 As a warm-up, we first consider consider a recursive function that does not
    involve any mutable state. The program function <span class="inlinecode"><span class="id" title="var">factorec</span></span> computes the
    factorial of its argument: it implements the logical function <span class="inlinecode"><span class="id" title="var">facto</span></span>.

<div class="paragraph"> </div>

<span class="inlinecode-ocaml">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="keyword">rec</span> <span class="id" title="var">factorec</span> <span class="id" title="var">n</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">n</span> ≤ 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">n</span> * <span class="id" title="var">factorec</span> (<span class="id" title="var">n</span>-1)
</span>
<div class="paragraph"> </div>

    The corresponding code in A-normal form is slightly more verbose. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="factorec" class="idref" href="#factorec"><span class="id" title="definition">factorec</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#7809db93a49fc4341c1251bb4de79a<sub>62</sub>"><span class="id" title="notation">fix</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">f</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#7809db93a49fc4341c1251bb4de79a<sub>62</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#9ff281c3872a35aaa31aa0ff16f0b827"><span class="id" title="notation">≤</span></a> 1 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'else'_x"><span class="id" title="notation">if</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'else'_x"><span class="id" title="notation">then</span></a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'else'_x"><span class="id" title="notation">else</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">x</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:x_'-'_x"><span class="id" title="notation">-</span></a> 1 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''y'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''y'"><span class="id" title="notation">y</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">f</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">x</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#8687bd0de562fa8820387e422eed2db<sub>3</sub>"><span class="id" title="notation">*</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''y'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''y'"><span class="id" title="notation">y</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
A call to <span class="inlinecode"><span class="id" title="var">factorec</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> can be specified as follows:

<div class="paragraph"> </div>

<ul class="doclist">
<li> the initial state is empty,

</li>
<li> the final state is empty,

</li>
<li> the result value <span class="inlinecode"><span class="id" title="var">r</span></span> is such that <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">facto</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, when <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0</span>.

</li>
</ul>

<div class="paragraph"> </div>

    In case <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode">0</span>, we have two choices:

<div class="paragraph"> </div>

<ul class="doclist">
<li> either we explicitly specify that the result is <span class="inlinecode">1</span> in this case,

</li>
<li> or we rule out this possibility by requiring <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0</span>.

</li>
</ul>

<div class="paragraph"> </div>

    Let us follow the second approach, in order to illustrate the specification
    of partial functions.

<div class="paragraph"> </div>

    There are two possibilities for expressing the constraint <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0</span>:

<div class="paragraph"> </div>

<ul class="doclist">
<li> either we use as precondition <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">n</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0]</span>,

</li>
<li> or we we use the empty precondition, that is, <span class="inlinecode"><span class='gray-font'>\</span>[]</span>, and we place an
      assumption <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0)</span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">_</span></span> at the front of the triple.

</li>
</ul>

<div class="paragraph"> </div>

    The two presentations are formally equivalent, but we prefer the second,
    which tends to improve both the readability of specifications and the
    conciseness of proof scripts. In that style, the specification of <span class="inlinecode"><span class="id" title="var">factorec</span></span>
    is stated as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_factorec" class="idref" href="#triple_factorec"><span class="id" title="lemma">triple_factorec</span></a> : <span class="id" title="keyword">∀</span> <a id="n:73" class="idref" href="#n:73"><span class="id" title="binder">n</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#n:73"><span class="id" title="variable">n</span></a> <span class="id" title="notation">≥</span> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#factorec"><span class="id" title="definition">factorec</span></a> <a class="idref" href="Basic.html#n:73"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:74" class="idref" href="#r:74"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:74"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#facto"><span class="id" title="axiom">facto</span></a> <a class="idref" href="Basic.html#n:73"><span class="id" title="variable">n</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
</div>

<div class="doc">
In general, we prove specifications for recursive functions by exploiting a
    strong induction principle statement ("well-founded induction") that allows
    us to assume, while we try to prove the specification, that the
    specification already holds for any "smaller input". The (well-founded)
    order relation that defines whether an input is smaller than another one is
    specified by the user. In the present example of <span class="inlinecode"><span class="id" title="var">factorec</span></span>, we use the
    well-founded relation <span class="inlinecode"><span class="id" title="var">downto</span></span> <span class="inlinecode">0</span>, where <span class="inlinecode"><span class="id" title="var">downto</span></span> <span class="inlinecode">0</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> asserts that
    <span class="inlinecode">0</span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Let's walk through the proof script in detail, to see how to set up the
    induction, how we exploit it for reasoning about the recursive call, and how
    we justify that the recursive call is made on a smaller input. 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
</div>

<div class="doc">
We set up a proof by induction on <span class="inlinecode"><span class="id" title="var">n</span></span> to obtain an induction hypothesis for
    the recursive calls. The tactic <span class="inlinecode"><span class="id" title="var">induction_wf</span></span>, provided by the TLC library,
    helps setting up well-founded inductions. Its usage is
    <span class="inlinecode"><span class="id" title="var">induction_wf</span></span> <span class="inlinecode"><span class="id" title="var">IH</span>:</span> <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>, where <span class="inlinecode"><span class="id" title="var">R</span></span> denotes a well-founded relation, <span class="inlinecode"><span class="id" title="var">x</span></span> is
    the name of a variable, and <span class="inlinecode"><span class="id" title="var">IH</span></span> is the name assigned to the induction
    hypothesis. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="var">induction_wf</span> <span class="id" title="var">IH</span>: (<span class="id" title="definition">downto</span> 0) <span class="id" title="var">n</span>.<br/>
</div>

<div class="doc">
Observe the induction hypothesis <span class="inlinecode"><span class="id" title="var">IH</span></span>. By unfolding <span class="inlinecode"><span class="id" title="var">downto</span></span> as in the next
    step, we can see that this hypothesis asserts that, given the current
    argument <span class="inlinecode"><span class="id" title="var">n</span></span>, the specification of <span class="inlinecode"><span class="id" title="var">factorec</span></span> can be exploited for any <span class="inlinecode"><span class="id" title="var">m</span></span>
    such that <span class="inlinecode">0</span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="definition">downto</span> <span class="id" title="keyword">in</span> <span class="id" title="var">IH</span>. <span class="comment">(*&nbsp;optional&nbsp;*)</span><br/>
</div>

<div class="doc">
We may then begin the interactive verification proof. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">Hn</span>. <span class="id" title="var">xwp</span>.<br/>
</div>

<div class="doc">
We reason about the evaluation of the boolean condition <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">1</span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">xapp</span>.<br/>
</div>

<div class="doc">
The result of the evaluation of <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">1</span> in the source program is described
    by the boolean value <span class="inlinecode"><span class="id" title="var">isTrue</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">1)</span>, which appears in the <span class="inlinecode"><span class="id" title="var">CODE</span></span> section
    after <span class="inlinecode"><span class="id" title="var">Ifval</span></span>. The operation <span class="inlinecode"><span class="id" title="var">isTrue</span></span> is provided by the TLC library as a
    conversion function from <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> to <span class="inlinecode"><span class="id" title="var">bool</span></span>. The use of such a conversion
    function (which leverages classical logic) greatly simplifies the process of
    automatically performing substitutions after calls to <span class="inlinecode"><span class="id" title="var">xapp</span></span>.  We next perform the case analysis on the test <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">1</span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">xif</span>.<br/>
</div>

<div class="doc">
Doing so gives two cases.  In the "then" branch, we can assume <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">1</span>. 
</div>
<div class="code">
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">C</span>.<br/>
</div>

<div class="doc">
Here, the return value is <span class="inlinecode">1</span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">xval</span>. <span class="id" title="var">xsimpl</span>.<br/>
</div>

<div class="doc">
We check that <span class="inlinecode">1</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">facto</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> when <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">1</span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Basic.html#facto_init"><span class="id" title="axiom">facto_init</span></a>. <span class="id" title="var">math</span>. <span class="id" title="var">math</span>. }<br/>
</div>

<div class="doc">
In the "else" branch, we can assume <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;</span> <span class="inlinecode">1</span>. 
</div>
<div class="code">
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">C</span>.<br/>
</div>

<div class="doc">
We reason about the evaluation of <span class="inlinecode"><span class="id" title="var">n</span>-1</span> 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">xapp</span>.<br/>
</div>

<div class="doc">
We reason about the recursive call, implicitly exploiting the induction
    hypothesis <span class="inlinecode"><span class="id" title="var">IH</span></span> with <span class="inlinecode"><span class="id" title="var">n</span>-1</span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">xapp</span>.<br/>
</div>

<div class="doc">
We justify that the recursive call is indeed made on a smaller argument than
    the current one, that is, a nonnegative integer smaller than <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">math</span>. }<br/>
</div>

<div class="doc">
We justify that the recursive call is also made on a nonnegative argument,
    as required by the specification. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">math</span>. }<br/>
</div>

<div class="doc">
We reason about the multiplication <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">facto</span>(<span class="id" title="var">n</span>-1)</span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">xapp</span>.<br/>
</div>

<div class="doc">
We check that <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">facto</span></span> <span class="inlinecode">(<span class="id" title="var">n</span>-1)</span> matches <span class="inlinecode"><span class="id" title="var">facto</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">xsimpl</span>. <span class="id" title="tactic">rewrite</span> (@<a class="idref" href="Basic.html#facto_step"><span class="id" title="axiom">facto_step</span></a> <span class="id" title="var">n</span>). <span class="id" title="var">math</span>. <span class="id" title="var">math</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
This completes our first proof of a recursive function. Further on, we will
    investigate a proof of an imperative implementation of a factorial function.
    
</div>

<div class="doc">
<a id="lab39"></a><h2 class="section">A Recursive Function with State</h2>

<div class="paragraph"> </div>

 Let's now tackle a recursive function involving some mutable state. The
    function <span class="inlinecode"><span class="id" title="var">repeat_incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> makes, <span class="inlinecode"><span class="id" title="var">m</span></span> times, a call to <span class="inlinecode"><span class="id" title="var">incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>, where <span class="inlinecode"><span class="id" title="var">m</span></span>
    is assumed to be nonnegative.

<div class="paragraph"> </div>

<span class="inlinecode-ocaml">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="keyword">rec</span> <span class="id" title="var">repeat_incr</span> <span class="id" title="var">p</span> <span class="id" title="var">m</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">m</span> &gt; 0 <span class="id" title="keyword">then</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">incr</span> <span class="id" title="var">p</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">repeat_incr</span> <span class="id" title="var">p</span> (<span class="id" title="var">m</span> - 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
</span> 
<div class="paragraph"> </div>

 In the concrete syntax for programs, conditionals without an 'else' branch
    are written <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> <span class="inlinecode"><span class="id" title="keyword">end</span></span>. The keyword <span class="inlinecode"><span class="id" title="keyword">end</span></span> avoids ambiguities in
    cases where this construct is followed by a semicolon. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="repeat_incr" class="idref" href="#repeat_incr"><span class="id" title="definition">repeat_incr</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#06de39bf13088f4f90583983ce65e722"><span class="id" title="notation">fix</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">f</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#06de39bf13088f4f90583983ce65e722"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:x_'&gt;'_x"><span class="id" title="notation">&gt;</span></a> 0 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'end'"><span class="id" title="notation">if</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'end'"><span class="id" title="notation">then</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basic.html#incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">x</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:x_'-'_x"><span class="id" title="notation">-</span></a> 1 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">f</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">x</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'end'"><span class="id" title="notation">end</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
The specification for <span class="inlinecode"><span class="id" title="var">repeat_incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> requires that the initial state
    contains a reference <span class="inlinecode"><span class="id" title="var">p</span></span> with some integer contents <span class="inlinecode"><span class="id" title="var">n</span></span>, that is, <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>.
    Its postcondition asserts that the resulting state is <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+<span class="id" title="var">m</span>)</span>, which
    is the result after incrementing, <span class="inlinecode"><span class="id" title="var">m</span></span> times, the reference <span class="inlinecode"><span class="id" title="var">p</span></span>. Observe that
    this postcondition is only valid under the assumption that <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0</span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_repeat_incr" class="idref" href="#triple_repeat_incr"><span class="id" title="lemma">triple_repeat_incr</span></a> : <span class="id" title="keyword">∀</span> (<a id="m:75" class="idref" href="#m:75"><span class="id" title="binder">m</span></a> <a id="n:76" class="idref" href="#n:76"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>) (<a id="p:77" class="idref" href="#p:77"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#m:75"><span class="id" title="variable">m</span></a> <span class="id" title="notation">≥</span> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#repeat_incr"><span class="id" title="definition">repeat_incr</span></a> <a class="idref" href="Basic.html#p:77"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#m:75"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:77"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:76"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:77"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:76"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> <a class="idref" href="Basic.html#m:75"><span class="id" title="variable">m</span></a><a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
</div>

<div class="doc">
<a id="lab40"></a><h4 class="section">Exercise: 2 stars, standard, especially useful (triple_repeat_incr)</h4>
 Prove the specification of the function <span class="inlinecode"><span class="id" title="var">repeat_incr</span></span>, by following the
    template of the proof of <span class="inlinecode"><span class="id" title="var">triple_factorec'</span></span>.

<div class="paragraph"> </div>

    Hint: begin the proof with <span class="inlinecode"><span class="id" title="tactic">intros</span></span> <span class="inlinecode"><span class="id" title="var">m</span>.</span> <span class="inlinecode"><span class="id" title="var">induction_wf</span></span> <span class="inlinecode"><span class="id" title="var">IH</span>:</span> <span class="inlinecode">...</span>, without
    introducing <span class="inlinecode"><span class="id" title="var">n</span></span> or <span class="inlinecode"><span class="id" title="var">p</span></span>, otherwise the induction principle obtained is too
    weak. 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 In the previous examples of recursive functions, the induction was always
    performed on the first argument quantified in the specification. When the
    decreasing argument is not the first one, additional manipulations are
    required for re-generalizing into the goal the variables that may change
    during the course of the induction. Here is an example illustrating how to
    deal with such a situation. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_repeat_incr'" class="idref" href="#triple_repeat_incr'"><span class="id" title="lemma">triple_repeat_incr'</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:78" class="idref" href="#p:78"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:79" class="idref" href="#n:79"><span class="id" title="binder">n</span></a> <a id="m:80" class="idref" href="#m:80"><span class="id" title="binder">m</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#m:80"><span class="id" title="variable">m</span></a> <span class="id" title="notation">≥</span> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#repeat_incr"><span class="id" title="definition">repeat_incr</span></a> <a class="idref" href="Basic.html#p:78"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#m:80"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:78"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:79"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:78"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:79"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> <a class="idref" href="Basic.html#m:80"><span class="id" title="variable">m</span></a><a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
</div>

<div class="doc">
First, we introduce all variables and hypotheses. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">p</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">Hm</span>.<br/>
</div>

<div class="doc">
Next, we generalize variables and hypotheses that are not constant during
    the recursion, using the TLC tactic <span class="inlinecode"><span class="id" title="var">gen</span></span>, which is similar to Coq's tactics
    <span class="inlinecode"><span class="id" title="var">revert</span></span> and <span class="inlinecode"><span class="id" title="tactic">dependent</span></span> <span class="inlinecode"><span class="id" title="tactic">generalize</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">gen</span> <span class="id" title="var">n</span> <span class="id" title="var">Hm</span>.<br/>
</div>

<div class="doc">
Then, we set up the induction. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">induction_wf</span> <span class="id" title="var">IH</span>: (<span class="id" title="definition">downto</span> 0) <span class="id" title="var">m</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="definition">downto</span> <span class="id" title="keyword">in</span> <span class="id" title="var">IH</span>.<br/>
</div>

<div class="doc">
Finally, we re-introduce the generalized hypotheses. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
</div>

<div class="doc">
The rest of the proof is exactly the same as before. 
</div>
<div class="code">
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
<a id="lab41"></a><h2 class="section">Trying to Prove Incorrect Specifications</h2>

<div class="paragraph"> </div>

 We established for <span class="inlinecode"><span class="id" title="var">repeat_incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> a specification featuring the
    hypothesis <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0</span>, but what if we had omitted this hypothesis? At which
    step would we get stuck in the proof? What feedback would we get at that
    point?

<div class="paragraph"> </div>

    Certainly, we expect the proof to get stuck if <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode">0</span>. Indeed, in this
    case, the call to <span class="inlinecode"><span class="id" title="var">repeat_incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> terminates immediately, so the final
    state is <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>, like the initial state, and the final state does not
    match the claimed postcondition <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>. Let us investigate how the
    proof of lemma <span class="inlinecode"><span class="id" title="var">triple_repeat_incr</span></span> breaks. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_repeat_incr_incorrect" class="idref" href="#triple_repeat_incr_incorrect"><span class="id" title="lemma">triple_repeat_incr_incorrect</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:81" class="idref" href="#p:81"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:82" class="idref" href="#n:82"><span class="id" title="binder">n</span></a> <a id="m:83" class="idref" href="#m:83"><span class="id" title="binder">m</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#repeat_incr"><span class="id" title="definition">repeat_incr</span></a> <a class="idref" href="Basic.html#p:81"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#m:83"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:81"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:82"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:81"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:82"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> <a class="idref" href="Basic.html#m:83"><span class="id" title="variable">m</span></a><a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">gen</span> <span class="id" title="var">n</span>. <span class="id" title="var">induction_wf</span> <span class="id" title="var">IH</span>: (<span class="id" title="definition">downto</span> 0) <span class="id" title="var">m</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="definition">downto</span> <span class="id" title="keyword">in</span> <span class="id" title="var">IH</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xif</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">C</span>.<br/>
&nbsp;&nbsp;{ <span class="comment">(*&nbsp;In&nbsp;the&nbsp;'then'&nbsp;branch:&nbsp;<span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&gt;</span> <span class="inlinecode">0</span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. { <span class="id" title="var">math</span>. } <span class="id" title="var">xsimpl</span>. <span class="id" title="var">math</span>. }<br/>
&nbsp;&nbsp;{ <span class="comment">(*&nbsp;In&nbsp;the&nbsp;'else'&nbsp;branch:&nbsp;<span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">0</span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">xval</span>.<br/>
</div>

<div class="doc">
At this point, we are requested to justify that the current state <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>
    matches the postcondition <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>, which amounts to proving
    <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
When the specification includes the assumption <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0</span>, we can prove this
    equality because the fact that we are in the else branch means that
    <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">0</span>, thus <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>. However, without the assumption <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0</span>, the value
    of <span class="inlinecode"><span class="id" title="var">m</span></span> could very well be negative. In that case, the equality <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span>
    is unprovable. As users, the proof obligation <span class="inlinecode">(<span class="id" title="var">m</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">0)</span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>
    gives us a very strong hint that either the code or the specification is not
    handling the case <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode">0</span> properly.

<div class="paragraph"> </div>

    This concludes our example attempt at proving an incorrect specification. 
<div class="paragraph"> </div>

 There exists a valid specification for <span class="inlinecode"><span class="id" title="var">repeat_incr</span></span> that does not constrain
    <span class="inlinecode"><span class="id" title="var">m</span></span> but instead specifies that, regardless of the value of <span class="inlinecode"><span class="id" title="var">m</span></span>, the state
    evolves from <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> to <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">max</span></span> <span class="inlinecode">0</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>. The corresponding proof
    script exploits two characteristic properties of the function <span class="inlinecode"><span class="id" title="var">max</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="max_l" class="idref" href="#max_l"><span class="id" title="lemma">max_l</span></a> : <span class="id" title="keyword">∀</span> <a id="n:84" class="idref" href="#n:84"><span class="id" title="binder">n</span></a> <a id="m:85" class="idref" href="#m:85"><span class="id" title="binder">m</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#n:84"><span class="id" title="variable">n</span></a> <span class="id" title="notation">≥</span> <a class="idref" href="Basic.html#m:85"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<span class="id" title="definition">max</span> <a class="idref" href="Basic.html#n:84"><span class="id" title="variable">n</span></a> <a class="idref" href="Basic.html#m:85"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#n:84"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="definition">max</span>. <span class="id" title="var">case_if</span>; <span class="id" title="var">math</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="max_r" class="idref" href="#max_r"><span class="id" title="lemma">max_r</span></a> : <span class="id" title="keyword">∀</span> <a id="n:86" class="idref" href="#n:86"><span class="id" title="binder">n</span></a> <a id="m:87" class="idref" href="#m:87"><span class="id" title="binder">m</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#n:86"><span class="id" title="variable">n</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="Basic.html#m:87"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<span class="id" title="definition">max</span> <a class="idref" href="Basic.html#n:86"><span class="id" title="variable">n</span></a> <a class="idref" href="Basic.html#m:87"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#m:87"><span class="id" title="variable">m</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="definition">max</span>. <span class="id" title="var">case_if</span>; <span class="id" title="var">math</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Here is the most general specification for the function <span class="inlinecode"><span class="id" title="var">repeat_incr</span></span>. 
<div class="paragraph"> </div>

<a id="lab42"></a><h4 class="section">Exercise: 2 stars, standard, optional (triple_repeat_incr')</h4>
 Prove the general specification for the function <span class="inlinecode"><span class="id" title="var">repeat_incr</span></span>, covering
    also the case <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode">0</span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_repeat_incr'" class="idref" href="#triple_repeat_incr'"><span class="id" title="lemma">triple_repeat_incr'</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:88" class="idref" href="#p:88"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:89" class="idref" href="#n:89"><span class="id" title="binder">n</span></a> <a id="m:90" class="idref" href="#m:90"><span class="id" title="binder">m</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#repeat_incr"><span class="id" title="definition">repeat_incr</span></a> <a class="idref" href="Basic.html#p:88"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#m:90"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:88"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:89"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:88"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:89"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> <span class="id" title="definition">max</span> 0 <a class="idref" href="Basic.html#m:90"><span class="id" title="variable">m</span></a><a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab43"></a><h2 class="section">A Recursive Function Involving two References</h2>

<div class="paragraph"> </div>

 Consider the function <span class="inlinecode"><span class="id" title="var">step_transfer</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">q</span></span>, which repeatedly increments a
    reference <span class="inlinecode"><span class="id" title="var">p</span></span> and decrements a reference <span class="inlinecode"><span class="id" title="var">q</span></span>, as long as the contents of <span class="inlinecode"><span class="id" title="var">q</span></span>
    is positive.

<div class="paragraph"> </div>

<span class="inlinecode-ocaml">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="keyword">rec</span> <span class="id" title="var">step_transfer</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> !<span class="id" title="var">q</span> &gt; 0 <span class="id" title="keyword">then</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">incr</span> <span class="id" title="var">p</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">decr</span> <span class="id" title="var">q</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">step_transfer</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
</span>
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="step_transfer" class="idref" href="#step_transfer"><span class="id" title="definition">step_transfer</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#06de39bf13088f4f90583983ce65e722"><span class="id" title="notation">fix</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">f</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a> <a class="idref" href="LibSepReference.html#06de39bf13088f4f90583983ce65e722"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:x_'&gt;'_x"><span class="id" title="notation">&gt;</span></a> 0 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'end'"><span class="id" title="notation">if</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'end'"><span class="id" title="notation">then</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basic.html#incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#DemoPrograms.Def_decr.decr"><span class="id" title="definition">decr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">f</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'end'"><span class="id" title="notation">end</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
The specification of <span class="inlinecode"><span class="id" title="var">step_transfer</span></span> is essentially the same as that of the
    function <span class="inlinecode"><span class="id" title="var">transfer</span></span> presented previously, the only difference being that we
    now assume the contents of <span class="inlinecode"><span class="id" title="var">q</span></span> to be nonnegative. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_step_transfer" class="idref" href="#triple_step_transfer"><span class="id" title="lemma">triple_step_transfer</span></a> : <span class="id" title="keyword">∀</span> <a id="p:91" class="idref" href="#p:91"><span class="id" title="binder">p</span></a> <a id="q:92" class="idref" href="#q:92"><span class="id" title="binder">q</span></a> <a id="n:93" class="idref" href="#n:93"><span class="id" title="binder">n</span></a> <a id="m:94" class="idref" href="#m:94"><span class="id" title="binder">m</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#m:94"><span class="id" title="variable">m</span></a> <span class="id" title="notation">≥</span> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#step_transfer"><span class="id" title="definition">step_transfer</span></a> <a class="idref" href="Basic.html#p:91"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#q:92"><span class="id" title="variable">q</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:91"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:93"><span class="id" title="variable">n</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#q:92"><span class="id" title="variable">q</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#m:94"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:91"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:93"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> <a class="idref" href="Basic.html#m:94"><span class="id" title="variable">m</span></a><a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#q:92"><span class="id" title="variable">q</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> 0).<br/>
</div>

<div class="doc">
<a id="lab44"></a><h4 class="section">Exercise: 2 stars, standard, especially useful (triple_step_transfer)</h4>
 Verify the function <span class="inlinecode"><span class="id" title="var">step_transfer</span></span>. Hint: to set up the induction, follow
    the pattern from <span class="inlinecode"><span class="id" title="var">triple_repeat_incr'</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab45"></a><h2 class="section">Computing Factorial using State</h2>

<div class="paragraph"> </div>

 To conclude this chapter, consider a function that computes factorial using
    mutable state. 
<div class="paragraph"> </div>

 A standard OCaml implementation would be:

<div class="paragraph"> </div>

<span class="inlinecode-ocaml">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">factoimp</span> <span class="id" title="var">n</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">r</span> = <span class="id" title="var">ref</span> 1 <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">for</span> <span class="id" title="var">i</span> = 1 <span class="id" title="var">to</span> <span class="id" title="var">n</span> <span class="id" title="tactic">do</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">r</span> := !<span class="id" title="var">r</span> * (<span class="id" title="var">i</span>+1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">done</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!<span class="id" title="var">r</span>
</span>
<div class="paragraph"> </div>

    Rather than explaining how to handle for loops at this stage, let us instead
    encode the loop using an auxiliary recursive function. 
<div class="paragraph"> </div>

 The auxiliary function <span class="inlinecode"><span class="id" title="var">factoimp_aux</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> performs the operations of the
    above for-loop starting at loop index <span class="inlinecode"><span class="id" title="var">i</span></span>, until reaching <span class="inlinecode"><span class="id" title="var">n</span></span>. The main
    function <span class="inlinecode"><span class="id" title="var">factoimp</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> computes the factorial of <span class="inlinecode"><span class="id" title="var">n</span></span> in a fresh reference
    cell named <span class="inlinecode"><span class="id" title="var">r</span></span>. Then, it returns the contents of <span class="inlinecode"><span class="id" title="var">r</span></span>.

<div class="paragraph"> </div>

<span class="inlinecode-ocaml">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="keyword">rec</span> <span class="id" title="var">factoimp_aux</span> <span class="id" title="var">r</span> <span class="id" title="var">i</span> <span class="id" title="var">n</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">i</span> &lt; <span class="id" title="var">n</span> <span class="id" title="keyword">then</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">r</span> := !<span class="id" title="var">r</span> * (<span class="id" title="var">i</span>+1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">factoimp_aux</span> <span class="id" title="var">r</span> (<span class="id" title="var">i</span>+1) <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">factoimp</span> <span class="id" title="var">n</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">r</span> = <span class="id" title="var">ref</span> 1 <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">factoimp_aux</span> <span class="id" title="var">r</span> 1 <span class="id" title="var">n</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!<span class="id" title="var">r</span>
</span>
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="factoimp_aux" class="idref" href="#factoimp_aux"><span class="id" title="definition">factoimp_aux</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#06de39bf13088f4f90583983ce65e722"><span class="id" title="notation">fix</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">f</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">r</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''i'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''i'"><span class="id" title="notation">i</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#06de39bf13088f4f90583983ce65e722"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''i'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''i'"><span class="id" title="notation">i</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:x_'&lt;'_x"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'end'"><span class="id" title="notation">if</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'end'"><span class="id" title="notation">then</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''j'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''j'"><span class="id" title="notation">j</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''i'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''i'"><span class="id" title="notation">i</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> 1 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''s'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''s'"><span class="id" title="notation">s</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">r</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''s'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''s'"><span class="id" title="notation">s</span></a> <a class="idref" href="LibSepReference.html#8687bd0de562fa8820387e422eed2db<sub>3</sub>"><span class="id" title="notation">*</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''j'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''j'"><span class="id" title="notation">j</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">r</span></a> <a class="idref" href="LibSepReference.html#e0633f114fcb17e965cb872e30ce07a<sub>5</sub>"><span class="id" title="notation">:=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">f</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">r</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''j'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''j'"><span class="id" title="notation">j</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'end'"><span class="id" title="notation">end</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <a id="factoimp" class="idref" href="#factoimp"><span class="id" title="definition">factoimp</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">r</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:'ref'"><span class="id" title="notation">ref</span></a> 1 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basic.html#factoimp_aux"><span class="id" title="definition">factoimp_aux</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">r</span></a> 1 <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">r</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'free'"><span class="id" title="notation">free</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''r'"><span class="id" title="notation">r</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
<a id="lab46"></a><h4 class="section">Exercise: 3 stars, standard, especially useful (triple_factoimp_aux)</h4>
 Verify the function <span class="inlinecode"><span class="id" title="var">triple_factoimp_aux</span></span>. Hint: the set up of the induction
    is provided. Use <span class="inlinecode"><span class="id" title="var">facto_succ</span></span> in the proof. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_factoimp_aux" class="idref" href="#triple_factoimp_aux"><span class="id" title="lemma">triple_factoimp_aux</span></a> : <span class="id" title="keyword">∀</span> (<a id="r:95" class="idref" href="#r:95"><span class="id" title="binder">r</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="i:96" class="idref" href="#i:96"><span class="id" title="binder">i</span></a> <a id="n:97" class="idref" href="#n:97"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;0 <span class="id" title="notation">≤</span> <a class="idref" href="Basic.html#i:96"><span class="id" title="variable">i</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="Basic.html#n:97"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#factoimp_aux"><span class="id" title="definition">factoimp_aux</span></a> <a class="idref" href="Basic.html#r:95"><span class="id" title="variable">r</span></a> <a class="idref" href="Basic.html#i:96"><span class="id" title="variable">i</span></a> <a class="idref" href="Basic.html#n:97"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#r:95"><span class="id" title="variable">r</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#facto"><span class="id" title="axiom">facto</span></a> <a class="idref" href="Basic.html#i:96"><span class="id" title="variable">i</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#r:95"><span class="id" title="variable">r</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#facto"><span class="id" title="axiom">facto</span></a> <a class="idref" href="Basic.html#n:97"><span class="id" title="variable">n</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span>. <span class="id" title="var">induction_wf</span> <span class="id" title="var">IH</span>: (<span class="id" title="definition">upto</span> <span class="id" title="var">n</span>) <span class="id" title="var">i</span>. <span class="id" title="var">introv</span> <span class="id" title="var">Hn</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab47"></a><h4 class="section">Exercise: 3 stars, standard, especially useful (triple_factoimp)</h4>
 Now verify the function <span class="inlinecode"><span class="id" title="var">factoimp</span></span>. Hint: use <span class="inlinecode"><span class="id" title="var">xapp</span></span> <span class="inlinecode"><span class="id" title="var">triple_factoimp_aux</span></span> to
    reason about the call to the auxiliary function <span class="inlinecode"><span class="id" title="var">factoimp_aux</span></span>. Use
    <span class="inlinecode"><span class="id" title="var">facto_init</span></span>. For simplicity, we assume <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">1</span> instead of <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0</span>. In the
    optional material section further on, we explain how to generalize the proof
    to handle the case <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_factoimp" class="idref" href="#triple_factoimp"><span class="id" title="lemma">triple_factoimp</span></a> : <span class="id" title="keyword">∀</span> <a id="n:98" class="idref" href="#n:98"><span class="id" title="binder">n</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#n:98"><span class="id" title="variable">n</span></a> <span class="id" title="notation">≥</span> 1 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#factoimp"><span class="id" title="definition">factoimp</span></a> <a class="idref" href="Basic.html#n:98"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:99" class="idref" href="#r:99"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:99"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#facto"><span class="id" title="axiom">facto</span></a> <a class="idref" href="Basic.html#n:98"><span class="id" title="variable">n</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab48"></a><h1 class="section">Summary</h1>

<div class="paragraph"> </div>

 This chapter introduced the following notions:

<div class="paragraph"> </div>

<ul class="doclist">
<li> "Heap predicates", which are used to describe memory states in Separation
      Logic.

</li>
<li> "Specification triples" of the form <span class="inlinecode"><span class="id" title="var">triple</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span>, which relate a term
      <span class="inlinecode"><span class="id" title="var">t</span></span>, a precondition <span class="inlinecode"><span class="id" title="var">H</span></span>, and a postcondition <span class="inlinecode"><span class="id" title="var">Q</span></span>.

</li>
<li> "Verification triples", of the form <span class="inlinecode"><span class="id" title="var">PRE</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">CODE</span></span> <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode"><span class="id" title="var">POST</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span>, are triples of
      a specific form, produced by the framework.

</li>
<li> "Entailments", of the form <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class="id" title="var">H'</span></span> or <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">===&gt;</span> <span class="inlinecode"><span class="id" title="var">Q'</span></span>, which assert that
      one pre- or post-condition is weaker than another one.

</li>
<li> Custom proof tactics, called "x-tactics", which are specialized tactics
      for discharging these proof obligations.

</li>
</ul>

<div class="paragraph"> </div>

    Several specific heap predicates for describing memory states were presented
    in this introductory chapter. They include:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>, which describes a memory cell at location <span class="inlinecode"><span class="id" title="var">p</span></span> with contents
      <span class="inlinecode"><span class="id" title="var">n</span></span>,

</li>
<li> <span class="inlinecode"><span class='gray-font'>\</span>[]</span>, which describes an empty state,

</li>
<li> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">P</span>]</span>, which also describes an empty state and moreover asserts that the
      proposition <span class="inlinecode"><span class="id" title="var">P</span></span> is true,

</li>
<li> <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span>, which describes a state made of two disjoint parts, one
      satisfying <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> and another satisfying <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span>,

</li>
<li> <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">H</span></span>, which is used to quantify variables in postconditions.

</li>
</ul>

<div class="paragraph"> </div>

    All these heap predicates have type <span class="inlinecode"><span class="id" title="var">hprop</span></span>, which describes predicates over
    memory states. A memory state has type <span class="inlinecode"><span class="id" title="var">heap</span></span>, thus <span class="inlinecode"><span class="id" title="var">hprop</span></span> is defined as
    <span class="inlinecode"><span class="id" title="var">heap</span>→<span class="id" title="keyword">Prop</span></span>.

<div class="paragraph"> </div>

    The verification of practical programs is carried out using x-tactics,
    identified by the leading "x" letter in their name. These tactics include:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">xwp</span></span> to begin a proof,

</li>
<li> <span class="inlinecode"><span class="id" title="var">xapp</span></span> to reason about an application,

</li>
<li> <span class="inlinecode"><span class="id" title="var">xval</span></span> to reason about a return value,

</li>
<li> <span class="inlinecode"><span class="id" title="var">xif</span></span> to reason about a conditional,

</li>
<li> <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> to simplify or prove entailments (<span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class="id" title="var">H'</span></span> and <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">===&gt;</span> <span class="inlinecode"><span class="id" title="var">Q'</span></span>).

</li>
</ul>

<div class="paragraph"> </div>

    In addition to x-tactics, the proof scripts exploit standard Coq tactics, as
    well as tactics from the TLC library, which provides a bunch of useful,
    general purpose tactics. In this chapter, we used a few TLC tactics:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">math</span></span>, which is a variant of <span class="inlinecode"><span class="id" title="var">lia</span></span> for proving mathematical goals,

</li>
<li> <span class="inlinecode"><span class="id" title="var">induction_wf</span></span>, which sets up proofs by well-founded induction,

</li>
<li> <span class="inlinecode"><span class="id" title="var">gen</span></span>, for generalizing variables for inductions. 

</li>
</ul>
</div>

<div class="doc">
<a id="lab49"></a><h1 class="section">Optional Material</h1>

<div class="paragraph"> </div>

 The function <span class="inlinecode"><span class="id" title="var">factoimp</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> correctly computes the factorial of <span class="inlinecode"><span class="id" title="var">n</span></span> not just
    when <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">1</span>, but also when <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>. Yet, the argument for justifying this
    fact is not entirely straightforward. A naive approach would be to develop a
    separate proof that <span class="inlinecode"><span class="id" title="var">factoimp</span></span> <span class="inlinecode">0</span> returns <span class="inlinecode">1</span>. Such a separate proof would
    look as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_factoimp_aux_zero" class="idref" href="#triple_factoimp_aux_zero"><span class="id" title="lemma">triple_factoimp_aux_zero</span></a> : <span class="id" title="keyword">∀</span> (<a id="r:100" class="idref" href="#r:100"><span class="id" title="binder">r</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="i:101" class="idref" href="#i:101"><span class="id" title="binder">i</span></a> <a id="n:102" class="idref" href="#n:102"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#i:101"><span class="id" title="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 1 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#n:102"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#factoimp_aux"><span class="id" title="definition">factoimp_aux</span></a> <a class="idref" href="Basic.html#r:100"><span class="id" title="variable">r</span></a> <a class="idref" href="Basic.html#i:101"><span class="id" title="variable">i</span></a> <a class="idref" href="Basic.html#n:102"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#r:100"><span class="id" title="variable">r</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#facto"><span class="id" title="axiom">facto</span></a> <a class="idref" href="Basic.html#i:101"><span class="id" title="variable">i</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#r:100"><span class="id" title="variable">r</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#facto"><span class="id" title="axiom">facto</span></a> <a class="idref" href="Basic.html#n:102"><span class="id" title="variable">n</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span>. <span class="id" title="var">introv</span> <span class="id" title="var">Hi</span> <span class="id" title="var">Hn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xif</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">C</span>.<br/>
</div>

<div class="doc">
Case <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">≥</span> <span class="inlinecode"><span class="id" title="var">n</span></span> cannot happen 
</div>
<div class="code">
&nbsp;&nbsp;{ <span class="id" title="var">false</span>. <span class="id" title="var">math</span>. }<br/>
</div>

<div class="doc">
Case <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> holds because <span class="inlinecode"><span class="id" title="var">facto</span></span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">facto</span></span> <span class="inlinecode">1</span> 
</div>
<div class="code">
&nbsp;&nbsp;{ <span class="id" title="var">xval</span>. <span class="id" title="var">xsimpl</span>. <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Basic.html#facto_init"><span class="id" title="axiom">facto_init</span></a>; [|<span class="id" title="var">math</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Basic.html#facto_init"><span class="id" title="axiom">facto_init</span></a>; [|<span class="id" title="var">math</span>]. <span class="id" title="tactic">auto</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="triple_factoimp_zero" class="idref" href="#triple_factoimp_zero"><span class="id" title="lemma">triple_factoimp_zero</span></a> : <span class="id" title="keyword">∀</span> <a id="n:103" class="idref" href="#n:103"><span class="id" title="binder">n</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#n:103"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#factoimp"><span class="id" title="definition">factoimp</span></a> <a class="idref" href="Basic.html#n:103"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:104" class="idref" href="#r:104"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:104"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#facto"><span class="id" title="axiom">facto</span></a> <a class="idref" href="Basic.html#n:103"><span class="id" title="variable">n</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span> <span class="id" title="var">Hn</span>. <span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">r</span>.<br/>
</div>

<div class="doc">
Here we invoke the specification of <span class="inlinecode"><span class="id" title="var">factoimp_aux</span></span> specialized for the case
    <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">xapp</span> <a class="idref" href="Basic.html#triple_factoimp_aux_zero"><span class="id" title="lemma">triple_factoimp_aux_zero</span></a>. { <span class="id" title="var">math</span>. } { <span class="id" title="var">math</span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">rewrite</span>* <a class="idref" href="Basic.html#facto_init"><span class="id" title="axiom">facto_init</span></a>. { <span class="id" title="var">math</span>. } }<br/>
&nbsp;&nbsp;<span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xval</span>. <span class="id" title="var">xsimpl</span>. <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
What we have done here is to go twice over the whole code, once to verify
    correctness in the case <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">1</span>, and once for the case <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>. Going twice
    over the same piece of code is, in general, bad practice. Indeed, the
    resulting script involves a fair amount of duplication. Fortunately, in most
    situations it is possible to verify code in a single pass. In the present
    example, it suffices to consider as precondition the disjunction of the two
    possible cases: either <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">=</span> <span class="inlinecode">1</span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> or <span class="inlinecode">0</span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
<div class="paragraph"> </div>

<a id="lab50"></a><h4 class="section">Exercise: 4 stars, standard, especially useful (triple_factoimp_aux')</h4>
 Refine the proof of <span class="inlinecode"><span class="id" title="var">triple_factoimp_aux</span></span> for a relaxed precondition
    accounting also for the case <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>. Hint: use <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">Hn</span></span> <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[(?&amp;?)|?]</span>
    to perform the case analyses. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_factoimp_aux'" class="idref" href="#triple_factoimp_aux'"><span class="id" title="lemma">triple_factoimp_aux'</span></a> : <span class="id" title="keyword">∀</span> (<a id="r:105" class="idref" href="#r:105"><span class="id" title="binder">r</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="i:106" class="idref" href="#i:106"><span class="id" title="binder">i</span></a> <a id="n:107" class="idref" href="#n:107"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e<sub>25</sub>"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#i:106"><span class="id" title="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 1 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="Basic.html#n:107"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 0<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e<sub>25</sub>"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e<sub>25</sub>"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e<sub>25</sub>"><span class="id" title="notation">(</span></a>0 <span class="id" title="notation">≤</span> <a class="idref" href="Basic.html#i:106"><span class="id" title="variable">i</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="Basic.html#n:107"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e<sub>25</sub>"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#factoimp_aux"><span class="id" title="definition">factoimp_aux</span></a> <a class="idref" href="Basic.html#r:105"><span class="id" title="variable">r</span></a> <a class="idref" href="Basic.html#i:106"><span class="id" title="variable">i</span></a> <a class="idref" href="Basic.html#n:107"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#r:105"><span class="id" title="variable">r</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#facto"><span class="id" title="axiom">facto</span></a> <a class="idref" href="Basic.html#i:106"><span class="id" title="variable">i</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#r:105"><span class="id" title="variable">r</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#facto"><span class="id" title="axiom">facto</span></a> <a class="idref" href="Basic.html#n:107"><span class="id" title="variable">n</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">introv</span>. <span class="id" title="var">induction_wf</span> <span class="id" title="var">IH</span>: (<span class="id" title="definition">upto</span> <span class="id" title="var">n</span>) <span class="id" title="var">i</span>. <span class="id" title="var">introv</span> <span class="id" title="var">Hn</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<a id="lab51"></a><h4 class="section">Exercise: 4 stars, standard, especially useful (triple_factoimp')</h4>
 Refine the proof of <span class="inlinecode"><span class="id" title="var">triple_factoimp</span></span> for a relaxed precondition accounting
    also for the case <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>. Hint: use the tactic <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode">(<span class="id" title="var">classic</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0))</span>
    to perform a case analysis on whether <span class="inlinecode"><span class="id" title="var">n</span></span> is zero; but make sure to perform
    the case analysis as late in the proof as possible, in order to avoid
    duplication. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_factoimp'" class="idref" href="#triple_factoimp'"><span class="id" title="lemma">triple_factoimp'</span></a> : <span class="id" title="keyword">∀</span> <a id="n:108" class="idref" href="#n:108"><span class="id" title="binder">n</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#n:108"><span class="id" title="variable">n</span></a> <span class="id" title="notation">≥</span> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#factoimp"><span class="id" title="definition">factoimp</span></a> <a class="idref" href="Basic.html#n:108"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:109" class="idref" href="#r:109"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:109"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#facto"><span class="id" title="axiom">facto</span></a> <a class="idref" href="Basic.html#n:108"><span class="id" title="variable">n</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<a id="lab52"></a><h1 class="section">Historical Notes</h1>

<div class="paragraph"> </div>

 The key ideas of Separation Logic were devised by John Reynolds, inspired in
    part by older work by <a href="Bib.html#Burstall-1972"><span class="inlineref">[Burstall 1972]</span></a>. Reynolds presented his ideas in
    lectures given in the fall of 1999. The proposed rules turned out to be
    unsound, but <a href="Bib.html#Ishtiaq-and O'Hearn 2001"><span class="inlineref">[Ishtiaq and O'Hearn 2001]</span></a> noticed a strong relationship
    with the logic of bunched implications by <a href="Bib.html#O'Hearn-and Pym 1999"><span class="inlineref">[O'Hearn and Pym 1999]</span></a>,
    leading to ideas on how to set up a sound program logic. Soon afterwards,
    the seminal publications on Separation Logic appeared at the CSL workshop
    <a href="Bib.html#O'Hearn,-Reynolds, and Yang 2001"><span class="inlineref">[O'Hearn, Reynolds, and Yang 2001]</span></a> and at the LICS conference
    <a href="Bib.html#Reynolds-2002"><span class="inlineref">[Reynolds 2002]</span></a>.

<div class="paragraph"> </div>

    The Separation Logic specifications and proof scripts using x-tactics
    presented in this file are directly adapted from the CFML tool (2010-2023),
    developed mainly by Arthur Charguéraud. The notations for Separation Logic
    predicates are directly inspired from those introduced in the Ynot project
    <a href="Bib.html#Chlipala-et al 2009"><span class="inlineref">[Chlipala et al 2009]</span></a>. See chapter <a href="Bib.html"><span class="inlineref">Bib</span></a> for references. 
</div>
<div class="code">

<span class="comment">(*&nbsp;2024-08-30&nbsp;14:21&nbsp;*)</span><br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>