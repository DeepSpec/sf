<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>Basic: Basic Proofs in Separation Logic</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/slf.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<div id="page">

<div id="header">
<div id='logoinheader'><a href='https://softwarefoundations.cis.upenn.edu'>
<img src='common/media/image/sf_logo_sm.png' alt='Software Foundations Logo'></a></div>
<div class='booktitleinheader'><a href='index.html'>Volume 6: Separation Logic Foundations</a></div>
<ul id='menu'>
   <li class='section_name'><a href='toc.html'>Table of Contents</a></li>
   <li class='section_name'><a href='coqindex.html'>Index</a></li>
   <li class='section_name'><a href='deps.html'>Roadmap</a></li>
</ul>
</div>

<div id="main">

<h1 class="libtitle">Basic<span class="subtitle">Basic Proofs in Separation Logic</span></h1>


<div class="code">

<span class="id" title="keyword">Set Implicit Arguments</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">SLF</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="LibSepReference.html#"><span class="id" title="library">LibSepReference</span></a>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">ProgramSyntax</span> <span class="id" title="var">DemoPrograms</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="notation">int</span>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span> : <a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>.<br/>
</div>

<div class="doc">
<a id="lab14"></a><h1 class="section">A First Taste</h1>

<div class="paragraph"> </div>

 This chapter gives an overview of the basic features of Separation Logic,
    by means of examples. The examples are specified and verified using a
    Separation Logic framework whose construction is explained throughout the
    course. 
</div>

<div class="doc">
<a id="lab15"></a><h2 class="section">Parsing of Programs</h2>

<div class="paragraph"> </div>

 The source code of the programs considered are written within Coq, using a
    "custom grammar" that allows writing code that reads almost like OCaml
    code. For example, consider the function <span class="inlinecode"><span class="id" title="var">incr</span></span>, which increments the
    contents of a mutable cell that stores an integer. In OCaml syntax, this
    function could be defined as:

<div class="paragraph"> </div>

<span class="inlinecode-ocaml">&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">incr</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">p</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">n</span> = !<span class="id" title="var">p</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">m</span> = <span class="id" title="var">n</span> + 1 <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">p</span> := <span class="id" title="var">m</span>
</span>
<div class="paragraph"> </div>

 In Coq, we describe the corresponding program as shown below. Observe that
    all variable names are prefixed with a quote symbol. This presentation
    avoids conflict between program variables and Coq constants. The function
    defined, named <span class="inlinecode"><span class="id" title="var">incr</span></span>, admits the type <span class="inlinecode"><span class="id" title="var">val</span></span>. This type is defined by the
    framework. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="incr" class="idref" href="#incr"><span class="id" title="definition">incr</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> 1 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#e0633f114fcb17e965cb872e30ce07a<sub>5</sub>"><span class="id" title="notation">:=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
There is no need to learn how to write programs in this custom syntax:
    source code is provided for all the programs involved in this course. 
<div class="paragraph"> </div>

 To simplify the implementation of the framework and the reasoning about
    programs, we make throughout the course the simplifying assumption that
    programs are written in "A-normal form": all intermediate expressions must
    be named using a let-binding. 
</div>

<div class="doc">
<a id="lab16"></a><h2 class="section">Specification of the Increment Function</h2>

<div class="paragraph"> </div>

 The specification of <span class="inlinecode"><span class="id" title="var">incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> is expressed using a "Separation Logic
    triple", that is, a predicate of the form <span class="inlinecode"><span class="id" title="var">triple</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span>. The term <span class="inlinecode"><span class="id" title="var">t</span></span>
    here corresponds to the application of the function <span class="inlinecode"><span class="id" title="var">incr</span></span> to the argument
    <span class="inlinecode"><span class="id" title="var">p</span></span>. We could write this application in the form <span class="inlinecode">&lt;{</span> <span class="inlinecode"><span class="id" title="var">incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">}&gt;</span>, using
    the custom syntax for parsing programs. That said, we can also write the
    same term in the form <span class="inlinecode">(<span class="id" title="var">incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span>)</span>, leveraging Coq's coercion facility to
    reuse Coq's syntax for application. In other words, the specification of
    <span class="inlinecode"><span class="id" title="var">incr</span></span> can be written in the form <span class="inlinecode"><span class="id" title="var">triple</span></span> <span class="inlinecode">(<span class="id" title="var">incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span>)</span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span>.

<div class="paragraph"> </div>

    The components <span class="inlinecode"><span class="id" title="var">H</span></span> and <span class="inlinecode"><span class="id" title="var">Q</span></span> correspond to the precondition and to the
    postcondition, which are explained next. To improve readability, we follow
    the convention of writing both the precondition and the postcondition on
    separate lines. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_incr" class="idref" href="#triple_incr"><span class="id" title="lemma">triple_incr</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:1" class="idref" href="#p:1"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:2" class="idref" href="#n:2"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="Basic.html#incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="Basic.html#p:1"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:1"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:2"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ (<a class="idref" href="Basic.html#p:1"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:2"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>)).<br/>
</div>

<div class="doc">
In the specification above, <span class="inlinecode"><span class="id" title="var">p</span></span> denotes the "location", that is, the
    address in memory, of the reference cell provided as argument to the
    increment function. Locations have type <span class="inlinecode"><span class="id" title="var">loc</span></span> in the framework.

<div class="paragraph"> </div>

    The precondition is written <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. This Separation Logic predicate
    describes a memory state in which the contents of the location <span class="inlinecode"><span class="id" title="var">p</span></span> is the
    value <span class="inlinecode"><span class="id" title="var">n</span></span>. In the present example, <span class="inlinecode"><span class="id" title="var">n</span></span> stands for an integer value.

<div class="paragraph"> </div>

    The behavior of the operation <span class="inlinecode"><span class="id" title="var">incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> consists of updating the memory
    state by incrementing the contents of the cell at location <span class="inlinecode"><span class="id" title="var">p</span></span>, updating
    its contents to <span class="inlinecode"><span class="id" title="var">n</span>+1</span>. Thus, the memory state posterior to the increment
    operation is described by the predicate <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>.

<div class="paragraph"> </div>

    The result value returned by <span class="inlinecode"><span class="id" title="var">incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> is the unit value, which does not
    carry any useful information. In the specification of <span class="inlinecode"><span class="id" title="var">incr</span></span>, the
    postcondition is of the form <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode">...</span> to indicate that there is
    no need to bind a name for the result value. 
<div class="paragraph"> </div>

 The general pattern of a specification thus includes:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Quantification of the arguments of the functions---here, the variable
      <span class="inlinecode"><span class="id" title="var">p</span></span>.

</li>
<li> Quantification of the "ghost variables" used to describe the input
      state---here, the variable <span class="inlinecode"><span class="id" title="var">n</span></span>.

</li>
<li> The application of the predicate <span class="inlinecode"><span class="id" title="var">triple</span></span> to the function application
      <span class="inlinecode"><span class="id" title="var">incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>---here, the term being specified by the triple.

</li>
<li> The precondition describing the input state---here, the predicate
      <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>.

</li>
<li> The postcondition describing both the output value and the output state.
      The general pattern is <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">H'</span></span>, where <span class="inlinecode"><span class="id" title="var">r</span></span> names the result and
      <span class="inlinecode"><span class="id" title="var">H'</span></span> describes the final state. Here, <span class="inlinecode"><span class="id" title="var">r</span></span> is just an underscore symbol,
      and the final state is described by <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>. 
</li>
</ul>

<div class="paragraph"> </div>

 Note that we have to write <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span> using parentheses around <span class="inlinecode"><span class="id" title="var">n</span>+1</span>,
    because <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span>+1</span> would get parsed as <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">+</span> <span class="inlinecode">1</span>. 
</div>

<div class="doc">
<a id="lab17"></a><h2 class="section">Verification of the Increment Function</h2>

<div class="paragraph"> </div>

 Our next step is to prove the specification lemma <span class="inlinecode"><span class="id" title="var">triple_incr</span></span> which
    specifies the behavior of the function <span class="inlinecode"><span class="id" title="var">incr</span></span>. We conduct the proof using
    tactics provided by the frameworks, called the "x-tactics" because their
    name start with the letter "x". These tactics include <span class="inlinecode"><span class="id" title="var">xwp</span></span> for starting
    a proof, <span class="inlinecode"><span class="id" title="var">xapp</span></span> for reasoning about a function call, and <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> for
    proving that a description of a state entails another one. 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">xwp</span></span> begins the verification proof. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">xwp</span>.<br/>
</div>

<div class="doc">
The proof obligation is displayed using a custom notation of the form
    <span class="inlinecode"><span class="id" title="var">PRE</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">CODE</span></span> <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode"><span class="id" title="var">POST</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span>. In the <span class="inlinecode"><span class="id" title="var">CODE</span></span> section, one should be able to
    somewhat recognize the body of <span class="inlinecode"><span class="id" title="var">incr</span></span>. Indeed, if we ignore the
    back-ticks and perform the alpha-renaming from <span class="inlinecode"><span class="id" title="var">v</span></span> to <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">v<sub>0</sub></span></span> to
    <span class="inlinecode"><span class="id" title="var">m</span></span>, the <span class="inlinecode"><span class="id" title="var">CODE</span></span> section reads like:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;[ <span class="id" title="keyword">Let</span> <span class="id" title="var">n</span> := <span class="id" title="var">App</span> <span class="id" title="var">val_get</span> <span class="id" title="var">p</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Let</span> <span class="id" title="var">m</span> := <span class="id" title="var">App</span> <span class="id" title="var">val_add</span> <span class="id" title="var">n</span> 1 <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">App</span> <span class="id" title="var">val_set</span> <span class="id" title="var">p</span> ) ]&gt;
</span>    which is somewhat similar to the original source code, but displayed
    using a special syntax whose meaning will be explained later on, in
    chapter <a href="WPgen.html"><span class="inlineref">WPgen</span></a>.  The remainder of the proof performs essentially a symbolic execution of
    the code. At each step, one should not attempt to read the full proof
    obligation, but instead only look at the current state, described by the
    <span class="inlinecode"><span class="id" title="var">PRE</span></span> part (here, <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>), and at the first line only of the <span class="inlinecode"><span class="id" title="var">CODE</span></span>
    part, which corresponds to the next operation to reason about. Each of
    the operations involved here is handled using the tactic <span class="inlinecode"><span class="id" title="var">xapp</span></span>. 
<div class="paragraph"> </div>

 First, we reason about the operation <span class="inlinecode">!<span class="id" title="var">p</span></span> that reads into <span class="inlinecode"><span class="id" title="var">p</span></span>; this read
    operation returns the value <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">xapp</span>.<br/>
</div>

<div class="doc">
Second, we reason about the addition operation <span class="inlinecode"><span class="id" title="var">n</span>+1</span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">xapp</span>.<br/>
</div>

<div class="doc">
Third, we reason about the update operation <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">n</span>+1</span>, thereby updating
    the state to <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">xapp</span>.<br/>
</div>

<div class="doc">
At this stage, the proof obligation takes the form <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span>. It
    requires us to check that the final state matches what is claimed in the
    postcondition. We discharge it using the tactic <span class="inlinecode"><span class="id" title="var">xsimpl</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The reader may be curious to know what the notation <span class="inlinecode"><span class="id" title="var">PRE</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">CODE</span></span> <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode"><span class="id" title="var">POST</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span>
    stands for, and what the x-tactics are doing. Everything will be explaiend
    throughout the course. This chapter and the next one focus presenting the
    features of Separation Logic, and on showing how x-tactics can be used to
    verify programs in Separation Logic. 
<div class="paragraph"> </div>

 This completes the verification of the lemma <span class="inlinecode"><span class="id" title="var">triple_incr</span></span>, which
    establishes a formal specification for the increment function. Before
    moving on to another function, we associate using the command shown below
    the lemma <span class="inlinecode"><span class="id" title="var">triple_incr</span></span> with the function <span class="inlinecode"><span class="id" title="var">incr</span></span> in a hint database called
    <span class="inlinecode"><span class="id" title="var">triple</span></span>. Doing so, when we verify a function that features a call to
    <span class="inlinecode"><span class="id" title="var">incr</span></span>, the <span class="inlinecode"><span class="id" title="var">xapp</span></span> tactic will be able to automatically invoke the lemma
    <span class="inlinecode"><span class="id" title="var">triple_incr</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">triple_incr</span> : <span class="id" title="var">triple</span>.<br/>
</div>

<div class="doc">
To minimize the amount of syntactic noise in specifications, we leverage
    an advanced feature of Coq's coercion mechanism. Concretely, instead of
    writing the specification in the form <span class="inlinecode"><span class="id" title="var">triple</span></span> <span class="inlinecode">&lt;{</span> <span class="inlinecode"><span class="id" title="var">incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">}&gt;</span> <span class="inlinecode">...</span>, we write
    it in the form <span class="inlinecode"><span class="id" title="var">triple</span></span> <span class="inlinecode">(<span class="id" title="var">incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span>)</span> <span class="inlinecode">...</span>, that is, with just parentheses.
    Thanks to the coercion mecanism, explained in more details in <a href="Rules.html"><span class="inlineref">Rules</span></a>,
    when Coq sees a "program value" <span class="inlinecode"><span class="id" title="var">incr</span></span> being applied to an argument <span class="inlinecode"><span class="id" title="var">p</span></span>,
    it automatically interprets this as a "program function call" of <span class="inlinecode"><span class="id" title="var">incr</span></span>
    to <span class="inlinecode"><span class="id" title="var">p</span></span>. Thus, the specification of the increment function can be written
    as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_incr'" class="idref" href="#triple_incr'"><span class="id" title="lemma">triple_incr'</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:3" class="idref" href="#p:3"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:4" class="idref" href="#n:4"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="Basic.html#p:3"><span class="id" title="variable">p</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:3"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:4"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ (<a class="idref" href="Basic.html#p:3"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:4"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Here,&nbsp;to&nbsp;view&nbsp;coercions,&nbsp;use&nbsp;<span class="inlinecode"><span class="id" title="keyword">Set</span></span> <span class="inlinecode"><span class="id" title="keyword">Printing</span></span> <span class="inlinecode"><span class="id" title="var">Coercions</span>.</span>,&nbsp;or&nbsp;in&nbsp;CoqIDE&nbsp;use<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="inlinecode"><span class="id" title="var">Shift</span>+<span class="id" title="var">Alt</span>+<span class="id" title="var">C</span></span>,&nbsp;which&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;menu&nbsp;View&nbsp;/&nbsp;Display&nbsp;Coerctions.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The existence of implicit coercions might be a little confusing at times,
    yet coercions make specifications so much more readable that it would
    be a pity to not exploit them. 
</div>

<div class="doc">
<a id="lab18"></a><h2 class="section">A Function with a Return Value</h2>

<div class="paragraph"> </div>

 As a second example, let us specify a function that performs simple
    arithmetic computations. The function, whose code appears below, expects
    an integer argument <span class="inlinecode"><span class="id" title="var">n</span></span> (in <span class="inlinecode"><span class="id" title="var">Z</span></span>). It evaluates <span class="inlinecode"><span class="id" title="var">a</span></span> as <span class="inlinecode"><span class="id" title="var">n</span>+1</span>, then
    evaluates <span class="inlinecode"><span class="id" title="var">b</span></span> as <span class="inlinecode"><span class="id" title="var">n</span>-1</span>, and finally returns the sum <span class="inlinecode"><span class="id" title="var">a</span>+<span class="id" title="var">b</span></span>. The function
    thus always returns <span class="inlinecode">2*<span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="example_let" class="idref" href="#example_let"><span class="id" title="definition">example_let</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''a'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''a'"><span class="id" title="notation">a</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> 1 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:x_'-'_x"><span class="id" title="notation">-</span></a> 1 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''a'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''a'"><span class="id" title="notation">a</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
The specification takes the form <span class="inlinecode"><span class="id" title="var">triple</span></span> <span class="inlinecode">(<span class="id" title="var">example_let</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">H'</span>)</span>,
    where <span class="inlinecode"><span class="id" title="var">r</span></span>, of type <span class="inlinecode"><span class="id" title="var">val</span></span>, denotes the output value.

<div class="paragraph"> </div>

    The precondition <span class="inlinecode"><span class="id" title="var">H</span></span> describes what we need to assume about the input
    state. For this function, we need not assume anything, hence we write
    <span class="inlinecode"><span class='gray-font'>\</span>[]</span> to denote the empty precondition. The program might have allocated
    data prior to the call to the function <span class="inlinecode"><span class="id" title="var">example_let</span></span>, however this
    function will not interfer in any way with this previously-allocated data.

<div class="paragraph"> </div>

    The postcondition describes what the function produces. More precisely, it
    describes in general both the output that the function returns, and the
    data from memory that the function has allocated, accessed, or updated.
    The function <span class="inlinecode"><span class="id" title="var">example_let</span></span> does not interact with the state, thus the
    postcondition could be described using the empty predicate <span class="inlinecode"><span class='gray-font'>\</span>[]</span>.

<div class="paragraph"> </div>

    Yet, if we write just <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode">(<span class="id" title="var">r</span>:<span class="id" title="var">val</span>)</span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class='gray-font'>\</span>[]</span> as postcondition, we would have
    said nothing about the output value <span class="inlinecode"><span class="id" title="var">r</span></span> produced by a call <span class="inlinecode"><span class="id" title="var">example_let</span></span>.
    Instead, we would like to specify that the result <span class="inlinecode"><span class="id" title="var">r</span></span> is equal to <span class="inlinecode">2*<span class="id" title="var">n</span></span>.
    To that end, we write the postcondition <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode">2*<span class="id" title="var">n</span>]</span>. Here,
    we use the predicate <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">P</span>]</span>, which allows to embed "pure facts", of type
    <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> in preconditions and postconditions.

<div class="paragraph"> </div>

    The equality <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode">2*<span class="id" title="var">n</span></span> actually resolves to <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">val_int</span></span> <span class="inlinecode">(2*<span class="id" title="var">n</span>)</span>, where
    <span class="inlinecode"><span class="id" title="var">val_int</span></span> is a coercion that translates the integer value <span class="inlinecode">2*<span class="id" title="var">n</span></span> into the
    corresponding integer value, of type <span class="inlinecode"><span class="id" title="var">val</span></span>, from the programming language.
    If you do not know what a coercion is, just ignore the previous sentence,
    and wait until chapter <a href="Rules.html"><span class="inlineref">Rules</span></a> to learn about coercions. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_example_let" class="idref" href="#triple_example_let"><span class="id" title="lemma">triple_example_let</span></a> : <span class="id" title="keyword">∀</span> (<a id="n:5" class="idref" href="#n:5"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#example_let"><span class="id" title="definition">example_let</span></a> <a class="idref" href="Basic.html#n:5"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:6" class="idref" href="#r:6"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:6"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 2<a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#d3ea1afb7d81263dc23c4eb0da2a3c4e"><span class="id" title="notation">*</span></a><a class="idref" href="Basic.html#n:5"><span class="id" title="variable">n</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
</div>

<div class="doc">
The proof script is quite similar to the previous one: <span class="inlinecode"><span class="id" title="var">xwp</span></span> begins the
    proof, <span class="inlinecode"><span class="id" title="var">xapp</span></span> performs symbolic execution. and <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> simplifies the
    entailment. Ultimately, we need to check that the expression computed,
    <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> <span class="inlinecode">+</span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode">1)</span>, is equal to the specified result, that is, <span class="inlinecode">2*<span class="id" title="var">n</span></span>.
    To prove this equality, we invoke the tactic <span class="inlinecode"><span class="id" title="var">math</span></span>, which is a variant
    of the tactic <span class="inlinecode"><span class="id" title="var">lia</span></span> provided by the TLC library. Recall from the preface
    that this course leverages TLC for enhanced definitions and tactics. 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>. <span class="id" title="var">math</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab19"></a><h4 class="section">Exercise: 1 star, standard, especially useful (triple_quadruple)</h4>

<div class="paragraph"> </div>

 Consider the function <span class="inlinecode"><span class="id" title="var">quadruple</span></span>, which expects an integer <span class="inlinecode"><span class="id" title="var">n</span></span> and
    returns its quadruple, that is, the value <span class="inlinecode">4*<span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="quadruple" class="idref" href="#quadruple"><span class="id" title="definition">quadruple</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
Specify and verify the function <span class="inlinecode"><span class="id" title="var">quadruple</span></span> to express that it returns
    <span class="inlinecode">4*<span class="id" title="var">n</span></span>. Hint: follow the pattern of the previous proof. 
</div>
<div class="code">

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab20"></a><h4 class="section">Exercise: 2 stars, standard, especially useful (triple_inplace_double)</h4>

<div class="paragraph"> </div>

 Consider the function <span class="inlinecode"><span class="id" title="var">inplace_double</span></span>, which expects a reference on an
    integer, reads its contents, then updates the contents with the double
    of the original value. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="inplace_double" class="idref" href="#inplace_double"><span class="id" title="definition">inplace_double</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#e0633f114fcb17e965cb872e30ce07a<sub>5</sub>"><span class="id" title="notation">:=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
Specify and verify the function <span class="inlinecode"><span class="id" title="var">inplace_double</span></span>. Hint: follow the
    pattern of the first example, namely <span class="inlinecode"><span class="id" title="var">triple_incr</span></span>. 
</div>
<div class="code">

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 From here on, we use the command <span class="inlinecode"><span class="id" title="keyword">Proof</span></span> <span class="inlinecode"><span class="id" title="keyword">using</span></span> for introducing a proof
    instead of writing just <span class="inlinecode"><span class="id" title="keyword">Proof</span></span>. Doing so enables asynchronous proof
    checking, a feature that may enable faster processing of scripts. 
</div>

<div class="doc">
<a id="lab21"></a><h1 class="section">Separation Logic Operators</h1>

</div>

<div class="doc">
<a id="lab22"></a><h2 class="section">Increment of Two References</h2>

<div class="paragraph"> </div>

 Consider the following function, which expects the addresses
    of two reference cells, and increments both of them. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="incr_two" class="idref" href="#incr_two"><span class="id" title="definition">incr_two</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#938475157e31b8b3433e07bd510fd74f"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a> <a class="idref" href="LibSepReference.html#938475157e31b8b3433e07bd510fd74f"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basic.html#incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basic.html#incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
The specification of this function takes the form
    <span class="inlinecode"><span class="id" title="var">triple</span></span> <span class="inlinecode">(<span class="id" title="var">incr_two</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">q</span>)</span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">H'</span>)</span>, where the underscore symbol
    denotes the result value. We do not bother binding a name for that result
    value because it always consists of the unit value.

<div class="paragraph"> </div>

    The precondition describes two references cells: <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">m</span></span>.
    To assert that the two cells are distinct from each other, we separate
    their description with the operator <span class="inlinecode"><span class='gray-font'>\</span>*</span>. Thus, the precondition
    is <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode">(<span class="id" title="var">q</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>, or simply <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">m</span></span>.
    The operator <span class="inlinecode"><span class='gray-font'>\</span>*</span> is called the "separating conjunction" of Separation
    Logic. It is also known as the "star" operator.

<div class="paragraph"> </div>

    The postcondition describes the final state in a similar way, as
    <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">m</span>+1)</span>. This predicate reflects the fact that the
    contents of both references gets increased by one unit.

<div class="paragraph"> </div>

    The specification triple for <span class="inlinecode"><span class="id" title="var">incr_two</span></span> is thus as follows. The proof
    follows the same pattern as in the previous examples. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_incr_two" class="idref" href="#triple_incr_two"><span class="id" title="lemma">triple_incr_two</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:7" class="idref" href="#p:7"><span class="id" title="binder">p</span></a> <a id="q:8" class="idref" href="#q:8"><span class="id" title="binder">q</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:9" class="idref" href="#n:9"><span class="id" title="binder">n</span></a> <a id="m:10" class="idref" href="#m:10"><span class="id" title="binder">m</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#incr_two"><span class="id" title="definition">incr_two</span></a> <a class="idref" href="Basic.html#p:7"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#q:8"><span class="id" title="variable">q</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:7"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:9"><span class="id" title="variable">n</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#q:8"><span class="id" title="variable">q</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#m:10"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:7"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:9"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#q:8"><span class="id" title="variable">q</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#m:10"><span class="id" title="variable">m</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Because we will make use of the function <span class="inlinecode"><span class="id" title="var">incr_two</span></span> later in this chapter,
    we register the specification <span class="inlinecode"><span class="id" title="var">triple_incr_two</span></span> in the <span class="inlinecode"><span class="id" title="var">triple</span></span> database. 
</div>
<div class="code">

<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">triple_incr_two</span> : <span class="id" title="var">triple</span>.<br/>
</div>

<div class="doc">
A quick point of vocabulary before moving on: Separation Logic expressions
    such as <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> or <span class="inlinecode"><span class='gray-font'>\</span>[]</span> or <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span> are called "heap predicates",
    because they corresponding to predicates over "heaps", i.e., predicates
    over memory states. 
</div>

<div class="doc">
<a id="lab23"></a><h2 class="section">Aliased Arguments</h2>

<div class="paragraph"> </div>

 The specification <span class="inlinecode"><span class="id" title="var">triple_incr_two</span></span> stated above describes the behavior
    of calls to the function <span class="inlinecode"><span class="id" title="var">incr_two</span></span> only for cases where the two arguments
    provided correspond to distinct reference cells. It says nothing, however,
    about a call of the form <span class="inlinecode"><span class="id" title="var">incr_two</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>. Indeed, in Separation Logic,
    a state described by <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> cannot be matched against a state described
    by <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>, because the star operator requires its operand to
    correspond to disjoint pieces of state.

<div class="paragraph"> </div>

    What happens if we nevertheless try to exploit <span class="inlinecode"><span class="id" title="var">triple_incr_two</span></span> to reason
    about a call of the form <span class="inlinecode"><span class="id" title="var">incr_two</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>, that is, with aliased arguments?
    Let's find out, by considering the operation <span class="inlinecode"><span class="id" title="var">aliased_call</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>, which does
    execute such a call. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="aliased_call" class="idref" href="#aliased_call"><span class="id" title="definition">aliased_call</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basic.html#incr_two"><span class="id" title="definition">incr_two</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
A call to <span class="inlinecode"><span class="id" title="var">aliased_call</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> increases the contents of <span class="inlinecode"><span class="id" title="var">p</span></span> by <span class="inlinecode">2</span>. This
    property can be specified as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_aliased_call" class="idref" href="#triple_aliased_call"><span class="id" title="lemma">triple_aliased_call</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:11" class="idref" href="#p:11"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:12" class="idref" href="#n:12"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#aliased_call"><span class="id" title="definition">aliased_call</span></a> <a class="idref" href="Basic.html#p:11"><span class="id" title="variable">p</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:11"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:12"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:11"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:12"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>2<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
</div>

<div class="doc">
If we attempt the proof, we get stuck. The tactic <span class="inlinecode"><span class="id" title="var">xapp</span></span> reports its
    failure by issuing a proof obligation of the form <span class="inlinecode"><span class='gray-font'>\</span>[]</span> <span class="inlinecode">==&gt;</span> <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">?<span class="id" title="var">m</span>)</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">_</span></span>.
    This proof obligation requires us to show that, from the empty heap
    predicate state, one can extract a heap predicate <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">?<span class="id" title="var">m</span></span> describing a
    reference at location <span class="inlinecode"><span class="id" title="var">p</span></span> with some integer contents <span class="inlinecode">?<span class="id" title="var">m</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
On the one hand, the precondition of the specification <span class="inlinecode"><span class="id" title="var">triple_incr_two</span></span>,
    with <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">p</span></span>, requires providing <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">?<span class="id" title="var">n</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">?<span class="id" title="var">m</span></span>. On the other
    hand, the current state is described as <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. When trying to match
    the two, the internal simplification tactic <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> is able to cancel out
    one occurrence of <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> from both expressions, but then there remains
    to match the empty heap predicate <span class="inlinecode"><span class='gray-font'>\</span>[]</span> against <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">?<span class="id" title="var">m</span>)</span>. The issue
    here is that the specification <span class="inlinecode"><span class="id" title="var">triple_incr_two</span></span> is specialized for the
    case of "non-aliased" references. 
<div class="paragraph"> </div>

 One thing we can do is to state and prove an alternative specification for
    the function <span class="inlinecode"><span class="id" title="var">incr_two</span></span>, to cover the case of aliased arguments. The
    precondition of this alternative specification mentions a single reference,
    <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>, and the postcondition asserts that the contents of that
    reference gets increased by two units. This alternative specification is
    stated and proved as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_incr_two_aliased" class="idref" href="#triple_incr_two_aliased"><span class="id" title="lemma">triple_incr_two_aliased</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:13" class="idref" href="#p:13"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:14" class="idref" href="#n:14"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#incr_two"><span class="id" title="definition">incr_two</span></a> <a class="idref" href="Basic.html#p:13"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#p:13"><span class="id" title="variable">p</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:13"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:14"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:13"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:14"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>2<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>. <span class="id" title="var">math</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
By exploiting the alternative specification for <span class="inlinecode"><span class="id" title="var">incr_two</span></span>, we are able
    to prove the specification of the function <span class="inlinecode"><span class="id" title="var">aliased_call</span></span>. In order to
    indicate to the tactic <span class="inlinecode"><span class="id" title="var">xapp</span></span> that it should not invoke the lemma
    <span class="inlinecode"><span class="id" title="var">triple_incr_two</span></span> registered for <span class="inlinecode"><span class="id" title="var">incr_two</span></span>, but instead invoke the
    lemma <span class="inlinecode"><span class="id" title="var">triple_incr_two_aliased</span></span>, we provide that lemma as argument to
    <span class="inlinecode"><span class="id" title="var">xapp</span></span>. Concretely, we write <span class="inlinecode"><span class="id" title="var">xapp</span></span> <span class="inlinecode"><span class="id" title="var">triple_incr_two_aliased</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_aliased_call" class="idref" href="#triple_aliased_call"><span class="id" title="lemma">triple_aliased_call</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:15" class="idref" href="#p:15"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:16" class="idref" href="#n:16"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#aliased_call"><span class="id" title="definition">aliased_call</span></a> <a class="idref" href="Basic.html#p:15"><span class="id" title="variable">p</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:15"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:16"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:15"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:16"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>2<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span> <a class="idref" href="Basic.html#triple_incr_two_aliased"><span class="id" title="lemma">triple_incr_two_aliased</span></a>. <span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Taking a step back, it may appear somewhat disappointing that we need
    two different specifications for the same function, depending on whether
    its arguments are aliased on not. There exists advanced features of
    Separation Logic that allow handling the two cases through a single
    specification. However, for such a simple function it is easiest to just
    state and prove the two specifications separately. 
</div>

<div class="doc">
<a id="lab24"></a><h2 class="section">A Function that Takes Two References and Increments One</h2>

<div class="paragraph"> </div>

 Consider the following function, which expects the addresses of two
    reference cells and increments only the first one. What is interesting
    about this function is precisely the fact that it does nothing with its
    second argument. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="incr_first" class="idref" href="#incr_first"><span class="id" title="definition">incr_first</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#938475157e31b8b3433e07bd510fd74f"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a> <a class="idref" href="LibSepReference.html#938475157e31b8b3433e07bd510fd74f"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basic.html#incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
We can specify this function by describing its input state as
    <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">m</span></span>, and describing its output state as
    <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">m</span></span>. Formally: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_incr_first" class="idref" href="#triple_incr_first"><span class="id" title="lemma">triple_incr_first</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:17" class="idref" href="#p:17"><span class="id" title="binder">p</span></a> <a id="q:18" class="idref" href="#q:18"><span class="id" title="binder">q</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:19" class="idref" href="#n:19"><span class="id" title="binder">n</span></a> <a id="m:20" class="idref" href="#m:20"><span class="id" title="binder">m</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#incr_first"><span class="id" title="definition">incr_first</span></a> <a class="idref" href="Basic.html#p:17"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#q:18"><span class="id" title="variable">q</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:17"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:19"><span class="id" title="variable">n</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#q:18"><span class="id" title="variable">q</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#m:20"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:17"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:19"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#q:18"><span class="id" title="variable">q</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#m:20"><span class="id" title="variable">m</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The second reference plays absolutely no role in the execution of the
    function. Thus, we could equally well consider a specification that
    mentions only the existence of the first reference. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_incr_first'" class="idref" href="#triple_incr_first'"><span class="id" title="lemma">triple_incr_first'</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:21" class="idref" href="#p:21"><span class="id" title="binder">p</span></a> <a id="q:22" class="idref" href="#q:22"><span class="id" title="binder">q</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:23" class="idref" href="#n:23"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#incr_first"><span class="id" title="definition">incr_first</span></a> <a class="idref" href="Basic.html#p:21"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#q:22"><span class="id" title="variable">q</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:21"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:23"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:21"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:23"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Interestingly, the specification <span class="inlinecode"><span class="id" title="var">triple_incr_first</span></span>, which mentions the
    two references, is derivable from the specification <span class="inlinecode"><span class="id" title="var">triple_incr_first'</span></span>,
    which mentions only the first reference. To prove the implication, it
    suffices to invoke the tactic <span class="inlinecode"><span class="id" title="var">xapp</span></span> with argument <span class="inlinecode"><span class="id" title="var">triple_incr_first'</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_incr_first_derived" class="idref" href="#triple_incr_first_derived"><span class="id" title="lemma">triple_incr_first_derived</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:24" class="idref" href="#p:24"><span class="id" title="binder">p</span></a> <a id="q:25" class="idref" href="#q:25"><span class="id" title="binder">q</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:26" class="idref" href="#n:26"><span class="id" title="binder">n</span></a> <a id="m:27" class="idref" href="#m:27"><span class="id" title="binder">m</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#incr_first"><span class="id" title="definition">incr_first</span></a> <a class="idref" href="Basic.html#p:24"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#q:25"><span class="id" title="variable">q</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:24"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:26"><span class="id" title="variable">n</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#q:25"><span class="id" title="variable">q</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#m:27"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:24"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:26"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#q:25"><span class="id" title="variable">q</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#m:27"><span class="id" title="variable">m</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">xapp</span> <a class="idref" href="Basic.html#triple_incr_first'"><span class="id" title="lemma">triple_incr_first'</span></a>. <span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
More generally, in Separation Logic, if a specification triple holds,
    then this triple remains valid when we add the same heap predicate to both
    the precondition and the postcondition. This is the "frame" principle, a
    key modularity feature that we'll come back to later on in the course. 
</div>

<div class="doc">
<a id="lab25"></a><h2 class="section">Transfer from one Reference to Another</h2>

<div class="paragraph"> </div>

 Consider the <span class="inlinecode"><span class="id" title="var">transfer</span></span> function, whose code appears below. Recall that,
    to simplify the implementation of the framework used in the course, we
    need to assign a name to every intermediate result. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="transfer" class="idref" href="#transfer"><span class="id" title="definition">transfer</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#938475157e31b8b3433e07bd510fd74f"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a> <a class="idref" href="LibSepReference.html#938475157e31b8b3433e07bd510fd74f"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''s'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''s'"><span class="id" title="notation">s</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#e0633f114fcb17e965cb872e30ce07a<sub>5</sub>"><span class="id" title="notation">:=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''s'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''s'"><span class="id" title="notation">s</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a> <a class="idref" href="LibSepReference.html#e0633f114fcb17e965cb872e30ce07a<sub>5</sub>"><span class="id" title="notation">:=</span></a> 0 <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
<a id="lab26"></a><h4 class="section">Exercise: 1 star, standard, especially useful (triple_transfer)</h4>
 State and prove a lemma called <span class="inlinecode"><span class="id" title="var">triple_transfer</span></span>, to specify the behavior
    of <span class="inlinecode"><span class="id" title="var">transfer</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">q</span></span> in the case where <span class="inlinecode"><span class="id" title="var">p</span></span> and <span class="inlinecode"><span class="id" title="var">q</span></span> denote two distinct
    references. 
</div>
<div class="code">

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab27"></a><h4 class="section">Exercise: 1 star, standard, especially useful (triple_transfer_aliased)</h4>
 State and prove a lemma called <span class="inlinecode"><span class="id" title="var">triple_transfer_aliased</span></span> specifying the
    behavior of <span class="inlinecode"><span class="id" title="var">transfer</span></span> when it is applied twice to the same argument. It
    should take the form <span class="inlinecode"><span class="id" title="var">triple</span></span> <span class="inlinecode">(<span class="id" title="var">transfer</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">p</span>)</span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span>. 
</div>
<div class="code">

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab28"></a><h2 class="section">Specification of Allocation</h2>

<div class="paragraph"> </div>

 Consider the operation <span class="inlinecode"><span class="id" title="var">ref</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span>, which allocates a memory cell with
    contents <span class="inlinecode"><span class="id" title="var">v</span></span>. How can we specify this operation using a triple? The
    precondition of this triple should be the empty heap predicate, written
    <span class="inlinecode"><span class='gray-font'>\</span>[]</span>, because the allocation can execute in an empty state. The
    postcondition should assert that the output value is a pointer <span class="inlinecode"><span class="id" title="var">p</span></span>, such
    that the final state is described by <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">v</span></span>.

<div class="paragraph"> </div>

    It would be tempting to write the postcondition <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">v</span></span>. Yet,
    the triple would be ill-typed, because the postcondition of a triple must
    be a predicate over values, of type <span class="inlinecode"><span class="id" title="var">val</span></span> in the framework, whereas here
    <span class="inlinecode"><span class="id" title="var">p</span></span> is an address, of type <span class="inlinecode"><span class="id" title="var">loc</span></span>. We thus need to write the postcondition
    in the form <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode">(<span class="id" title="var">r</span>:<span class="id" title="var">val</span>)</span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">H'</span></span>, where <span class="inlinecode"><span class="id" title="var">r</span></span> denotes the result value, and
    somehow assert that <span class="inlinecode"><span class="id" title="var">r</span></span> is the value that corresponds to the location <span class="inlinecode"><span class="id" title="var">p</span></span>.
    This value is written <span class="inlinecode"><span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>, where <span class="inlinecode"><span class="id" title="var">val_loc</span></span> denotes the constructor
    that injects locations into the grammar of program values.

<div class="paragraph"> </div>

    To formally quantify the variable <span class="inlinecode"><span class="id" title="var">p</span></span>, we use the existential quantifier
    for heap predicates, written <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span>. The correct postcondition for
    <span class="inlinecode"><span class="id" title="var">ref</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> is thus <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode">(<span class="id" title="var">p</span>:<span class="id" title="var">loc</span>),</span> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">p</span>]</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">v</span>)</span>.
    The complete statement of the specification appears below. It appears as
    a <span class="inlinecode"><span class="id" title="keyword">Parameter</span></span> instead of a <span class="inlinecode"><span class="id" title="keyword">Lemma</span></span>, because the semantics of the primitive
    operation <span class="inlinecode"><span class="id" title="var">ref</span></span> is established in another file, directly with respect to
    the semantics---in <a href="Rules.html"><span class="inlineref">Rules</span></a>. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_ref" class="idref" href="#triple_ref"><span class="id" title="axiom">triple_ref</span></a> : <span class="id" title="keyword">∀</span> (<a id="v:28" class="idref" href="#v:28"><span class="id" title="binder">v</span></a>:<a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:'ref'"><span class="id" title="notation">ref</span></a> <a class="idref" href="Basic.html#v:28"><span class="id" title="variable">v</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:29" class="idref" href="#r:29"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="p:30" class="idref" href="#p:30"><span class="id" title="binder">p</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:29"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <a class="idref" href="Basic.html#p:30"><span class="id" title="variable">p</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#p:30"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#v:28"><span class="id" title="variable">v</span></a>).<br/>
</div>

<div class="doc">
The pattern <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">p</span>,</span> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">p</span>]</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H</span>)</span> occurs whenever a
    function returns a pointer. To improve concision for this frequent pattern,
    we introduce a specific notation, of the form <span class="inlinecode"><span class="id" title="var">funloc</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">H</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Notation</span> <a id="41749fe005eef2f7f0316a63bdabe5a<sub>8</sub>" class="idref" href="#41749fe005eef2f7f0316a63bdabe5a<sub>8</sub>"><span class="id" title="notation">&quot;</span></a>'funloc' p '=&gt;' H" :=<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:32" class="idref" href="#r:32"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="p:33" class="idref" href="#p:33"><span class="id" title="binder">p</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:32"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#val_loc"><span class="id" title="constructor">val_loc</span></a> <span class="id" title="var">p</span><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <span class="id" title="var">H</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 200, <span class="id" title="var">p</span> <span class="id" title="var">ident</span>, <span class="id" title="var">format</span> "'funloc'  p  '=&gt;'  H").<br/>
</div>

<div class="doc">
Using this notation, the specification <span class="inlinecode"><span class="id" title="var">triple_ref</span></span> can be reformulated
    more concisely, as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="triple_ref'" class="idref" href="#triple_ref'"><span class="id" title="axiom">triple_ref'</span></a> : <span class="id" title="keyword">∀</span> (<a id="v:34" class="idref" href="#v:34"><span class="id" title="binder">v</span></a>:<a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:'ref'"><span class="id" title="notation">ref</span></a> <a class="idref" href="Basic.html#v:34"><span class="id" title="variable">v</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#41749fe005eef2f7f0316a63bdabe5a<sub>8</sub>"><span class="id" title="notation">funloc</span></a> <a id="p:37" class="idref" href="#p:37"><span class="id" title="binder">p</span></a> <a class="idref" href="Basic.html#41749fe005eef2f7f0316a63bdabe5a<sub>8</sub>"><span class="id" title="notation">⇒</span></a> <a class="idref" href="Basic.html#p:35"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#v:34"><span class="id" title="variable">v</span></a>).<br/>
</div>

<div class="doc">
The tool CFML, which leverages similar techniques as described in this
    course, leverages type-classes to generalize the notation <span class="inlinecode"><span class="id" title="var">funloc</span></span> to all
    return types. Yet, in order to avoid technical difficulties associated
    with type-classes, we will not go for the general presentation, but
    instead exploit the <span class="inlinecode"><span class="id" title="var">funloc</span></span> notation, specific to the case where the
    return type is a location. For other types, we can quantify over the
    result value explicitly. 
</div>

<div class="doc">
<a id="lab29"></a><h2 class="section">Allocation of a Reference with Greater Contents</h2>

<div class="paragraph"> </div>

 Consider the following function, <span class="inlinecode"><span class="id" title="var">ref_greater</span></span>, which takes as argument
    the address <span class="inlinecode"><span class="id" title="var">p</span></span> of a memory cell with contents <span class="inlinecode"><span class="id" title="var">n</span></span>, allocates a fresh
    memory cell with contents <span class="inlinecode"><span class="id" title="var">n</span>+1</span>, then returns the address of that fresh
    cell. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="ref_greater" class="idref" href="#ref_greater"><span class="id" title="definition">ref_greater</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#590da34eb63eef1c68773c655749c128"><span class="id" title="notation">+</span></a> 1 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'ref'"><span class="id" title="notation">ref</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
The precondition of <span class="inlinecode"><span class="id" title="var">ref_greater</span></span> needs to assert the existence of a cell
    <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. The postcondition of <span class="inlinecode"><span class="id" title="var">ref_greater</span></span> should assert the existence
    of two cells, <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>, where <span class="inlinecode"><span class="id" title="var">q</span></span> denotes the
    location returned by the function. The postcondition is thus written
    <span class="inlinecode"><span class="id" title="var">funloc</span></span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>, which is a shorthand for
    <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode">(<span class="id" title="var">r</span>:<span class="id" title="var">val</span>)</span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">q</span>,</span> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">val_loc</span></span> <span class="inlinecode"><span class="id" title="var">q</span>]</span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_ref_greater" class="idref" href="#triple_ref_greater"><span class="id" title="lemma">triple_ref_greater</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:39" class="idref" href="#p:39"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:40" class="idref" href="#n:40"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#ref_greater"><span class="id" title="definition">ref_greater</span></a> <a class="idref" href="Basic.html#p:39"><span class="id" title="variable">p</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:39"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:40"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#41749fe005eef2f7f0316a63bdabe5a<sub>8</sub>"><span class="id" title="notation">funloc</span></a> <a id="q:43" class="idref" href="#q:43"><span class="id" title="binder">q</span></a> <a class="idref" href="Basic.html#41749fe005eef2f7f0316a63bdabe5a<sub>8</sub>"><span class="id" title="notation">⇒</span></a> <a class="idref" href="Basic.html#p:39"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:40"><span class="id" title="variable">n</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#q:41"><span class="id" title="variable">q</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:40"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">q</span>. <span class="id" title="var">xsimpl</span>. <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab30"></a><h4 class="section">Exercise: 2 stars, standard, especially useful (triple_ref_greater_abstract)</h4>
 State another specification for the function <span class="inlinecode"><span class="id" title="var">ref_greater</span></span> with a
    postcondition that does not reveal the contents of the fresh reference <span class="inlinecode"><span class="id" title="var">q</span></span>,
    but instead only asserts that it is greater than the contents of <span class="inlinecode"><span class="id" title="var">p</span></span>. To
    that end, introduce in the postcondition an existentially quantified
    variable called <span class="inlinecode"><span class="id" title="var">m</span></span>, with <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. This new specification, to be called
    <span class="inlinecode"><span class="id" title="var">triple_ref_greater_abstract</span></span>, should be derived from <span class="inlinecode"><span class="id" title="var">triple_ref_greater</span></span>,
    following the proof pattern employed in <span class="inlinecode"><span class="id" title="var">triple_incr_first_derived</span></span>. 
</div>
<div class="code">

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab31"></a><h2 class="section">Deallocation in Separation Logic</h2>

<div class="paragraph"> </div>

 Separation Logic, in its simplest form, enforces that every piece of
    allocated data is eventually deallocated. Yet, OCaml is a programming
    language equipped with a garbage collector: programs do not contain
    explicit deallocation operations. Thus, concretely, if we consider an
    OCaml program that allocates a reference and that this reference is not
    described in the postcondition, we get stuck in the proof. In what
    follows, we will first describe how the proof gets stuck, then we will
    see how the problem goes away by adding an explicit deallocation operation,
    and we'll point at a later chapter (<a href="Affine.html"><span class="inlineref">Affine</span></a>) for the presentation of
    a generic solution to handling implicit deallocation. 
<div class="paragraph"> </div>

 To begin with, consider the following function, which makes local use of
    a reference, without exposing that reference in the postcondition. This
    function computes the successor of a integer <span class="inlinecode"><span class="id" title="var">n</span></span>. It first stores <span class="inlinecode"><span class="id" title="var">n</span></span> into
    a reference cell, then it increments that reference, and finally it
    returns the new contents of the reference. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="succ_using_incr_attempt" class="idref" href="#succ_using_incr_attempt"><span class="id" title="definition">succ_using_incr_attempt</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:'ref'"><span class="id" title="notation">ref</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basic.html#incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
A call to that function can be specified using an empty precondition and a
    postcondition asserting that the final result is equal to <span class="inlinecode"><span class="id" title="var">n</span>+1</span>. Let us
    investigate how we get stuck on the last step when trying to prove that
    specification. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_succ_using_incr_attempt" class="idref" href="#triple_succ_using_incr_attempt"><span class="id" title="lemma">triple_succ_using_incr_attempt</span></a> : <span class="id" title="keyword">∀</span> (<a id="n:44" class="idref" href="#n:44"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#succ_using_incr_attempt"><span class="id" title="definition">succ_using_incr_attempt</span></a> <a class="idref" href="Basic.html#n:44"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:45" class="idref" href="#r:45"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:45"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#n:44"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>. { <span class="id" title="tactic">auto</span>. }<br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
We get stuck with the unprovable entailment <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class='gray-font'>\</span>[]</span>, where
    the left-hand side describes a state with one reference, whereas the
    right-hand side describes an empty state. There are three possibilities
    to work around the issue. 
<div class="paragraph"> </div>

 The first solution consists of extending the postcondition to account for
    the existence of the reference <span class="inlinecode"><span class="id" title="var">p</span></span>. This yields a provable specification. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_succ_using_incr_attempt'" class="idref" href="#triple_succ_using_incr_attempt'"><span class="id" title="lemma">triple_succ_using_incr_attempt'</span></a> : <span class="id" title="keyword">∀</span> (<a id="n:46" class="idref" href="#n:46"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#succ_using_incr_attempt"><span class="id" title="definition">succ_using_incr_attempt</span></a> <a class="idref" href="Basic.html#n:46"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:47" class="idref" href="#r:47"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:47"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#n:46"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">\</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">∃</span></a> <a id="p:48" class="idref" href="#p:48"><span class="id" title="binder">p</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">,</span></a> <a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#p:48"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:46"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a><a class="idref" href="LibSepReference.html#961b41dcd8e5f7d3252676574333c51d"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xsimpl</span>. { <span class="id" title="tactic">auto</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
However, while the specification above is provable, it is totally
    unsatisfying. Indeed, the piece of postcondition <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">p</span>,</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>
    is of absolutely no use to the caller of the function. Worse, the caller
    will get its own heap predicate polluted with <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">p</span>,</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>,
    with no way of throwing away that predicate. 
<div class="paragraph"> </div>

 A second solution is to alter the code of the program to include an
    explicit free operation, written <span class="inlinecode"><span class="id" title="var">free</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>, for deallocating the reference.
    This operation does not exist in OCaml, but let us nevertheless assume
    it to be able to demonstrate how Separation Logic supports reasoning about
    explicit deallocation. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="succ_using_incr" class="idref" href="#succ_using_incr"><span class="id" title="definition">succ_using_incr</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:'ref'"><span class="id" title="notation">ref</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basic.html#incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">x</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'free'"><span class="id" title="notation">free</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">x</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
This program may be proved correct with respect to the intended
    postcondition <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span>+1]</span>, without the need to mention <span class="inlinecode"><span class="id" title="var">p</span></span>.
    In the proof, shown below, the key step is the last call to <span class="inlinecode"><span class="id" title="var">xapp</span></span>. This
    call is for reasoning about the operation <span class="inlinecode"><span class="id" title="var">free</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>, which consumes (i.e.,
    removes) from the current state the heap predicate of the form <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">_</span></span>.
    At the last proof step, we invoke the tactic <span class="inlinecode"><span class="id" title="var">xval</span></span> for reasoning about
    the return value. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_succ_using_incr" class="idref" href="#triple_succ_using_incr"><span class="id" title="lemma">triple_succ_using_incr</span></a> : <span class="id" title="keyword">∀</span> <a id="n:49" class="idref" href="#n:49"><span class="id" title="binder">n</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#succ_using_incr"><span class="id" title="definition">succ_using_incr</span></a> <a class="idref" href="Basic.html#n:49"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:50" class="idref" href="#r:50"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:50"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#n:49"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a>1<a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">xapp</span>. <span class="comment">(*&nbsp;reasoning&nbsp;about&nbsp;the&nbsp;call&nbsp;<span class="inlinecode"><span class="id" title="var">free</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="var">xval</span>. <span class="comment">(*&nbsp;reasoning&nbsp;about&nbsp;the&nbsp;return&nbsp;value,&nbsp;named&nbsp;<span class="inlinecode"><span class="id" title="var">x</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="var">xsimpl</span>. <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The third solution consists of considering a generalized version of
    Separation Logic in which specific classes of heap predicates may be
    freely discarded from the current state, at any point during the proofs.
    This variant is described in the chapter <a href="Affine.html"><span class="inlineref">Affine</span></a>. 
</div>

<div class="doc">
<a id="lab32"></a><h2 class="section">Combined Reading and Freeing of a Reference</h2>

<div class="paragraph"> </div>

 The function <span class="inlinecode"><span class="id" title="var">get_and_free</span></span> takes as argument the address <span class="inlinecode"><span class="id" title="var">p</span></span> of a
    reference cell. It reads the contents of that cell, frees the cell,
    and returns its contents. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="get_and_free" class="idref" href="#get_and_free"><span class="id" title="definition">get_and_free</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">fun</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#580b26347bf7760f2fc76a1944e0af<sub>93</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''v'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''v'"><span class="id" title="notation">v</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'free'"><span class="id" title="notation">free</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''v'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''v'"><span class="id" title="notation">v</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
<a id="lab33"></a><h4 class="section">Exercise: 2 stars, standard, especially useful (triple_get_and_free)</h4>
 Prove the correctness of the function <span class="inlinecode"><span class="id" title="var">get_and_free</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_get_and_free" class="idref" href="#triple_get_and_free"><span class="id" title="lemma">triple_get_and_free</span></a> : <span class="id" title="keyword">∀</span> <a id="p:51" class="idref" href="#p:51"><span class="id" title="binder">p</span></a> <a id="v:52" class="idref" href="#v:52"><span class="id" title="binder">v</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#get_and_free"><span class="id" title="definition">get_and_free</span></a> <a class="idref" href="Basic.html#p:51"><span class="id" title="variable">p</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:51"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#v:52"><span class="id" title="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:53" class="idref" href="#r:53"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:53"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#v:52"><span class="id" title="variable">v</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="code">

<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">triple_get_and_free</span> : <span class="id" title="var">triple</span>.<br/>
</div>

<div class="doc">
<a id="lab34"></a><h1 class="section">Recursive Functions</h1>

</div>

<div class="doc">
<a id="lab35"></a><h2 class="section">Axiomatization of the Mathematical Factorial Function</h2>

<div class="paragraph"> </div>

 Our next example consists of a program that evaluates the factorial
    function. To specify this function, we consider a Coq axiomatization
    of the mathematical factorial function, named <span class="inlinecode"><span class="id" title="var">facto</span></span>. Here again, we use
    the <span class="inlinecode"><span class="id" title="keyword">Parameter</span></span> keyword because we are not interested in the details of
    the implementation of this function. We wrap the axiomatization inside
    a module, so that we can later refer to it from other files. 
</div>
<div class="code">

<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Import</span> <a id="Facto" class="idref" href="#Facto"><span class="id" title="module">Facto</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Parameter</span> <a id="Facto.facto" class="idref" href="#Facto.facto"><span class="id" title="axiom">facto</span></a> : <span class="id" title="notation">int</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="notation">int</span>.<br/>
</div>

<div class="doc">
The factorial of <span class="inlinecode">0</span> and <span class="inlinecode">1</span> is equal to <span class="inlinecode">1</span>, and the factorial of <span class="inlinecode"><span class="id" title="var">n</span></span>
    for <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;</span> <span class="inlinecode">1</span> is equal to <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">facto</span></span> <span class="inlinecode">(<span class="id" title="var">n</span>-1)</span>. Note that we purposely leave
    unspecified the value of <span class="inlinecode"><span class="id" title="var">facto</span></span> on negative arguments. 
</div>
<div class="code">

<span class="id" title="keyword">Parameter</span> <a id="Facto.facto_init" class="idref" href="#Facto.facto_init"><span class="id" title="axiom">facto_init</span></a> : <span class="id" title="keyword">∀</span> <a id="n:55" class="idref" href="#n:55"><span class="id" title="binder">n</span></a>,<br/>
&nbsp;&nbsp;0 <span class="id" title="notation">≤</span> <a class="idref" href="Basic.html#n:55"><span class="id" title="variable">n</span></a> <span class="id" title="notation">≤</span> 1 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#Facto.facto"><span class="id" title="axiom">facto</span></a> <a class="idref" href="Basic.html#n:55"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 1.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Parameter</span> <a id="Facto.facto_step" class="idref" href="#Facto.facto_step"><span class="id" title="axiom">facto_step</span></a> : <span class="id" title="keyword">∀</span> <a id="n:57" class="idref" href="#n:57"><span class="id" title="binder">n</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#n:57"><span class="id" title="variable">n</span></a> <span class="id" title="notation">&gt;</span> 1 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#Facto.facto"><span class="id" title="axiom">facto</span></a> <a class="idref" href="Basic.html#n:57"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#n:57"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#d3ea1afb7d81263dc23c4eb0da2a3c4e"><span class="id" title="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#d3ea1afb7d81263dc23c4eb0da2a3c4e"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#Facto.facto"><span class="id" title="axiom">facto</span></a> (<a class="idref" href="Basic.html#n:57"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#::Z_scope:x_'-'_x"><span class="id" title="notation">-</span></a>1)<a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#d3ea1afb7d81263dc23c4eb0da2a3c4e"><span class="id" title="notation">)</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <a class="idref" href="Basic.html#Facto"><span class="id" title="module">Facto</span></a>.<br/>
</div>

<div class="doc">
<a id="lab36"></a><h2 class="section">A Partial Recursive Function, Without State</h2>

<div class="paragraph"> </div>

 As a warm-up, we first consider consider a recursive function that does
    not involve any mutable state. The program function <span class="inlinecode"><span class="id" title="var">factorec</span></span> computes
    the factorial of its argument: it implements the logical function <span class="inlinecode"><span class="id" title="var">facto</span></span>.

<div class="paragraph"> </div>

<span class="inlinecode-ocaml">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="keyword">rec</span> <span class="id" title="var">factorec</span> <span class="id" title="var">n</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">n</span> ≤ 1 <span class="id" title="keyword">then</span> 1 <span class="id" title="keyword">else</span> <span class="id" title="var">n</span> * <span class="id" title="var">factorec</span> (<span class="id" title="var">n</span>-1)
</span>
<div class="paragraph"> </div>

    The corresponding code in A-normal form is slightly more verbose. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="factorec" class="idref" href="#factorec"><span class="id" title="definition">factorec</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#7809db93a49fc4341c1251bb4de79a<sub>62</sub>"><span class="id" title="notation">fix</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">f</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#7809db93a49fc4341c1251bb4de79a<sub>62</sub>"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#9ff281c3872a35aaa31aa0ff16f0b827"><span class="id" title="notation">≤</span></a> 1 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'else'_x"><span class="id" title="notation">if</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'else'_x"><span class="id" title="notation">then</span></a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'else'_x"><span class="id" title="notation">else</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">x</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:x_'-'_x"><span class="id" title="notation">-</span></a> 1 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''y'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''y'"><span class="id" title="notation">y</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">f</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">x</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''n'"><span class="id" title="notation">n</span></a> <a class="idref" href="LibSepReference.html#8687bd0de562fa8820387e422eed2db<sub>3</sub>"><span class="id" title="notation">*</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''y'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''y'"><span class="id" title="notation">y</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
A call to <span class="inlinecode"><span class="id" title="var">factorec</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> can be specified as follows:

<div class="paragraph"> </div>

<ul class="doclist">
<li> the initial state is empty,

</li>
<li> the final state is empty,

</li>
<li> the result value <span class="inlinecode"><span class="id" title="var">r</span></span> is such that <span class="inlinecode"><span class="id" title="var">r</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">facto</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, when <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0</span>.

</li>
</ul>

<div class="paragraph"> </div>

    In case the argument is negative (i.e., <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode">0</span>), we have two choices:

<div class="paragraph"> </div>

<ul class="doclist">
<li> either we explicitly specify that the result is <span class="inlinecode">1</span> in this case,

</li>
<li> or we rule out this possibility by requiring <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0</span>.

</li>
</ul>

<div class="paragraph"> </div>

    Let us follow the second approach, in order to illustrate the
    specification of partial functions.

<div class="paragraph"> </div>

    There are two possibilities for expressing the constraint <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0</span>:

<div class="paragraph"> </div>

<ul class="doclist">
<li> either we use as precondition <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">n</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0]</span>,

</li>
<li> or we we use the empty precondition, that is, <span class="inlinecode"><span class='gray-font'>\</span>[]</span>, and we place an
      assumption <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0)</span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">_</span></span> to the front of the triple.

</li>
</ul>

<div class="paragraph"> </div>

    The two presentations are totally equivalent. We prefer the second
    presentation, which tends to improve both the readability of
    specifications and the conciseness of proof scripts. In that style, the
    specification of <span class="inlinecode"><span class="id" title="var">factorec</span></span> is stated as follows. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_factorec" class="idref" href="#triple_factorec"><span class="id" title="lemma">triple_factorec</span></a> : <span class="id" title="keyword">∀</span> <a id="n:59" class="idref" href="#n:59"><span class="id" title="binder">n</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#n:59"><span class="id" title="variable">n</span></a> <span class="id" title="notation">≥</span> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#factorec"><span class="id" title="definition">factorec</span></a> <a class="idref" href="Basic.html#n:59"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#0a700e54c124035039013e87e1a2bcaa"><span class="id" title="notation"><span class='gray-font'>\</span>[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a id="r:60" class="idref" href="#r:60"><span class="id" title="binder">r</span></a> ⇒ <a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation"><span class='gray-font'>\</span>[</span></a><a class="idref" href="Basic.html#r:60"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#facto"><span class="id" title="axiom">facto</span></a> <a class="idref" href="Basic.html#n:59"><span class="id" title="variable">n</span></a><a class="idref" href="LibSepReference.html#d090ebaffe5a082b6a27552ccf013e<sub>09</sub>"><span class="id" title="notation">]</span></a>).<br/>
</div>

<div class="doc">
In general, we prove specifications for recursive functions by exploiting
    a strong induction principle statement ("well-founded induction") that
    allows us to assume, while we try to prove the specification, that the
    specification already holds for any "smaller input". The (well-founded)
    order relation that defines whether an input is smaller than another one
    is specified by the user.

<div class="paragraph"> </div>

    In the specific case of the function <span class="inlinecode"><span class="id" title="var">factorec</span></span>, the input is a
    nonnegative integer <span class="inlinecode"><span class="id" title="var">n</span></span>, so we can assume, by induction hypothesis, that
    the specification already holds for any nonnegative integer smaller than
    <span class="inlinecode"><span class="id" title="var">n</span></span>. Let's walk through the proof script in detail, to see in particular
    how to set up the induction, how we exploit it for reasoning about the
    recursive call, and how we justify that the recursive call is made on a
    smaller input. 
</div>
<div class="code">
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
</div>

<div class="doc">
We set up a proof by induction on <span class="inlinecode"><span class="id" title="var">n</span></span> to obtain an induction hypothesis
    for the recursive calls. The well-founded relation <span class="inlinecode"><span class="id" title="var">downto</span></span> <span class="inlinecode">0</span> captures
    the order on arguments: <span class="inlinecode"><span class="id" title="var">downto</span></span> <span class="inlinecode">0</span> <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode"><span class="id" title="var">j</span></span> asserts that <span class="inlinecode">0</span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">j</span></span> holds.
    The tactic <span class="inlinecode"><span class="id" title="var">induction_wf</span></span>, provided by the TLC library, helps setting up
    well-founded inductions. It is exploited as follows. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="var">induction_wf</span> <span class="id" title="var">IH</span>: (<span class="id" title="definition">downto</span> 0) <span class="id" title="var">n</span>.<br/>
</div>

<div class="doc">
Observe the induction hypothesis <span class="inlinecode"><span class="id" title="var">IH</span></span>. By unfolding <span class="inlinecode"><span class="id" title="var">downto</span></span> as done in
    the next step, we can see that this hypothesis asserts that the
    specification that we are trying to prove already holds for arguments that
    are smaller than the current argument <span class="inlinecode"><span class="id" title="var">n</span></span>, and that are greater than or
    equal to <span class="inlinecode">0</span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="definition">downto</span> <span class="id" title="keyword">in</span> <span class="id" title="var">IH</span>. <span class="comment">(*&nbsp;optional&nbsp;*)</span><br/>
</div>

<div class="doc">
We may then begin the interactive verification proof. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">Hn</span>. <span class="id" title="var">xwp</span>.<br/>
</div>

<div class="doc">
We reason about the evaluation of the boolean condition <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">1</span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">xapp</span>.<br/>
</div>

<div class="doc">
The result of the evaluation of <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">1</span> in the source program is
    described by the boolean value <span class="inlinecode"><span class="id" title="var">isTrue</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">1)</span>, which appears in the
    <span class="inlinecode"><span class="id" title="var">CODE</span></span> section after <span class="inlinecode"><span class="id" title="var">Ifval</span></span>. The operation <span class="inlinecode"><span class="id" title="var">isTrue</span></span> is provided by the
    TLC library as a conversion function from <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> to <span class="inlinecode"><span class="id" title="var">bool</span></span>. The use of
    such a conversion function (which leverages classical logic) greatly
    simplifies the process of automatically performing substitutions after
    calls to <span class="inlinecode"><span class="id" title="var">xapp</span></span>.  We next perform the case analysis on the test <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">1</span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">xif</span>.<br/>
</div>

<div class="doc">
Doing so gives two cases.  In the "then" branch, we can assume <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">1</span>. 
</div>
<div class="code">
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">C</span>.<br/>
</div>

<div class="doc">
Here, the return value is <span class="inlinecode">1</span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">xval</span>. <span class="id" title="var">xsimpl</span>.<br/>
</div>

<div class="doc">
We check that <span class="inlinecode">1</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">facto</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> when <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">1</span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Basic.html#facto_init"><span class="id" title="axiom">facto_init</span></a>. <span class="id" title="var">math</span>. <span class="id" title="var">math</span>. }<br/>
</div>

<div class="doc">
In the "else" branch, we can assume <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;</span> <span class="inlinecode">1</span>. 
</div>
<div class="code">
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">C</span>.<br/>
</div>

<div class="doc">
We reason about the evaluation of <span class="inlinecode"><span class="id" title="var">n</span>-1</span> 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">xapp</span>.<br/>
</div>

<div class="doc">
We reason about the recursive call, implicitly exploiting the induction
    hypothesis <span class="inlinecode"><span class="id" title="var">IH</span></span> with <span class="inlinecode"><span class="id" title="var">n</span>-1</span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">xapp</span>.<br/>
</div>

<div class="doc">
We justify that the recursive call is indeed made on a smaller argument
    than the current one, that is, a nonnegative integer smaller than <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">math</span>. }<br/>
</div>

<div class="doc">
We justify that the recursive call is made to a nonnegative argument,
    as required by the specification. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">math</span>. }<br/>
</div>

<div class="doc">
We reason about the multiplication <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">facto</span>(<span class="id" title="var">n</span>-1)</span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">xapp</span>.<br/>
</div>

<div class="doc">
We check that <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">facto</span></span> <span class="inlinecode">(<span class="id" title="var">n</span>-1)</span> matches <span class="inlinecode"><span class="id" title="var">facto</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">xsimpl</span>. <span class="id" title="tactic">rewrite</span> (@<a class="idref" href="Basic.html#facto_step"><span class="id" title="axiom">facto_step</span></a> <span class="id" title="var">n</span>). <span class="id" title="var">math</span>. <span class="id" title="var">math</span>. }<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab37"></a><h2 class="section">A Recursive Function with State</h2>

<div class="paragraph"> </div>

 Let's now tackle a recursive function involving some mutable state. The
    function <span class="inlinecode"><span class="id" title="var">repeat_incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> makes <span class="inlinecode"><span class="id" title="var">m</span></span> times a call to <span class="inlinecode"><span class="id" title="var">incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>. Here, <span class="inlinecode"><span class="id" title="var">m</span></span>
    is assumed to be a nonnegative value.

<div class="paragraph"> </div>

<span class="inlinecode-ocaml">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="keyword">rec</span> <span class="id" title="var">repeat_incr</span> <span class="id" title="var">p</span> <span class="id" title="var">m</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">m</span> &gt; 0 <span class="id" title="keyword">then</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">incr</span> <span class="id" title="var">p</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">repeat_incr</span> <span class="id" title="var">p</span> (<span class="id" title="var">m</span> - 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
</span>
<div class="paragraph"> </div>

    In the concrete syntax for programs, conditionals without an 'else' branch
    are written <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode"><span class="id" title="var">t<sub>2</sub></span></span> <span class="inlinecode"><span class="id" title="keyword">end</span></span>. The keyword <span class="inlinecode"><span class="id" title="keyword">end</span></span> avoids ambiguities in
    cases where this construct is followed by a semicolon. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="repeat_incr" class="idref" href="#repeat_incr"><span class="id" title="definition">repeat_incr</span></a> : <a class="idref" href="LibSepReference.html#val"><span class="id" title="inductive">val</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#04af5112f77d94e84bf2cc7677bd575d"><span class="id" title="notation">fix</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">f</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#04af5112f77d94e84bf2cc7677bd575d"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:x_'&gt;'_x"><span class="id" title="notation">&gt;</span></a> 0 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'end'"><span class="id" title="notation">if</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'end'"><span class="id" title="notation">then</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basic.html#incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">x</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:x_'-'_x"><span class="id" title="notation">-</span></a> 1 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">f</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''x'"><span class="id" title="notation">x</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'end'"><span class="id" title="notation">end</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
The specification for <span class="inlinecode"><span class="id" title="var">repeat_incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> requires that the initial state
    contains a reference <span class="inlinecode"><span class="id" title="var">p</span></span> with some integer contents <span class="inlinecode"><span class="id" title="var">n</span></span>, that is,
    <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. Its postcondition asserts that the resulting state is
    <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span>+<span class="id" title="var">m</span>)</span>, which is the result after incrementing <span class="inlinecode"><span class="id" title="var">m</span></span> times the
    reference <span class="inlinecode"><span class="id" title="var">p</span></span>. Observe that this postcondition is only valid under the
    assumption that <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0</span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_repeat_incr" class="idref" href="#triple_repeat_incr"><span class="id" title="lemma">triple_repeat_incr</span></a> : <span class="id" title="keyword">∀</span> (<a id="m:61" class="idref" href="#m:61"><span class="id" title="binder">m</span></a> <a id="n:62" class="idref" href="#n:62"><span class="id" title="binder">n</span></a>:<span class="id" title="notation">int</span>) (<a id="p:63" class="idref" href="#p:63"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#m:61"><span class="id" title="variable">m</span></a> <span class="id" title="notation">≥</span> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#repeat_incr"><span class="id" title="definition">repeat_incr</span></a> <a class="idref" href="Basic.html#p:63"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#m:61"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:63"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:62"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:63"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:62"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> <a class="idref" href="Basic.html#m:61"><span class="id" title="variable">m</span></a><a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
</div>

<div class="doc">
<a id="lab38"></a><h4 class="section">Exercise: 2 stars, standard, especially useful (triple_repeat_incr)</h4>
 Prove the specification of the function <span class="inlinecode"><span class="id" title="var">repeat_incr</span></span>, by following the
    template of the proof of <span class="inlinecode"><span class="id" title="var">triple_factorec'</span></span>. Hint: begin the proof with
    <span class="inlinecode"><span class="id" title="tactic">intros</span></span> <span class="inlinecode"><span class="id" title="var">m</span>.</span> <span class="inlinecode"><span class="id" title="var">induction_wf</span></span> <span class="inlinecode"><span class="id" title="var">IH</span>:</span> <span class="inlinecode">...</span>, but make sure to not leave <span class="inlinecode"><span class="id" title="var">n</span></span> in the
    goal, otherwise the induction principle that you obtain is too weak. 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

 In the previous examples of recursive functions, the induction was always
    performed on the first argument quantified in the specification. When the
    decreasing argument is not the first one, additional manipulations are
    required for re-generalizing into the goal the variables that may change
    during the course of the induction. Here is an example illustrating how to
    deal with such a situation. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_repeat_incr'" class="idref" href="#triple_repeat_incr'"><span class="id" title="lemma">triple_repeat_incr'</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:64" class="idref" href="#p:64"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:65" class="idref" href="#n:65"><span class="id" title="binder">n</span></a> <a id="m:66" class="idref" href="#m:66"><span class="id" title="binder">m</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#m:66"><span class="id" title="variable">m</span></a> <span class="id" title="notation">≥</span> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#repeat_incr"><span class="id" title="definition">repeat_incr</span></a> <a class="idref" href="Basic.html#p:64"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#m:66"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:64"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:65"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:64"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:65"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> <a class="idref" href="Basic.html#m:66"><span class="id" title="variable">m</span></a><a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
</div>

<div class="doc">
First, introduces all variables and hypotheses. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">Hm</span>.<br/>
</div>

<div class="doc">
Next, generalize those that are not constant during the recursion. We use
    the TLC tactic <span class="inlinecode"><span class="id" title="var">gen</span></span>, which is a shorthand for <span class="inlinecode"><span class="id" title="tactic">generalize</span></span> <span class="inlinecode"><span class="id" title="tactic">dependent</span></span>s. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">gen</span> <span class="id" title="var">n</span> <span class="id" title="var">Hm</span>.<br/>
</div>

<div class="doc">
Then, set up the induction. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">induction_wf</span> <span class="id" title="var">IH</span>: (<span class="id" title="definition">downto</span> 0) <span class="id" title="var">m</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="definition">downto</span> <span class="id" title="keyword">in</span> <span class="id" title="var">IH</span>.<br/>
</div>

<div class="doc">
Finally, re-introduce the generalized hypotheses. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
</div>

<div class="doc">
The rest of the proof is exactly the same as before. 
</div>
<div class="code">
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
<a id="lab39"></a><h2 class="section">Trying to Prove Incorrect Specifications</h2>

<div class="paragraph"> </div>

 We established for <span class="inlinecode"><span class="id" title="var">repeat_incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> a specification featuring the
    hypothesis <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0</span>, but what if we did omit this hypothesis? At which step
    would we get stuck in the proof? What feedback would we get at that step?

<div class="paragraph"> </div>

    Certainly, we expect the proof to get stuck because if <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode">0</span>. Indeed, in
    that case, the call to <span class="inlinecode"><span class="id" title="var">repeat_incr</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> terminates immediately, thus the
    final state is <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>, like the initial state, and this final state does
    not match the claimed postcondition <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>. Let us investigate how
    the proof of lemma <span class="inlinecode"><span class="id" title="var">triple_repeat_incr</span></span> breaks. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_repeat_incr_incorrect" class="idref" href="#triple_repeat_incr_incorrect"><span class="id" title="lemma">triple_repeat_incr_incorrect</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:67" class="idref" href="#p:67"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:68" class="idref" href="#n:68"><span class="id" title="binder">n</span></a> <a id="m:69" class="idref" href="#m:69"><span class="id" title="binder">m</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#repeat_incr"><span class="id" title="definition">repeat_incr</span></a> <a class="idref" href="Basic.html#p:67"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#m:69"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:67"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:68"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:67"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:68"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> <a class="idref" href="Basic.html#m:69"><span class="id" title="variable">m</span></a><a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">revert</span> <span class="id" title="var">n</span>. <span class="id" title="var">induction_wf</span> <span class="id" title="var">IH</span>: (<span class="id" title="definition">downto</span> 0) <span class="id" title="var">m</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="definition">downto</span> <span class="id" title="keyword">in</span> <span class="id" title="var">IH</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">xwp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xif</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">C</span>.<br/>
&nbsp;&nbsp;{ <span class="comment">(*&nbsp;In&nbsp;the&nbsp;'then'&nbsp;branch:&nbsp;<span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&gt;</span> <span class="inlinecode">0</span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. <span class="id" title="var">xapp</span>. { <span class="id" title="var">math</span>. } <span class="id" title="var">xsimpl</span>. <span class="id" title="var">math</span>. }<br/>
&nbsp;&nbsp;{ <span class="comment">(*&nbsp;In&nbsp;the&nbsp;'else'&nbsp;branch:&nbsp;<span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">0</span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">xval</span>.<br/>
</div>

<div class="doc">
At this point, we are requested to justify that the current state <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>
    matches the postcondition <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>, which amounts to proving
    <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">xsimpl</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
When the specification features the assumption <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0</span>, we can prove this
    equality because the fact that we are in the else branch means that
    <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">0</span>, thus <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>. However, without the assumption <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≥</span> <span class="inlinecode">0</span>, the value
    of <span class="inlinecode"><span class="id" title="var">m</span></span> could very well be negative. In that case, the equality <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span>
    is unprovable. As a user, the proof obligation <span class="inlinecode">(<span class="id" title="var">m</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">0)</span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>
    gives us a very strong hint on the fact that either the code or the
    specification is not handling the case <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode">0</span> properly. This concludes
    our example attempt at proving an incorrect specification. 
<div class="paragraph"> </div>

 In passing, we note that there exists a valid specification for
    <span class="inlinecode"><span class="id" title="var">repeat_incr</span></span> that does not constrain <span class="inlinecode"><span class="id" title="var">m</span></span> but instead specifies that,
    regardless of the value of <span class="inlinecode"><span class="id" title="var">m</span></span>, the state evolves from <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> to
    <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">max</span></span> <span class="inlinecode">0</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>. The corresponding proof scripts exploits two
    characteristic properties of the function <span class="inlinecode"><span class="id" title="var">max</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="max_l" class="idref" href="#max_l"><span class="id" title="lemma">max_l</span></a> : <span class="id" title="keyword">∀</span> <a id="n:70" class="idref" href="#n:70"><span class="id" title="binder">n</span></a> <a id="m:71" class="idref" href="#m:71"><span class="id" title="binder">m</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#n:70"><span class="id" title="variable">n</span></a> <span class="id" title="notation">≥</span> <a class="idref" href="Basic.html#m:71"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<span class="id" title="definition">max</span> <a class="idref" href="Basic.html#n:70"><span class="id" title="variable">n</span></a> <a class="idref" href="Basic.html#m:71"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#n:70"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="definition">max</span>. <span class="id" title="var">case_if</span>; <span class="id" title="var">math</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <a id="max_r" class="idref" href="#max_r"><span class="id" title="lemma">max_r</span></a> : <span class="id" title="keyword">∀</span> <a id="n:72" class="idref" href="#n:72"><span class="id" title="binder">n</span></a> <a id="m:73" class="idref" href="#m:73"><span class="id" title="binder">m</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#n:72"><span class="id" title="variable">n</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="Basic.html#m:73"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<span class="id" title="definition">max</span> <a class="idref" href="Basic.html#n:72"><span class="id" title="variable">n</span></a> <a class="idref" href="Basic.html#m:73"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basic.html#m:73"><span class="id" title="variable">m</span></a>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="id" title="var">introv</span> <span class="id" title="var">M</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="definition">max</span>. <span class="id" title="var">case_if</span>; <span class="id" title="var">math</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Here is the most general specification for the function <span class="inlinecode"><span class="id" title="var">repeat_incr</span></span>. 
<div class="paragraph"> </div>

<a id="lab40"></a><h4 class="section">Exercise: 2 stars, standard, optional (triple_repeat_incr')</h4>
 Prove the general specification for the function <span class="inlinecode"><span class="id" title="var">repeat_incr</span></span>, covering
    also the case <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode">0</span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_repeat_incr'" class="idref" href="#triple_repeat_incr'"><span class="id" title="lemma">triple_repeat_incr'</span></a> : <span class="id" title="keyword">∀</span> (<a id="p:74" class="idref" href="#p:74"><span class="id" title="binder">p</span></a>:<a class="idref" href="LibSepReference.html#loc"><span class="id" title="definition">loc</span></a>) (<a id="n:75" class="idref" href="#n:75"><span class="id" title="binder">n</span></a> <a id="m:76" class="idref" href="#m:76"><span class="id" title="binder">m</span></a>:<span class="id" title="notation">int</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#repeat_incr"><span class="id" title="definition">repeat_incr</span></a> <a class="idref" href="Basic.html#p:74"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#m:76"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:74"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:75"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:74"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:75"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> <span class="id" title="definition">max</span> 0 <a class="idref" href="Basic.html#m:76"><span class="id" title="variable">m</span></a><a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab41"></a><h2 class="section">A Recursive Function Involving two References</h2>

<div class="paragraph"> </div>

 Consider the function <span class="inlinecode"><span class="id" title="var">step_transfer</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">q</span></span>, which repeatedly increments a
    reference <span class="inlinecode"><span class="id" title="var">p</span></span> and decrements a reference <span class="inlinecode"><span class="id" title="var">q</span></span>, as long as the contents of <span class="inlinecode"><span class="id" title="var">q</span></span>
    is positive.

<div class="paragraph"> </div>

<span class="inlinecode-ocaml">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="keyword">rec</span> <span class="id" title="var">step_transfer</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> !<span class="id" title="var">q</span> &gt; 0 <span class="id" title="keyword">then</span> (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">incr</span> <span class="id" title="var">p</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">decr</span> <span class="id" title="var">q</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">step_transfer</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
</span>
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="step_transfer" class="idref" href="#step_transfer"><span class="id" title="definition">step_transfer</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="LibSepReference.html#04af5112f77d94e84bf2cc7677bd575d"><span class="id" title="notation">fix</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">f</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a> <a class="idref" href="LibSepReference.html#04af5112f77d94e84bf2cc7677bd575d"><span class="id" title="notation">⇒</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepReference.html#27f9d9ef09cb3e20c393642accbfc5d<sub>1</sub>"><span class="id" title="notation">!</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">let</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a> <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">=</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''m'"><span class="id" title="notation">m</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:x_'&gt;'_x"><span class="id" title="notation">&gt;</span></a> 0 <a class="idref" href="LibSepReference.html#3a3686de54cc1093527e5e95b371bea7"><span class="id" title="notation">in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'end'"><span class="id" title="notation">if</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''b'"><span class="id" title="notation">b</span></a> <a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'end'"><span class="id" title="notation">then</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basic.html#incr"><span class="id" title="definition">incr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#DemoPrograms.Def_decr.decr"><span class="id" title="definition">decr</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a><a class="idref" href="LibSepReference.html#56accb00428c2a6753c1055752721c<sub>75</sub>"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''f'"><span class="id" title="notation">f</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''p'"><span class="id" title="notation">p</span></a> <a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">'</span></a><a class="idref" href="LibSepVar.html#NotationForVariables.:trm:trm_scope:'''q'"><span class="id" title="notation">q</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#:trm:trm_scope:'if'_x_'then'_x_'end'"><span class="id" title="notation">end</span></a> <a class="idref" href="LibSepReference.html#e0b85224b7295b880f5ac68dccd380d<sub>1</sub>"><span class="id" title="notation">}&gt;</span></a>.<br/>
</div>

<div class="doc">
The specification of <span class="inlinecode"><span class="id" title="var">step_transfer</span></span> is essentially the same as that of the
    function <span class="inlinecode"><span class="id" title="var">transfer</span></span> presented previously, the only difference being that we
    here assume the contents of <span class="inlinecode"><span class="id" title="var">q</span></span> to be nonnegative. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <a id="triple_step_transfer" class="idref" href="#triple_step_transfer"><span class="id" title="lemma">triple_step_transfer</span></a> : <span class="id" title="keyword">∀</span> <a id="p:77" class="idref" href="#p:77"><span class="id" title="binder">p</span></a> <a id="q:78" class="idref" href="#q:78"><span class="id" title="binder">q</span></a> <a id="n:79" class="idref" href="#n:79"><span class="id" title="binder">n</span></a> <a id="m:80" class="idref" href="#m:80"><span class="id" title="binder">m</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basic.html#m:80"><span class="id" title="variable">m</span></a> <span class="id" title="notation">≥</span> 0 <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="LibSepReference.html#triple"><span class="id" title="definition">triple</span></a> (<a class="idref" href="Basic.html#step_transfer"><span class="id" title="definition">step_transfer</span></a> <a class="idref" href="Basic.html#p:77"><span class="id" title="variable">p</span></a> <a class="idref" href="Basic.html#q:78"><span class="id" title="variable">q</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Basic.html#p:77"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#n:79"><span class="id" title="variable">n</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#q:78"><span class="id" title="variable">q</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="Basic.html#m:80"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="Basic.html#p:77"><span class="id" title="variable">p</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">(</span></a><a class="idref" href="Basic.html#n:79"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.ZArith.BinInt.html#46584eddd5fdb16176a10a2843177d3a"><span class="id" title="notation">+</span></a> <a class="idref" href="Basic.html#m:80"><span class="id" title="variable">m</span></a><a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">)</span></a> <a class="idref" href="LibSepReference.html#6e7aeeae3643da4efcca62b993bbca40"><span class="id" title="notation"><span class='gray-font'>\</span>*</span></a> <a class="idref" href="Basic.html#q:78"><span class="id" title="variable">q</span></a> <a class="idref" href="LibSepReference.html#04d59e26c33e7500ff8979242a3d649f"><span class="id" title="notation">~~&gt;</span></a> 0).<br/>
</div>

<div class="doc">
<a id="lab42"></a><h4 class="section">Exercise: 2 stars, standard, especially useful (triple_step_transfer)</h4>
 Verify the function <span class="inlinecode"><span class="id" title="var">step_transfer</span></span>.
    Hint: to set up the induction, follow the pattern shown in
    the proof of <span class="inlinecode"><span class="id" title="var">triple_repeat_incr'</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">using</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>


<div class="doc">
<a id="lab43"></a><h1 class="section">Summary</h1>

<div class="paragraph"> </div>

 This chapter introduces the following notions:

<div class="paragraph"> </div>

<ul class="doclist">
<li> "Heap predicates", which are used to describe memory states in Separation
      Logic.

</li>
<li> "Specification triples", of the form <span class="inlinecode"><span class="id" title="var">triple</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span>, which relate a term
      <span class="inlinecode"><span class="id" title="var">t</span></span>, a precondition <span class="inlinecode"><span class="id" title="var">H</span></span>, and a postcondition <span class="inlinecode"><span class="id" title="var">Q</span></span>.

</li>
<li> "Entailmens", of the form <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class="id" title="var">H'</span></span> or <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">===&gt;</span> <span class="inlinecode"><span class="id" title="var">Q'</span></span>, which assert that a
      pre- or post-condition is weaker than another one.

</li>
<li> "Verification proof obligations", of the form <span class="inlinecode"><span class="id" title="var">PRE</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode"><span class="id" title="var">CODE</span></span> <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode"><span class="id" title="var">POST</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span>, which
      are produced by the framework, and capture triples by leveraging a notion
      of "weakest precondition", presented further in the course.

</li>
<li> Custom proof tactics, called "x-tactics", which are specialized tactics
      for carrying discharging these proof obligations.

</li>
</ul>

<div class="paragraph"> </div>

    Several "heap predicates", used to describe memory states, were presented in
    this first chapter. They include:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">~~&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span>, which describes a memory cell at location <span class="inlinecode"><span class="id" title="var">p</span></span> with contents
      <span class="inlinecode"><span class="id" title="var">n</span></span>,

</li>
<li> <span class="inlinecode"><span class='gray-font'>\</span>[]</span>, which describes an empty state,

</li>
<li> <span class="inlinecode"><span class='gray-font'>\</span>[<span class="id" title="var">P</span>]</span>, which also describes an empty state, and moreover asserts that the
      proposition <span class="inlinecode"><span class="id" title="var">P</span></span> is true,

</li>
<li> <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> <span class="inlinecode"><span class='gray-font'>\</span>*</span> <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span>, which describes a state made of two disjoint parts, one
      satisfying <span class="inlinecode"><span class="id" title="var">H<sub>1</sub></span></span> and another satisfying <span class="inlinecode"><span class="id" title="var">H<sub>2</sub></span></span>,

</li>
<li> <span class="inlinecode"><span class='gray-font'>\</span><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">H</span></span>, which is used to quantify variables in postconditions.

</li>
</ul>

<div class="paragraph"> </div>

    All these heap predicates admit the type <span class="inlinecode"><span class="id" title="var">hprop</span></span>, which describes predicates
    over memory states. Technically, <span class="inlinecode"><span class="id" title="var">hprop</span></span> is defined as <span class="inlinecode"><span class="id" title="var">state</span>→<span class="id" title="keyword">Prop</span></span>.

<div class="paragraph"> </div>

    The verification of practical programs is carried out using x-tactics,
    identified by the leading "x" letter in their name. These tactics include:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">xwp</span></span> to begin a proof,

</li>
<li> <span class="inlinecode"><span class="id" title="var">xapp</span></span> to reason about an application,

</li>
<li> <span class="inlinecode"><span class="id" title="var">xval</span></span> to reason about a return value,

</li>
<li> <span class="inlinecode"><span class="id" title="var">xif</span></span> to reason about a conditional,

</li>
<li> <span class="inlinecode"><span class="id" title="var">xsimpl</span></span> to simplify or prove entailments (<span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode"><span class="id" title="var">H'</span></span> and <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">===&gt;</span> <span class="inlinecode"><span class="id" title="var">Q'</span></span>).

</li>
</ul>

<div class="paragraph"> </div>

    In addition to x-tactics, the proof scripts exploit standard Coq tactics,
    as well as tactics from the TLC library, which provides a bunch of useful,
    general purpose tactics. In this chapter, we used a few TLC tactics:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">math</span></span>, which is a variant of <span class="inlinecode"><span class="id" title="var">lia</span></span> for proving mathematical goals,

</li>
<li> <span class="inlinecode"><span class="id" title="var">induction_wf</span></span>, which sets up proofs by well-founded induction,

</li>
<li> <span class="inlinecode"><span class="id" title="var">gen</span></span>, which is a shorthand for <span class="inlinecode"><span class="id" title="tactic">generalize</span></span> <span class="inlinecode"><span class="id" title="tactic">dependent</span></span>, a tactic
      also useful to set up induction principles. 

</li>
</ul>
</div>

<div class="doc">
<a id="lab44"></a><h1 class="section">Historical Notes</h1>

<div class="paragraph"> </div>

 The key ideas of Separation Logic were devised by John Reynolds, inspired
    in part by older work by <a href="Bib.html#Burstall-1972"><span class="inlineref">[Burstall 1972]</span></a>. Reynolds presented his
    ideas in lectures given in the fall of 1999. The proposed rules turned out
    to be unsound, but <a href="Bib.html#Ishtiaq-and O'Hearn 2001"><span class="inlineref">[Ishtiaq and O'Hearn 2001]</span></a> noticed a strong
    relationship with the logic of bunched implications by
    <a href="Bib.html#O'Hearn-and Pym 1999"><span class="inlineref">[O'Hearn and Pym 1999]</span></a>, leading to ideas on how to set up a sound
    program logic. Soon afterwards, the seminal publications on Separation Logic
    appeared at the CSL workshop <a href="Bib.html#O'Hearn,-Reynolds, and Yang 2001"><span class="inlineref">[O'Hearn, Reynolds, and Yang 2001]</span></a> and at
    the LICS conference <a href="Bib.html#Reynolds-2002"><span class="inlineref">[Reynolds 2002]</span></a>.

<div class="paragraph"> </div>

    The Separation Logic specifications and proof scripts using x-tactics
    presented in this file are directly adapted from the CFML tool (2010-2020),
    developed mainly by Arthur Charguéraud. The notations for Separation Logic
    predicates are directly inspired from those introduced in the Ynot project
    <a href="Bib.html#Chlipala-et al 2009"><span class="inlineref">[Chlipala et al 2009]</span></a>. See chapter <a href="Bib.html"><span class="inlineref">Bib</span></a> for references. 
</div>
<div class="code">

<span class="comment">(*&nbsp;2022-07-21&nbsp;14:32&nbsp;*)</span><br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>